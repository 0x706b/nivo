{"version":3,"file":"component---src-pages-guides-legends-tsx-e4b2a1e57fd1206bbe18.js","mappings":"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","sources":["webpack://nivo-website/./src/components/PageContent.ts","webpack://nivo-website/./src/components/styled.ts","webpack://nivo-website/./src/components/guides/legends/LegendDirection.tsx","webpack://nivo-website/./src/components/guides/legends/LegendItemDirection.tsx","webpack://nivo-website/./src/components/guides/legends/LegendPosition.tsx","webpack://nivo-website/./src/components/guides/legends/SymbolShape.tsx","webpack://nivo-website/./src/pages/guides/legends.tsx","webpack://nivo-website/../src/svg/symbols/SymbolTriangle.tsx","webpack://nivo-website/../src/defaults.ts","webpack://nivo-website/../src/compute.ts","webpack://nivo-website/../src/svg/ContinuousColorsLegendSvg.tsx","webpack://nivo-website/../src/svg/AnchoredContinuousColorsLegendSvg.tsx","webpack://nivo-website/../src/svg/LegendSvgItem.tsx","webpack://nivo-website/../src/svg/symbols/SymbolCircle.tsx","webpack://nivo-website/../src/svg/symbols/SymbolDiamond.tsx","webpack://nivo-website/../src/svg/symbols/SymbolSquare.tsx","webpack://nivo-website/../src/svg/LegendSvg.tsx","webpack://nivo-website/../src/svg/BoxLegendSvg.tsx","webpack://nivo-website/../src/canvas.ts","webpack://nivo-website/../src/hooks.ts","webpack://nivo-website/../src/props.ts"],"sourcesContent":["import styled from 'styled-components'\nimport media from '../theming/mediaQueries'\n\nexport default styled.div`\n    margin: 0 50px;\n    position: relative;\n\n    ${media.tablet`\n        & {\n            margin: 0 30px;\n        }\n    `}\n\n    ${media.mobile`\n        & {\n            margin: 0 15px;\n        }\n    `}\n`\n","import styled from 'styled-components'\nimport media from '../theming/mediaQueries'\n\nexport const FullWidthBanner = styled.div`\n    background: ${({ theme }) => theme.colors.cardBackground};\n    margin-bottom: 40px;\n    padding: 20px;\n`\n\nexport const DescriptionBlock = styled.div`\n    max-width: 800px;\n    margin: 0 auto 50px;\n\n    ${media.tablet`\n        & {\n            margin: 0 15px 50px;\n        }\n    `}\n\n    ${media.mobile`\n        & {\n            margin: 0 15px 50px;\n        }\n    `}\n`\n\nexport const Card = styled.div`\n    background: ${({ theme }) => theme.colors.cardBackground};\n    box-shadow: ${({ theme }) => theme.cardShadow};\n`\n","import React from 'react'\nimport { useTheme } from 'styled-components'\nimport { BoxLegendSvg } from '@nivo/legends'\n\nconst legendProps = {\n    containerWidth: 800,\n    containerHeight: 90,\n    itemWidth: 70,\n    itemHeight: 24,\n}\n\nexport const LegendDirection = () => {\n    const theme = useTheme()\n\n    return (\n        <div>\n            <h2>Legend direction</h2>\n            <p>\n                Legends support two directions, using the <code>direction</code> property,{' '}\n                <code>column</code> or <code>row</code>.\n            </p>\n            <svg width={legendProps.containerWidth} height={legendProps.containerHeight}>\n                <BoxLegendSvg\n                    {...legendProps}\n                    itemTextColor={theme.colors.text}\n                    anchor=\"left\"\n                    direction=\"column\"\n                    data={[\n                        { id: 'a', label: `column`, color: theme.colors.accent },\n                        { id: 'b', label: `column`, color: theme.colors.accent },\n                        { id: 'c', label: `column`, color: theme.colors.accent },\n                    ]}\n                />\n                <BoxLegendSvg\n                    {...legendProps}\n                    itemTextColor={theme.colors.text}\n                    anchor=\"left\"\n                    translateX={260}\n                    direction=\"row\"\n                    data={[\n                        { id: 'a', label: `row`, color: theme.colors.accent },\n                        { id: 'b', label: `row`, color: theme.colors.accent },\n                        { id: 'c', label: `row`, color: theme.colors.accent },\n                    ]}\n                />\n            </svg>\n        </div>\n    )\n}\n","import React from 'react'\nimport { useTheme } from 'styled-components'\nimport { LegendSvgItem } from '@nivo/legends'\n\nconst itemDirections = ['left-to-right', 'right-to-left', 'top-to-bottom', 'bottom-to-top'] as const\n\nexport const LegendItemDirection = () => {\n    const theme = useTheme()\n\n    const itemsProps = {\n        x: 0,\n        y: 0,\n        width: 160,\n        height: 40,\n        data: {\n            id: 'demo',\n            color: theme.colors.accent,\n        },\n    }\n\n    return (\n        <div>\n            <h2>Legend item direction</h2>\n            <p>\n                The <code>itemDirection</code> property defines how symbol and label are positioned.\n                <br />\n                You have 4 available directives:\n            </p>\n            <div\n                style={{\n                    display: 'flex',\n                    justifyContent: 'space-between',\n                }}\n            >\n                {itemDirections.map(dir => (\n                    <div\n                        key={dir}\n                        style={{\n                            background: theme.colors.cardBackground,\n                            padding: '10px 15px',\n                            borderRadius: 2,\n                            display: 'flex',\n                            boxShadow: '0 1px 3px rgba(0, 0, 0, 0.1)',\n                        }}\n                    >\n                        <svg width={itemsProps.width} height={itemsProps.height}>\n                            <LegendSvgItem\n                                {...itemsProps}\n                                textColor={theme.colors.text}\n                                data={{\n                                    ...itemsProps.data,\n                                    label: dir,\n                                }}\n                                direction={dir}\n                            />\n                        </svg>\n                    </div>\n                ))}\n            </div>\n            <p>\n                The behavior is slightly different if you set <code>justify</code> to{' '}\n                <code>true</code> as the label will be positioned at the opposite of the symbol,\n                filling up the whole width/height of the legend's item.\n            </p>\n            <div\n                style={{\n                    display: 'flex',\n                    justifyContent: 'space-between',\n                }}\n            >\n                {itemDirections.map(dir => (\n                    <div\n                        key={dir}\n                        style={{\n                            background: theme.colors.cardBackground,\n                            padding: '9px 12px',\n                            display: 'flex',\n                            boxShadow: '0 1px 2px rgba(0, 0, 0, 0.1)',\n                        }}\n                    >\n                        <svg key={dir} width={itemsProps.width} height={itemsProps.height}>\n                            <LegendSvgItem\n                                {...itemsProps}\n                                textColor={theme.colors.text}\n                                data={{\n                                    ...itemsProps.data,\n                                    label: dir,\n                                }}\n                                direction={dir}\n                                justify={true}\n                            />\n                        </svg>\n                    </div>\n                ))}\n            </div>\n        </div>\n    )\n}\n","import React from 'react'\nimport omit from 'lodash/omit'\nimport { useTheme } from 'styled-components'\nimport { BoxLegendSvg } from '@nivo/legends'\n\nconst anchors = [\n    'top-left',\n    'top',\n    'top-right',\n    'right',\n    'bottom-right',\n    'bottom',\n    'bottom-left',\n    'left',\n    'center',\n] as const\n\nconst translateExamples = [\n    {\n        anchor: 'top',\n        translateX: -160,\n        translateY: -30,\n    },\n    {\n        anchor: 'left',\n        translateX: -30,\n        translateY: 50,\n    },\n    {\n        anchor: 'right',\n        translateX: -30,\n        translateY: -60,\n    },\n    {\n        anchor: 'bottom',\n        translateX: 160,\n        translateY: 30,\n    },\n]\n\nconst margin = 30\nconst legendProps = {\n    containerWidth: 800 - margin * 2,\n    containerHeight: 300 - margin * 2,\n    itemWidth: 120,\n    itemHeight: 16,\n    itemsSpacing: 4,\n    direction: 'column',\n}\n\nexport const LegendPosition = () => {\n    const theme = useTheme()\n\n    return (\n        <div>\n            <h2>Legend position</h2>\n            <p>\n                The legend can be positioned in your chart area using the <code>anchor</code>{' '}\n                property.\n                <br />\n                You have 9 available directives:\n            </p>\n            <svg\n                width={legendProps.containerWidth + margin * 2}\n                height={legendProps.containerHeight + margin * 2}\n                style={{\n                    background: theme.colors.cardBackground,\n                }}\n            >\n                <text\n                    x={legendProps.containerWidth / 2 + margin}\n                    y={margin / 2}\n                    textAnchor=\"middle\"\n                    style={{\n                        alignmentBaseline: 'middle',\n                        fill: theme.colors.textLight,\n                        fontSize: '14px',\n                    }}\n                >\n                    margin\n                </text>\n                <g transform={`translate(${margin},${margin})`}>\n                    <rect\n                        fill={theme.colors.background}\n                        width={legendProps.containerWidth}\n                        height={legendProps.containerHeight}\n                    />\n                    {anchors.map(anchor => (\n                        <BoxLegendSvg\n                            {...legendProps}\n                            itemTextColor={theme.colors.text}\n                            key={anchor}\n                            anchor={anchor}\n                            data={[\n                                { id: 'a', label: anchor, color: theme.colors.accent },\n                                { id: 'b', label: '...', color: theme.colors.accent },\n                                { id: 'c', label: '...', color: theme.colors.accent },\n                            ]}\n                        />\n                    ))}\n                </g>\n            </svg>\n            <p>\n                The legend's anchor is relative to the inner chart area (with margin applied), but\n                depending on the chart type, you'll probably want to move it outside of this area.\n                <br />\n                That's where <code>translateX</code> & <code>translateY</code> come into play,\n                allowing to adjust the legend position from its original anchor.\n            </p>\n            <svg\n                width={legendProps.containerWidth + margin * 2}\n                height={legendProps.containerHeight + margin * 2}\n                style={{\n                    background: theme.colors.cardBackground,\n                }}\n            >\n                <text\n                    x={legendProps.containerWidth / 2 + margin}\n                    y={margin / 2}\n                    textAnchor=\"middle\"\n                    style={{\n                        alignmentBaseline: 'middle',\n                        fill: theme.colors.textLight,\n                        fontSize: '14px',\n                    }}\n                >\n                    margin\n                </text>\n                <g transform={`translate(${margin},${margin})`}>\n                    <rect\n                        fill={theme.colors.background}\n                        width={legendProps.containerWidth}\n                        height={legendProps.containerHeight}\n                    />\n                    {translateExamples.map((example, i) => (\n                        <BoxLegendSvg\n                            key={i}\n                            {...legendProps}\n                            {...omit(example, ['translateX', 'translateY'])}\n                            itemTextColor={theme.colors.text}\n                            data={[\n                                {\n                                    id: example.anchor,\n                                    label: `${example.anchor} (regular)`,\n                                    color: theme.colors.text,\n                                },\n                            ]}\n                        />\n                    ))}\n                    {translateExamples.map((example, i) => (\n                        <BoxLegendSvg\n                            key={i}\n                            {...legendProps}\n                            {...example}\n                            itemTextColor={theme.colors.text}\n                            data={[\n                                {\n                                    id: 'a',\n                                    label: `${example.anchor} (translated)`,\n                                    color: theme.colors.accent,\n                                },\n                                {\n                                    id: 'b',\n                                    label: `translateX: ${example.translateX}`,\n                                    color: theme.colors.accent,\n                                },\n                                {\n                                    id: 'c',\n                                    label: `translateY: ${example.translateY}`,\n                                    color: theme.colors.accent,\n                                },\n                            ]}\n                        />\n                    ))}\n                </g>\n            </svg>\n        </div>\n    )\n}\n","import React from 'react'\nimport { useTheme } from 'styled-components'\nimport { LegendSvgItem } from '@nivo/legends'\nimport { Highlight } from '../../Highlight'\n\nconst shapes = ['square', 'circle', 'triangle', 'diamond'] as const\n\nconst code = `\nconst CustomSymbolShape = ({\n    x, y, size, fill, borderWidth, borderColor\n}) => (\n    <rect\n        x={x}\n        y={y}\n        transform={\\`rotate(45 \\${size/2} \\${size/2})\\`}\n        fill={fill}\n        strokeWidth={borderWidth}\n        stroke={borderColor}\n        width={size}\n        height={size}\n        style={{ pointerEvents: 'none' }}\n    />\n)\n`.trim()\n\nexport const SymbolShape = () => {\n    const theme = useTheme()\n\n    const itemsProps = {\n        x: 0,\n        y: 0,\n        width: 160,\n        height: 40,\n        data: {\n            id: 'demo',\n            color: theme.colors.accent,\n        },\n    }\n\n    return (\n        <div>\n            <h2>Symbol shape</h2>\n            <p>\n                You can customize symbols using <code>symbolShape</code> property.\n            </p>\n            <div\n                style={{\n                    display: 'flex',\n                    justifyContent: 'space-between',\n                }}\n            >\n                {shapes.map(shape => (\n                    <div\n                        key={shape}\n                        style={{\n                            background: theme.colors.cardBackground,\n                            padding: '10px 15px',\n                            borderRadius: 2,\n                            display: 'flex',\n                            boxShadow: '0 1px 3px rgba(0, 0, 0, 0.1)',\n                        }}\n                    >\n                        <svg width={itemsProps.width} height={itemsProps.height}>\n                            <LegendSvgItem\n                                {...itemsProps}\n                                textColor={theme.colors.text}\n                                data={{\n                                    ...itemsProps.data,\n                                    label: shape,\n                                }}\n                                direction=\"left-to-right\"\n                                symbolShape={shape}\n                            />\n                        </svg>\n                    </div>\n                ))}\n            </div>\n            <p>\n                You can also use a custom shape passing a component to <code>symbolShape</code>:\n            </p>\n            <Highlight code={code} language=\"jsx\" />\n        </div>\n    )\n}\n","import React from 'react'\nimport { useTheme } from 'styled-components'\n// @ts-ignore\nimport { themeContext } from '@nivo/core'\nimport Layout from '../../components/Layout'\nimport { Seo } from '../../components/Seo'\nimport PageContent from '../../components/PageContent'\nimport {\n    LegendPosition,\n    LegendDirection,\n    LegendItemDirection,\n    SymbolShape,\n} from '../../components/guides/legends'\nimport { DescriptionBlock } from '../../components/styled'\n\nconst Legends = () => {\n    const theme = useTheme()\n\n    return (\n        <Layout>\n            <themeContext.Provider value={theme.nivo}>\n                <Seo title=\"Legends Guide\" description=\"How to add legends to your nivo charts?\" />\n                <PageContent>\n                    <div className=\"guide__header\">\n                        <h1>Legends</h1>\n                    </div>\n                </PageContent>\n                <DescriptionBlock>\n                    <p>Let's see how to add legends to your charts.</p>\n                    <p>\n                        Legend components are available via the <code>@nivo/legends</code> package,\n                        however it's added as a dependency for most chart packages supporting them,\n                        in most cases you won't have to add it as a direct dependency.\n                    </p>\n                    <LegendPosition />\n                    <LegendDirection />\n                    <LegendItemDirection />\n                    <SymbolShape />\n                </DescriptionBlock>\n            </themeContext.Provider>\n        </Layout>\n    )\n}\n\nexport default Legends\n","import { SymbolProps } from './types'\n\nexport const SymbolTriangle = ({\n    x,\n    y,\n    size,\n    fill,\n    opacity = 1,\n    borderWidth = 0,\n    borderColor = 'transparent',\n}: SymbolProps) => {\n    return (\n        <g transform={`translate(${x},${y})`}>\n            <path\n                d={`\n                M${size / 2} 0\n                L${size} ${size}\n                L0 ${size}\n                L${size / 2} 0\n            `}\n                fill={fill}\n                opacity={opacity}\n                strokeWidth={borderWidth}\n                stroke={borderColor}\n                style={{\n                    pointerEvents: 'none',\n                }}\n            />\n        </g>\n    )\n}\n","import { ContinuousColorsLegendProps } from './types'\n\nexport const continuousColorsLegendDefaults: {\n    length: NonNullable<ContinuousColorsLegendProps['length']>\n    thickness: NonNullable<ContinuousColorsLegendProps['thickness']>\n    direction: NonNullable<ContinuousColorsLegendProps['direction']>\n    tickPosition: NonNullable<ContinuousColorsLegendProps['tickPosition']>\n    tickSize: NonNullable<ContinuousColorsLegendProps['tickSize']>\n    tickSpacing: NonNullable<ContinuousColorsLegendProps['tickSpacing']>\n    tickOverlap: NonNullable<ContinuousColorsLegendProps['tickOverlap']>\n    tickFormat: NonNullable<ContinuousColorsLegendProps['tickFormat']>\n    titleAlign: NonNullable<ContinuousColorsLegendProps['titleAlign']>\n    titleOffset: NonNullable<ContinuousColorsLegendProps['titleOffset']>\n} = {\n    length: 200,\n    thickness: 16,\n    direction: 'row',\n    tickPosition: 'after',\n    tickSize: 4,\n    tickSpacing: 3,\n    tickOverlap: false,\n    tickFormat: (value: number) => `${value}`,\n    titleAlign: 'start',\n    titleOffset: 4,\n}\n","import { scaleLinear } from 'd3-scale'\nimport { getValueFormatter } from '@nivo/core'\nimport { computeContinuousColorScaleColorStops } from '@nivo/colors'\nimport {\n    BoxLegendSvgProps,\n    ContinuousColorsLegendProps,\n    LegendAnchor,\n    LegendItemDirection,\n} from './types'\nimport { continuousColorsLegendDefaults } from './defaults'\n\nconst isObject = <T>(item: unknown): item is T =>\n    typeof item === 'object' && !Array.isArray(item) && item !== null\n\nconst zeroPadding = {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n}\n\nexport const computeDimensions = ({\n    direction,\n    itemsSpacing,\n    padding: _padding,\n    itemCount,\n    itemWidth,\n    itemHeight,\n}: Pick<BoxLegendSvgProps, 'direction' | 'padding'> &\n    Record<'itemsSpacing' | 'itemCount' | 'itemWidth' | 'itemHeight', number>) => {\n    if (typeof _padding !== 'number' && !isObject(_padding)) {\n        throw new Error('Invalid property padding, must be one of: number, object')\n    }\n\n    const padding =\n        typeof _padding === 'number'\n            ? {\n                  top: _padding,\n                  right: _padding,\n                  bottom: _padding,\n                  left: _padding,\n              }\n            : {\n                  ...zeroPadding,\n                  ..._padding,\n              }\n\n    const horizontalPadding = padding.left + padding.right\n    const verticalPadding = padding.top + padding.bottom\n    let width = itemWidth + horizontalPadding\n    let height = itemHeight + verticalPadding\n    const spacing = (itemCount - 1) * itemsSpacing\n    if (direction === 'row') {\n        width = itemWidth * itemCount + spacing + horizontalPadding\n    } else if (direction === 'column') {\n        height = itemHeight * itemCount + spacing + verticalPadding\n    }\n\n    return { width, height, padding }\n}\n\nexport const computePositionFromAnchor = ({\n    anchor,\n    translateX,\n    translateY,\n    containerWidth,\n    containerHeight,\n    width,\n    height,\n}: { anchor: LegendAnchor } & Record<\n    'translateX' | 'translateY' | 'containerWidth' | 'containerHeight' | 'width' | 'height',\n    number\n>) => {\n    let x = translateX\n    let y = translateY\n\n    switch (anchor) {\n        case 'top':\n            x += (containerWidth - width) / 2\n            break\n\n        case 'top-right':\n            x += containerWidth - width\n            break\n\n        case 'right':\n            x += containerWidth - width\n            y += (containerHeight - height) / 2\n            break\n\n        case 'bottom-right':\n            x += containerWidth - width\n            y += containerHeight - height\n            break\n\n        case 'bottom':\n            x += (containerWidth - width) / 2\n            y += containerHeight - height\n            break\n\n        case 'bottom-left':\n            y += containerHeight - height\n            break\n\n        case 'left':\n            y += (containerHeight - height) / 2\n            break\n\n        case 'center':\n            x += (containerWidth - width) / 2\n            y += (containerHeight - height) / 2\n            break\n    }\n\n    return { x, y }\n}\n\nexport const computeItemLayout = ({\n    direction,\n    justify,\n    symbolSize,\n    symbolSpacing,\n    width,\n    height,\n}: {\n    direction: LegendItemDirection\n    justify: boolean\n} & Record<'symbolSize' | 'symbolSpacing' | 'width' | 'height', number>) => {\n    let symbolX\n    let symbolY\n\n    let labelX\n    let labelY\n    let labelAnchor: 'start' | 'middle' | 'end'\n    let labelAlignment: 'alphabetic' | 'central' | 'text-before-edge'\n\n    switch (direction) {\n        case 'left-to-right':\n            symbolX = 0\n            symbolY = (height - symbolSize) / 2\n\n            labelY = height / 2\n            labelAlignment = 'central'\n            if (justify) {\n                labelX = width\n                labelAnchor = 'end'\n            } else {\n                labelX = symbolSize + symbolSpacing\n                labelAnchor = 'start'\n            }\n            break\n\n        case 'right-to-left':\n            symbolX = width - symbolSize\n            symbolY = (height - symbolSize) / 2\n\n            labelY = height / 2\n            labelAlignment = 'central'\n            if (justify) {\n                labelX = 0\n                labelAnchor = 'start'\n            } else {\n                labelX = width - symbolSize - symbolSpacing\n                labelAnchor = 'end'\n            }\n            break\n\n        case 'top-to-bottom':\n            symbolX = (width - symbolSize) / 2\n            symbolY = 0\n\n            labelX = width / 2\n\n            labelAnchor = 'middle'\n            if (justify) {\n                labelY = height\n                labelAlignment = 'alphabetic'\n            } else {\n                labelY = symbolSize + symbolSpacing\n                labelAlignment = 'text-before-edge'\n            }\n            break\n\n        case 'bottom-to-top':\n            symbolX = (width - symbolSize) / 2\n            symbolY = height - symbolSize\n\n            labelX = width / 2\n            labelAnchor = 'middle'\n            if (justify) {\n                labelY = 0\n                labelAlignment = 'text-before-edge'\n            } else {\n                labelY = height - symbolSize - symbolSpacing\n                labelAlignment = 'alphabetic'\n            }\n            break\n    }\n\n    return {\n        symbolX,\n        symbolY,\n        labelX,\n        labelY,\n        labelAnchor,\n        labelAlignment,\n    }\n}\n\nexport const computeContinuousColorsLegend = ({\n    scale,\n    ticks,\n    length = continuousColorsLegendDefaults.length,\n    thickness = continuousColorsLegendDefaults.thickness,\n    direction = continuousColorsLegendDefaults.direction,\n    tickPosition = continuousColorsLegendDefaults.tickPosition,\n    tickSize = continuousColorsLegendDefaults.tickSize,\n    tickSpacing = continuousColorsLegendDefaults.tickSpacing,\n    tickOverlap = continuousColorsLegendDefaults.tickOverlap,\n    tickFormat = continuousColorsLegendDefaults.tickFormat,\n    title,\n    titleAlign = continuousColorsLegendDefaults.titleAlign,\n    titleOffset = continuousColorsLegendDefaults.titleOffset,\n}: ContinuousColorsLegendProps) => {\n    // left to right for `row`, bottom to top for `column`\n    const domain = direction === 'column' ? [...scale.domain()].reverse() : scale.domain()\n\n    const positionScale = scaleLinear().domain(domain)\n    if (domain.length === 2) {\n        // sequential, quantize\n        positionScale.range([0, length])\n    } else if (domain.length === 3) {\n        // diverging\n        positionScale.range([0, length / 2, length])\n    }\n\n    let values: number[]\n    if ('thresholds' in scale) {\n        // quantize\n        values = [domain[0], ...scale.thresholds(), domain[1]]\n    } else {\n        // sequential, diverging\n        values = Array.isArray(ticks) ? ticks : (scale as any).ticks(ticks)\n    }\n\n    const colorStops = computeContinuousColorScaleColorStops(scale, 32)\n\n    const formatValue = getValueFormatter(tickFormat)\n\n    const computedTicks: {\n        x1: number\n        y1: number\n        x2: number\n        y2: number\n        text: string\n        textX: number\n        textY: number\n        textHorizontalAlign: 'start' | 'middle' | 'end'\n        textVerticalAlign: 'alphabetic' | 'central' | 'hanging'\n    }[] = []\n\n    let width: number\n    let height: number\n\n    const gradientX1 = 0\n    let gradientY1 = 0\n    let gradientX2 = 0\n    const gradientY2 = 0\n\n    let titleX: number\n    let titleY: number\n    let titleRotation: number\n    let titleVerticalAlign: 'alphabetic' | 'hanging'\n\n    if (direction === 'row') {\n        width = length\n        height = thickness\n\n        gradientX2 = 1\n\n        let y1: number\n        let y2: number\n\n        let textY: number\n        const textHorizontalAlign = 'middle'\n        let textVerticalAlign: 'alphabetic' | 'hanging'\n\n        titleRotation = 0\n        if (titleAlign === 'start') {\n            titleX = 0\n        } else if (titleAlign === 'middle') {\n            titleX = length / 2\n        } else {\n            titleX = length\n        }\n\n        if (tickPosition === 'before') {\n            y1 = -tickSize\n            y2 = tickOverlap ? thickness : 0\n\n            textY = -tickSize - tickSpacing\n            textVerticalAlign = 'alphabetic'\n\n            titleY = thickness + titleOffset\n            titleVerticalAlign = 'hanging'\n        } else {\n            y1 = tickOverlap ? 0 : thickness\n            y2 = thickness + tickSize\n\n            textY = y2 + tickSpacing\n            textVerticalAlign = 'hanging'\n\n            titleY = -titleOffset\n            titleVerticalAlign = 'alphabetic'\n        }\n\n        values.forEach(value => {\n            const x = positionScale(value)\n\n            computedTicks.push({\n                x1: x,\n                y1,\n                x2: x,\n                y2,\n                text: formatValue(value),\n                textX: x,\n                textY,\n                textHorizontalAlign,\n                textVerticalAlign,\n            })\n        })\n    } else {\n        width = thickness\n        height = length\n\n        gradientY1 = 1\n\n        let x1: number\n        let x2: number\n\n        let textX: number\n        let textHorizontalAlign: 'start' | 'end'\n        const textVerticalAlign = 'central'\n\n        titleRotation = -90\n        if (titleAlign === 'start') {\n            titleY = length\n        } else if (titleAlign === 'middle') {\n            titleY = length / 2\n        } else {\n            titleY = 0\n        }\n\n        if (tickPosition === 'before') {\n            x1 = -tickSize\n            x2 = tickOverlap ? thickness : 0\n\n            textX = x1 - tickSpacing\n            textHorizontalAlign = 'end'\n\n            titleX = thickness + titleOffset\n            titleVerticalAlign = 'hanging'\n        } else {\n            x1 = tickOverlap ? 0 : thickness\n            x2 = thickness + tickSize\n\n            textX = x2 + tickSpacing\n            textHorizontalAlign = 'start'\n\n            titleX = -titleOffset\n            titleVerticalAlign = 'alphabetic'\n        }\n\n        values.forEach(value => {\n            const y = positionScale(value)\n\n            computedTicks.push({\n                x1,\n                y1: y,\n                x2,\n                y2: y,\n                text: formatValue(value),\n                textX,\n                textY: y,\n                textHorizontalAlign,\n                textVerticalAlign,\n            })\n        })\n    }\n\n    return {\n        width,\n        height,\n        gradientX1,\n        gradientY1,\n        gradientX2,\n        gradientY2,\n        colorStops,\n        ticks: computedTicks,\n        titleText: title,\n        titleX,\n        titleY,\n        titleRotation,\n        titleHorizontalAlign: titleAlign,\n        titleVerticalAlign,\n    }\n}\n","import { Fragment } from 'react'\nimport { useTheme } from '@nivo/core'\nimport { computeContinuousColorsLegend } from '../compute'\nimport { ContinuousColorsLegendProps } from '../types'\nimport { continuousColorsLegendDefaults } from '../defaults'\n\nexport const ContinuousColorsLegendSvg = ({\n    scale,\n    ticks,\n    length = continuousColorsLegendDefaults.length,\n    thickness = continuousColorsLegendDefaults.thickness,\n    direction = continuousColorsLegendDefaults.direction,\n    tickPosition = continuousColorsLegendDefaults.tickPosition,\n    tickSize = continuousColorsLegendDefaults.tickSize,\n    tickSpacing = continuousColorsLegendDefaults.tickSpacing,\n    tickOverlap = continuousColorsLegendDefaults.tickOverlap,\n    tickFormat = continuousColorsLegendDefaults.tickFormat,\n    title,\n    titleAlign = continuousColorsLegendDefaults.titleAlign,\n    titleOffset = continuousColorsLegendDefaults.titleOffset,\n}: ContinuousColorsLegendProps) => {\n    const {\n        width,\n        height,\n        gradientX1,\n        gradientY1,\n        gradientX2,\n        gradientY2,\n        ticks: computedTicks,\n        colorStops,\n        titleText,\n        titleX,\n        titleY,\n        titleRotation,\n        titleVerticalAlign,\n        titleHorizontalAlign,\n    } = computeContinuousColorsLegend({\n        scale,\n        ticks,\n        length,\n        thickness,\n        direction,\n        tickPosition,\n        tickSize,\n        tickSpacing,\n        tickOverlap,\n        tickFormat,\n        title,\n        titleAlign,\n        titleOffset,\n    })\n\n    const theme = useTheme()\n\n    const id = `ContinuousColorsLegendSvgGradient.${direction}.${colorStops\n        .map(stop => stop.offset)\n        .join('_')}`\n\n    return (\n        <g>\n            <defs>\n                <linearGradient\n                    id={id}\n                    x1={gradientX1}\n                    y1={gradientY1}\n                    x2={gradientX2}\n                    y2={gradientY2}\n                >\n                    {colorStops.map(colorStop => (\n                        <stop {...colorStop} />\n                    ))}\n                </linearGradient>\n            </defs>\n            {titleText && (\n                <text\n                    transform={`translate(${titleX}, ${titleY}) rotate(${titleRotation})`}\n                    textAnchor={titleHorizontalAlign}\n                    dominantBaseline={titleVerticalAlign}\n                    style={theme.legends.title.text}\n                >\n                    {titleText}\n                </text>\n            )}\n            <rect width={width} height={height} fill={`url(#${id}`} />\n            {computedTicks.map((tick, index) => (\n                <Fragment key={index}>\n                    <line\n                        x1={tick.x1}\n                        y1={tick.y1}\n                        x2={tick.x2}\n                        y2={tick.y2}\n                        style={theme.legends.ticks.line}\n                    />\n                    <text\n                        x={tick.textX}\n                        y={tick.textY}\n                        textAnchor={tick.textHorizontalAlign}\n                        dominantBaseline={tick.textVerticalAlign}\n                        style={theme.legends.ticks.text}\n                    >\n                        {tick.text}\n                    </text>\n                </Fragment>\n            ))}\n        </g>\n    )\n}\n","import { AnchoredContinuousColorsLegendProps } from '../types'\nimport { computePositionFromAnchor } from '../compute'\nimport { continuousColorsLegendDefaults } from '../defaults'\nimport { ContinuousColorsLegendSvg } from './ContinuousColorsLegendSvg'\n\nexport const AnchoredContinuousColorsLegendSvg = ({\n    containerWidth,\n    containerHeight,\n    anchor,\n    translateX = 0,\n    translateY = 0,\n    length = continuousColorsLegendDefaults.length,\n    thickness = continuousColorsLegendDefaults.thickness,\n    direction = continuousColorsLegendDefaults.direction,\n    ...legendProps\n}: AnchoredContinuousColorsLegendProps) => {\n    let width: number\n    let height: number\n    if (direction === 'row') {\n        width = length\n        height = thickness\n    } else {\n        width = thickness\n        height = length\n    }\n\n    const { x, y } = computePositionFromAnchor({\n        anchor,\n        translateX,\n        translateY,\n        containerWidth,\n        containerHeight,\n        width,\n        height,\n    })\n\n    return (\n        <g transform={`translate(${x}, ${y})`}>\n            <ContinuousColorsLegendSvg\n                length={length}\n                thickness={thickness}\n                direction={direction}\n                {...legendProps}\n            />\n        </g>\n    )\n}\n","import { useState, useCallback } from 'react'\nimport * as React from 'react'\nimport { useTheme } from '@nivo/core'\nimport { LegendSvgItemProps } from '../types'\nimport { computeItemLayout } from '../compute'\nimport { SymbolCircle, SymbolDiamond, SymbolSquare, SymbolTriangle } from './symbols'\n\ntype Style = Partial<{\n    itemBackground: string\n    itemOpacity: number\n    itemTextColor: string\n    symbolBorderColor: string\n    symbolBorderWidth: number\n    symbolSize: number\n}>\n\nconst symbolByShape = {\n    circle: SymbolCircle,\n    diamond: SymbolDiamond,\n    square: SymbolSquare,\n    triangle: SymbolTriangle,\n}\n\nexport const LegendSvgItem = ({\n    x,\n    y,\n    width,\n    height,\n    data,\n    direction = 'left-to-right',\n    justify = false,\n    textColor,\n    background = 'transparent',\n    opacity = 1,\n\n    symbolShape = 'square',\n    symbolSize = 16,\n    symbolSpacing = 8,\n    symbolBorderWidth = 0,\n    symbolBorderColor = 'transparent',\n\n    onClick,\n    onMouseEnter,\n    onMouseLeave,\n    toggleSerie,\n\n    effects,\n}: LegendSvgItemProps) => {\n    const [style, setStyle] = useState<Style>({})\n    const theme = useTheme()\n\n    const handleMouseEnter = useCallback(\n        (event: React.MouseEvent<SVGRectElement>) => {\n            if (effects) {\n                const applyEffects = effects.filter(({ on }) => on === 'hover')\n                const style = applyEffects.reduce(\n                    (acc, effect) => ({\n                        ...acc,\n                        ...effect.style,\n                    }),\n                    {}\n                )\n                setStyle(style)\n            }\n\n            onMouseEnter?.(data, event)\n        },\n        [onMouseEnter, data, effects]\n    )\n    const handleMouseLeave = useCallback(\n        (event: React.MouseEvent<SVGRectElement>) => {\n            if (effects) {\n                const applyEffects = effects.filter(({ on }) => on !== 'hover')\n                const style = applyEffects.reduce(\n                    (acc, effect) => ({\n                        ...acc,\n                        ...effect.style,\n                    }),\n                    {}\n                )\n                setStyle(style)\n            }\n\n            onMouseLeave?.(data, event)\n        },\n        [onMouseLeave, data, effects]\n    )\n\n    const { symbolX, symbolY, labelX, labelY, labelAnchor, labelAlignment } = computeItemLayout({\n        direction,\n        justify,\n        symbolSize: style.symbolSize ?? symbolSize,\n        symbolSpacing,\n        width,\n        height,\n    })\n\n    const isInteractive = [onClick, onMouseEnter, onMouseLeave, toggleSerie].some(\n        handler => handler !== undefined\n    )\n\n    const SymbolShape = typeof symbolShape === 'function' ? symbolShape : symbolByShape[symbolShape]\n\n    return (\n        <g\n            transform={`translate(${x},${y})`}\n            style={{\n                opacity: style.itemOpacity ?? opacity,\n            }}\n        >\n            <rect\n                width={width}\n                height={height}\n                fill={style.itemBackground ?? background}\n                style={{\n                    cursor: isInteractive ? 'pointer' : 'auto',\n                }}\n                onClick={event => {\n                    onClick?.(data, event)\n                    toggleSerie?.(data.id)\n                }}\n                onMouseEnter={handleMouseEnter}\n                onMouseLeave={handleMouseLeave}\n            />\n            {React.createElement(SymbolShape, {\n                id: data.id,\n                x: symbolX,\n                y: symbolY,\n                size: style.symbolSize ?? symbolSize,\n                fill: data.fill ?? data.color ?? 'black',\n                borderWidth: style.symbolBorderWidth ?? symbolBorderWidth,\n                borderColor: style.symbolBorderColor ?? symbolBorderColor,\n                ...(data.hidden ? theme.legends.hidden.symbol : undefined),\n            })}\n            <text\n                textAnchor={labelAnchor}\n                style={{\n                    ...theme.legends.text,\n                    fill: style.itemTextColor ?? textColor ?? theme.legends.text.fill ?? 'black',\n                    dominantBaseline: labelAlignment,\n                    pointerEvents: 'none',\n                    userSelect: 'none',\n                    ...(data.hidden ? theme.legends.hidden.text : undefined),\n                }}\n                x={labelX}\n                y={labelY}\n            >\n                {data.label}\n            </text>\n        </g>\n    )\n}\n","import { SymbolProps } from './types'\n\nexport const SymbolCircle = ({\n    x,\n    y,\n    size,\n    fill,\n    opacity = 1,\n    borderWidth = 0,\n    borderColor = 'transparent',\n}: SymbolProps) => {\n    return (\n        <circle\n            r={size / 2}\n            cx={x + size / 2}\n            cy={y + size / 2}\n            fill={fill}\n            opacity={opacity}\n            strokeWidth={borderWidth}\n            stroke={borderColor}\n            style={{\n                pointerEvents: 'none',\n            }}\n        />\n    )\n}\n","import { SymbolProps } from './types'\n\nexport const SymbolDiamond = ({\n    x,\n    y,\n    size,\n    fill,\n    opacity = 1,\n    borderWidth = 0,\n    borderColor = 'transparent',\n}: SymbolProps) => {\n    return (\n        <g transform={`translate(${x},${y})`}>\n            <path\n                d={`\n                    M${size / 2} 0\n                    L${size * 0.8} ${size / 2}\n                    L${size / 2} ${size}\n                    L${size * 0.2} ${size / 2}\n                    L${size / 2} 0\n                `}\n                fill={fill}\n                opacity={opacity}\n                strokeWidth={borderWidth}\n                stroke={borderColor}\n                style={{\n                    pointerEvents: 'none',\n                }}\n            />\n        </g>\n    )\n}\n","import { SymbolProps } from './types'\n\nexport const SymbolSquare = ({\n    x,\n    y,\n    size,\n    fill,\n    opacity = 1,\n    borderWidth = 0,\n    borderColor = 'transparent',\n}: SymbolProps) => {\n    return (\n        <rect\n            x={x}\n            y={y}\n            fill={fill}\n            opacity={opacity}\n            strokeWidth={borderWidth}\n            stroke={borderColor}\n            width={size}\n            height={size}\n            style={{\n                pointerEvents: 'none',\n            }}\n        />\n    )\n}\n","import { LegendSvgItem } from './LegendSvgItem'\nimport { LegendSvgProps } from '../types'\nimport { computeDimensions } from '../compute'\n\nexport const LegendSvg = ({\n    data,\n\n    x,\n    y,\n    direction,\n    padding: _padding = 0,\n    justify,\n    effects,\n\n    itemWidth,\n    itemHeight,\n    itemDirection = 'left-to-right',\n    itemsSpacing = 0,\n    itemTextColor,\n    itemBackground = 'transparent',\n    itemOpacity = 1,\n\n    symbolShape,\n    symbolSize,\n    symbolSpacing,\n    symbolBorderWidth,\n    symbolBorderColor,\n\n    onClick,\n    onMouseEnter,\n    onMouseLeave,\n    toggleSerie,\n}: LegendSvgProps) => {\n    const { padding } = computeDimensions({\n        itemCount: data.length,\n        itemWidth,\n        itemHeight,\n        itemsSpacing,\n        direction,\n        padding: _padding,\n    })\n\n    const xStep = direction === 'row' ? itemWidth + itemsSpacing : 0\n    const yStep = direction === 'column' ? itemHeight + itemsSpacing : 0\n\n    return (\n        <g transform={`translate(${x},${y})`}>\n            {data.map((data, i) => (\n                <LegendSvgItem\n                    key={i}\n                    data={data}\n                    x={i * xStep + padding.left}\n                    y={i * yStep + padding.top}\n                    width={itemWidth}\n                    height={itemHeight}\n                    direction={itemDirection}\n                    justify={justify}\n                    effects={effects}\n                    textColor={itemTextColor}\n                    background={itemBackground}\n                    opacity={itemOpacity}\n                    symbolShape={symbolShape}\n                    symbolSize={symbolSize}\n                    symbolSpacing={symbolSpacing}\n                    symbolBorderWidth={symbolBorderWidth}\n                    symbolBorderColor={symbolBorderColor}\n                    onClick={onClick}\n                    onMouseEnter={onMouseEnter}\n                    onMouseLeave={onMouseLeave}\n                    toggleSerie={toggleSerie}\n                />\n            ))}\n        </g>\n    )\n}\n","import { LegendSvg } from './LegendSvg'\nimport { BoxLegendSvgProps } from '../types'\nimport { computeDimensions, computePositionFromAnchor } from '../compute'\n\nexport const BoxLegendSvg = ({\n    data,\n\n    containerWidth,\n    containerHeight,\n    translateX = 0,\n    translateY = 0,\n    anchor,\n    direction,\n    padding = 0,\n    justify,\n\n    itemsSpacing = 0,\n    itemWidth,\n    itemHeight,\n    itemDirection,\n    itemTextColor,\n    itemBackground,\n    itemOpacity,\n\n    symbolShape,\n    symbolSize,\n    symbolSpacing,\n    symbolBorderWidth,\n    symbolBorderColor,\n\n    onClick,\n    onMouseEnter,\n    onMouseLeave,\n    toggleSerie,\n\n    effects,\n}: BoxLegendSvgProps) => {\n    const { width, height } = computeDimensions({\n        itemCount: data.length,\n        itemsSpacing,\n        itemWidth,\n        itemHeight,\n        direction,\n        padding,\n    })\n\n    const { x, y } = computePositionFromAnchor({\n        anchor,\n        translateX,\n        translateY,\n        containerWidth,\n        containerHeight,\n        width,\n        height,\n    })\n\n    return (\n        <LegendSvg\n            data={data}\n            x={x}\n            y={y}\n            direction={direction}\n            padding={padding}\n            justify={justify}\n            effects={effects}\n            itemsSpacing={itemsSpacing}\n            itemWidth={itemWidth}\n            itemHeight={itemHeight}\n            itemDirection={itemDirection}\n            itemTextColor={itemTextColor}\n            itemBackground={itemBackground}\n            itemOpacity={itemOpacity}\n            symbolShape={symbolShape}\n            symbolSize={symbolSize}\n            symbolSpacing={symbolSpacing}\n            symbolBorderWidth={symbolBorderWidth}\n            symbolBorderColor={symbolBorderColor}\n            onClick={onClick}\n            onMouseEnter={onMouseEnter}\n            onMouseLeave={onMouseLeave}\n            toggleSerie={typeof toggleSerie === 'boolean' ? undefined : toggleSerie}\n        />\n    )\n}\n","import { CompleteTheme, degreesToRadians } from '@nivo/core'\nimport {\n    computeDimensions,\n    computePositionFromAnchor,\n    computeItemLayout,\n    computeContinuousColorsLegend,\n} from './compute'\nimport { AnchoredContinuousColorsLegendProps, LegendCanvasProps } from './types'\nimport { continuousColorsLegendDefaults } from './defaults'\n\nconst textAlignMapping = {\n    start: 'left',\n    middle: 'center',\n    end: 'right',\n} as const\n\nexport const renderLegendToCanvas = (\n    ctx: CanvasRenderingContext2D,\n    {\n        data,\n\n        containerWidth,\n        containerHeight,\n        translateX = 0,\n        translateY = 0,\n        anchor,\n        direction,\n        padding: _padding = 0,\n        justify = false,\n\n        // items\n        itemsSpacing = 0,\n        itemWidth,\n        itemHeight,\n        itemDirection = 'left-to-right',\n        itemTextColor,\n\n        // symbol\n        symbolSize = 16,\n        symbolSpacing = 8,\n        // @todo add support for shapes\n        // symbolShape = LegendSvgItem.defaultProps.symbolShape,\n\n        theme,\n    }: LegendCanvasProps\n) => {\n    const { width, height, padding } = computeDimensions({\n        itemCount: data.length,\n        itemWidth,\n        itemHeight,\n        itemsSpacing,\n        direction,\n        padding: _padding,\n    })\n\n    const { x, y } = computePositionFromAnchor({\n        anchor,\n        translateX,\n        translateY,\n        containerWidth,\n        containerHeight,\n        width,\n        height,\n    })\n\n    const xStep = direction === 'row' ? itemWidth + itemsSpacing : 0\n    const yStep = direction === 'column' ? itemHeight + itemsSpacing : 0\n\n    ctx.save()\n    ctx.translate(x, y)\n\n    ctx.font = `${theme.legends.text.fontSize}px ${theme.legends.text.fontFamily || 'sans-serif'}`\n\n    data.forEach((d, i) => {\n        const itemX = i * xStep + padding.left\n        const itemY = i * yStep + padding.top\n\n        const { symbolX, symbolY, labelX, labelY, labelAnchor, labelAlignment } = computeItemLayout(\n            {\n                direction: itemDirection,\n                justify,\n                symbolSize,\n                symbolSpacing,\n                width: itemWidth,\n                height: itemHeight,\n            }\n        )\n\n        ctx.fillStyle = d.color ?? 'black'\n        ctx.fillRect(itemX + symbolX, itemY + symbolY, symbolSize, symbolSize)\n\n        ctx.textAlign = textAlignMapping[labelAnchor]\n\n        if (labelAlignment === 'central') {\n            ctx.textBaseline = 'middle'\n        }\n\n        ctx.fillStyle = itemTextColor ?? theme.legends.text.fill ?? 'black'\n        ctx.fillText(String(d.label), itemX + labelX, itemY + labelY)\n    })\n\n    ctx.restore()\n}\n\nexport const renderContinuousColorLegendToCanvas = (\n    ctx: CanvasRenderingContext2D,\n    {\n        containerWidth,\n        containerHeight,\n        anchor,\n        translateX = 0,\n        translateY = 0,\n        scale,\n        length = continuousColorsLegendDefaults.length,\n        thickness = continuousColorsLegendDefaults.thickness,\n        direction = continuousColorsLegendDefaults.direction,\n        ticks: _ticks,\n        tickPosition = continuousColorsLegendDefaults.tickPosition,\n        tickSize = continuousColorsLegendDefaults.tickSize,\n        tickSpacing = continuousColorsLegendDefaults.tickSpacing,\n        tickOverlap = continuousColorsLegendDefaults.tickOverlap,\n        tickFormat = continuousColorsLegendDefaults.tickFormat,\n        title,\n        titleAlign = continuousColorsLegendDefaults.titleAlign,\n        titleOffset = continuousColorsLegendDefaults.titleOffset,\n        theme,\n    }: AnchoredContinuousColorsLegendProps & {\n        theme: CompleteTheme\n    }\n) => {\n    const {\n        width,\n        height,\n        gradientX1,\n        gradientY1,\n        gradientX2,\n        gradientY2,\n        colorStops,\n        ticks,\n        titleText,\n        titleX,\n        titleY,\n        titleRotation,\n        titleVerticalAlign,\n        titleHorizontalAlign,\n    } = computeContinuousColorsLegend({\n        scale,\n        ticks: _ticks,\n        length,\n        thickness,\n        direction,\n        tickPosition,\n        tickSize,\n        tickSpacing,\n        tickOverlap,\n        tickFormat,\n        title,\n        titleAlign,\n        titleOffset,\n    })\n\n    const { x, y } = computePositionFromAnchor({\n        anchor,\n        translateX,\n        translateY,\n        containerWidth,\n        containerHeight,\n        width,\n        height,\n    })\n\n    const initialStyles = {\n        font: ctx.font,\n        textAlign: ctx.textAlign,\n        textBaseline: ctx.textBaseline,\n    }\n    ctx.save()\n\n    ctx.translate(x, y)\n\n    const gradient = ctx.createLinearGradient(\n        gradientX1 * width,\n        gradientY1 * height,\n        gradientX2 * width,\n        gradientY2 * height\n    )\n    colorStops.forEach(colorStop => {\n        gradient.addColorStop(colorStop.offset, colorStop.stopColor)\n    })\n\n    ctx.fillStyle = gradient\n    ctx.fillRect(0, 0, width, height)\n\n    ctx.font = `${\n        theme.legends.ticks.text.fontWeight ? `${theme.legends.ticks.text.fontWeight} ` : ''\n    }${theme.legends.ticks.text.fontSize}px ${theme.legends.ticks.text.fontFamily}`\n\n    ticks.forEach(tick => {\n        if ((theme.legends.ticks.line.strokeWidth ?? 0) > 0) {\n            ctx.lineWidth = Number(theme.axis.ticks.line.strokeWidth)\n            if (theme.axis.ticks.line.stroke) {\n                ctx.strokeStyle = theme.axis.ticks.line.stroke\n            }\n            ctx.lineCap = 'square'\n\n            ctx.beginPath()\n            ctx.moveTo(tick.x1, tick.y1)\n            ctx.lineTo(tick.x2, tick.y2)\n            ctx.stroke()\n        }\n\n        if (theme.legends.ticks.text.fill) {\n            ctx.fillStyle = theme.legends.ticks.text.fill\n        }\n        ctx.textAlign = tick.textHorizontalAlign === 'middle' ? 'center' : tick.textHorizontalAlign\n        ctx.textBaseline = tick.textVerticalAlign === 'central' ? 'middle' : tick.textVerticalAlign\n\n        ctx.fillText(tick.text, tick.textX, tick.textY)\n    })\n\n    if (titleText) {\n        ctx.save()\n        ctx.translate(titleX, titleY)\n        ctx.rotate(degreesToRadians(titleRotation))\n\n        ctx.font = `${\n            theme.legends.title.text.fontWeight ? `${theme.legends.title.text.fontWeight} ` : ''\n        }${theme.legends.title.text.fontSize}px ${theme.legends.title.text.fontFamily}`\n        if (theme.legends.title.text.fill) {\n            ctx.fillStyle = theme.legends.title.text.fill\n        }\n        ctx.textAlign = titleHorizontalAlign === 'middle' ? 'center' : titleHorizontalAlign\n        ctx.textBaseline = titleVerticalAlign\n\n        ctx.fillText(titleText, 0, 0)\n\n        ctx.restore()\n    }\n\n    ctx.restore()\n\n    ctx.font = initialStyles.font\n    ctx.textAlign = initialStyles.textAlign\n    ctx.textBaseline = initialStyles.textBaseline\n}\n","import { useMemo } from 'react'\n\ntype Scale = {\n    (value: number): number\n    invertExtent: (value: number) => [number, number]\n    range: () => number[]\n}\n\nexport const useQuantizeColorScaleLegendData = ({\n    scale,\n    domain: overriddenDomain,\n    reverse = false,\n    valueFormat = v => v,\n    separator = ' - ',\n}: {\n    scale: Scale\n    domain?: number[]\n    reverse?: boolean\n    valueFormat?: <T, U>(value: T) => T | U\n    separator?: string\n}) => {\n    return useMemo(() => {\n        const domain = overriddenDomain ?? scale.range()\n\n        const items = domain.map((domainValue, index) => {\n            const [start, end] = scale.invertExtent(domainValue)\n\n            return {\n                id: domainValue,\n                index,\n                extent: [start, end],\n                label: `${valueFormat(start)}${separator}${valueFormat(end)}`,\n                value: scale(start),\n                color: domainValue,\n            }\n        })\n\n        if (reverse) items.reverse()\n\n        return items\n    }, [overriddenDomain, scale, reverse, separator, valueFormat])\n}\n","import PropTypes from 'prop-types'\n\n/**\n * The prop type is exported as a simple object instead of `PropTypes.shape`\n * to be able to add extra properties.\n *\n * @example\n * ```javascript\n * import { LegendPropShape } from '@nivo/legends'\n *\n * const customLegendPropType = PropTypes.shape({\n *     ...LegendPropShape,\n *     extra: PropTypes.any.isRequired,\n * })\n * ```\n */\nexport const LegendPropShape = {\n    data: PropTypes.arrayOf(PropTypes.object),\n\n    // position & layout\n    anchor: PropTypes.oneOf([\n        'top',\n        'top-right',\n        'right',\n        'bottom-right',\n        'bottom',\n        'bottom-left',\n        'left',\n        'top-left',\n        'center',\n    ]).isRequired,\n    translateX: PropTypes.number,\n    translateY: PropTypes.number,\n    direction: PropTypes.oneOf(['row', 'column']).isRequired,\n\n    // item\n    itemsSpacing: PropTypes.number,\n    itemWidth: PropTypes.number.isRequired,\n    itemHeight: PropTypes.number.isRequired,\n    itemDirection: PropTypes.oneOf([\n        'left-to-right',\n        'right-to-left',\n        'top-to-bottom',\n        'bottom-to-top',\n    ]),\n    itemTextColor: PropTypes.string,\n    itemBackground: PropTypes.string,\n    itemOpacity: PropTypes.number,\n\n    symbolShape: PropTypes.oneOfType([\n        PropTypes.oneOf(['circle', 'diamond', 'square', 'triangle']),\n        PropTypes.func,\n    ]),\n    symbolSize: PropTypes.number,\n    symbolSpacing: PropTypes.number,\n    symbolBorderWidth: PropTypes.number,\n    symbolBorderColor: PropTypes.string,\n\n    onClick: PropTypes.func,\n    onMouseEnter: PropTypes.func,\n    onMouseLeave: PropTypes.func,\n\n    effects: PropTypes.arrayOf(\n        PropTypes.shape({\n            on: PropTypes.oneOfType([PropTypes.oneOf(['hover'])]).isRequired,\n            style: PropTypes.shape({\n                itemTextColor: PropTypes.string,\n                itemBackground: PropTypes.string,\n                itemOpacity: PropTypes.number,\n                symbolSize: PropTypes.number,\n                symbolBorderWidth: PropTypes.number,\n                symbolBorderColor: PropTypes.string,\n            }).isRequired,\n        })\n    ),\n}\n"],"names":["styled","media","FullWidthBanner","theme","colors","cardBackground","DescriptionBlock","Card","cardShadow","legendProps","containerWidth","containerHeight","itemWidth","itemHeight","LegendDirection","useTheme","width","height","itemTextColor","text","anchor","direction","data","id","label","color","accent","translateX","itemDirections","LegendItemDirection","itemsProps","x","y","style","display","justifyContent","map","dir","background","padding","borderRadius","boxShadow","textColor","justify","anchors","translateExamples","translateY","margin","itemsSpacing","LegendPosition","textAnchor","alignmentBaseline","fill","textLight","fontSize","transform","key","example","i","omit","shapes","code","trim","SymbolShape","shape","symbolShape","Highlight","language","Layout","value","nivo","Seo","title","description","PageContent","className","continuousColorsLegendDefaults","length","thickness","tickPosition","tickSize","tickSpacing","tickOverlap","tickFormat","titleAlign","titleOffset","zeroPadding","top","right","bottom","left","computeDimensions","item","_padding","itemCount","Array","isArray","Error","horizontalPadding","verticalPadding","spacing","computePositionFromAnchor","computeItemLayout","symbolX","symbolY","labelX","labelY","labelAnchor","labelAlignment","symbolSize","symbolSpacing","computeContinuousColorsLegend","values","scale","ticks","domain","reverse","positionScale","scaleLinear","range","thresholds","titleX","titleY","titleRotation","titleVerticalAlign","y1","y2","textY","textVerticalAlign","x1","x2","textX","textHorizontalAlign","colorStops","computeContinuousColorScaleColorStops","formatValue","getValueFormatter","computedTicks","gradientY1","gradientX2","forEach","push","gradientX1","gradientY2","titleText","titleHorizontalAlign","ContinuousColorsLegendSvg","stop","offset","join","_jsxs","_jsx","colorStop","dominantBaseline","legends","tick","index","Fragment","line","AnchoredContinuousColorsLegendSvg","symbolByShape","circle","size","opacity","borderWidth","borderColor","r","cx","cy","strokeWidth","stroke","pointerEvents","diamond","d","square","triangle","LegendSvgItem","symbolBorderWidth","symbolBorderColor","onClick","onMouseEnter","onMouseLeave","toggleSerie","effects","useState","setStyle","handleMouseEnter","useCallback","event","filter","on","reduce","acc","effect","handleMouseLeave","isInteractive","some","handler","itemOpacity","itemBackground","cursor","React","hidden","symbol","userSelect","LegendSvg","itemDirection","xStep","yStep","BoxLegendSvg","textAlignMapping","start","middle","end","renderLegendToCanvas","ctx","save","translate","font","fontFamily","itemX","itemY","fillStyle","fillRect","textAlign","textBaseline","fillText","String","restore","renderContinuousColorLegendToCanvas","_ticks","initialStyles","gradient","createLinearGradient","addColorStop","stopColor","fontWeight","lineWidth","Number","axis","strokeStyle","lineCap","beginPath","moveTo","lineTo","rotate","degreesToRadians","useQuantizeColorScaleLegendData","overriddenDomain","valueFormat","v","separator","useMemo","items","domainValue","invertExtent","extent","LegendPropShape","PropTypes","isRequired"],"sourceRoot":""}