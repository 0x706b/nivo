{"version":3,"sources":["webpack:///../node_modules/lodash/_baseIsDate.js","webpack:///./src/data/components/swarmplot/mapper.js","webpack:///./src/pages/swarmplot/index.js","webpack:///../node_modules/lodash/uniqBy.js","webpack:///./src/lib/settings.js","webpack:///../node_modules/lodash/isDate.js","webpack:///../node_modules/d3-scale/node_modules/d3-time/src/utcMonth.js","webpack:///../node_modules/d3-scale/node_modules/d3-time/src/utcHour.js","webpack:///../node_modules/d3-scale/node_modules/d3-time/src/utcMinute.js","webpack:///../src/linearScale.js","webpack:///../src/logScale.js","webpack:///../src/symlogScale.js","webpack:///../src/pointScale.js","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js","webpack:///../src/timeHelpers.js","webpack:///../src/timeScale.js","webpack:///../node_modules/d3-scale/src/utcTime.js","webpack:///../src/bandScale.js","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArray.js","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js","webpack:///../src/compute.js","webpack:///../src/index.js"],"names":["baseGetTag","isObjectLike","module","exports","value","settingsMapper","axisTop","mapAxis","axisRight","axisBottom","axisLeft","initialProperties","Object","freeze","groupBy","identity","valueFormat","valueScale","type","min","max","reverse","size","key","values","sizes","spacing","layout","SwarmPlotDefaultProps","gap","forceStrength","simulationIterations","colors","colorBy","borderWidth","borderColor","from","modifiers","margin","top","right","bottom","left","enableGridX","enableGridY","enable","orient","tickSize","tickPadding","tickRotation","legend","legendPosition","legendOffset","isInteractive","useMesh","debugMesh","animate","motionStiffness","motionDamping","ScatterPlot","ComponentTemplate","name","meta","SwarmPlot","icon","flavors","currentFlavor","properties","groups","defaultProperties","propertiesMapper","mapper","codePropertiesMapper","data","generateData","generateLightDataSet","getTabData","getDataSize","length","theme","logAction","onClick","node","label","id","group","color","baseIteratee","baseUniq","array","iteratee","mapping","exclude","settings","options","overrides","keys","forEach","omit","upperFirst","mapFormat","format","enabled","undefined","baseIsDate","baseUnary","nodeUtil","nodeIsDate","isDate","utcMonth","interval","date","setUTCDate","setUTCHours","step","setUTCMonth","getUTCMonth","start","end","getUTCFullYear","range","utcHour","setUTCMinutes","setTime","duration","getUTCHours","utcMinute","setUTCSeconds","getUTCMinutes","linearScalePropTypes","PropTypes","stacked","clamp","nice","logScalePropTypes","base","symLogScalePropTypes","constant","pointScalePropTypes","isRequired","_defineProperty","obj","defineProperty","enumerable","configurable","writable","timePrecisions","precisionCutOffs","precisionCutOffsByType","createDateNormalizer","precision","useUTC","precisionFn","cutOff","createPrecisionMethod","v","parseTime","utcParse","timeParse","timeScale","axis","xy","normalize","minValue","maxValue","scale","init","apply","utcYear","utcWeek","utcDay","domain","Date","UTC","arguments","scaleUtc","scaleTime","timeScalePropTypes","bandScalePropTypes","round","bool","_arrayLikeToArray","arr","len","i","arr2","Array","_toConsumableArray","isArray","arrayLikeToArray","arrayWithoutHoles","iter","Symbol","iterator","iterableToArray","o","minLen","n","prototype","toString","call","slice","constructor","test","unsupportedIterableToArray","TypeError","nonIterableSpread","ownKeys","object","enumerableOnly","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","push","_objectSpread2","target","source","getOwnPropertyDescriptors","defineProperties","getOtherAxis","compareValues","a","compareDateValues","b","computeXYScalesForSeries","_series","series","serie","d","generateSeriesXY","xScaleSpec","stackX","yScaleSpec","stackY","xScale","computeScale","yScale","x","y","spec","scaleLinear","linearScale","scalePoint","pointScale","hasZero","hasMixedSign","sign","Math","scaleLog","logScale","scaleSymlog","symlogScale","generateSeriesAxis","getValue","setValue","scaleSpec","parseFloat","all","uniq","sortBy","uniqBy","last","stackAxis","otherAxis","compare","stack","datum","stackValue","head","scalePropType"],"mappings":"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","file":"component---src-pages-swarmplot-index-js-ddb5ed45369578029af4.js","sourcesContent":["var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar dateTag = '[object Date]';\n\n/**\n * The base implementation of `_.isDate` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n */\nfunction baseIsDate(value) {\n  return isObjectLike(value) && baseGetTag(value) == dateTag;\n}\n\nmodule.exports = baseIsDate;\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { settingsMapper, mapAxis } from '../../../lib/settings'\n\nexport default settingsMapper({\n    axisTop: mapAxis('top'),\n    axisRight: mapAxis('right'),\n    axisBottom: mapAxis('bottom'),\n    axisLeft: mapAxis('left'),\n})\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport React from 'react'\nimport { ResponsiveSwarmPlot, SwarmPlotDefaultProps } from '@nivo/swarmplot'\nimport ComponentTemplate from '../../components/components/ComponentTemplate'\nimport meta from '../../data/components/swarmplot/meta.yml'\nimport mapper from '../../data/components/swarmplot/mapper'\nimport { groups } from '../../data/components/swarmplot/props'\nimport { generateLightDataSet } from '../../data/components/swarmplot/generator'\n\nconst initialProperties = Object.freeze({\n    groupBy: 'group',\n    identity: 'id',\n    value: 'price',\n    valueFormat: '$.2f',\n    valueScale: {\n        type: 'linear',\n        min: 0,\n        max: 500,\n        reverse: false,\n    },\n    size: {\n        key: 'volume',\n        values: [4, 20],\n        sizes: [6, 20],\n    },\n    spacing: 2,\n    layout: SwarmPlotDefaultProps.layout,\n    gap: SwarmPlotDefaultProps.gap,\n\n    forceStrength: 4,\n    simulationIterations: 100,\n\n    colors: SwarmPlotDefaultProps.colors,\n    colorBy: 'group',\n    borderWidth: 0,\n    borderColor: {\n        from: 'color',\n        modifiers: [\n            ['darker', 0.6],\n            ['opacity', 0.5],\n        ],\n    },\n    margin: {\n        top: 80,\n        right: 100,\n        bottom: 80,\n        left: 100,\n    },\n    enableGridX: true,\n    enableGridY: true,\n    axisTop: {\n        enable: true,\n        orient: 'top',\n        tickSize: 10,\n        tickPadding: 5,\n        tickRotation: 0,\n        legend: 'group if vertical, price if horizontal',\n        legendPosition: 'middle',\n        legendOffset: -46,\n    },\n    axisRight: {\n        enable: true,\n        orient: 'right',\n        tickSize: 10,\n        tickPadding: 5,\n        tickRotation: 0,\n        legend: 'price if vertical, group if horizontal',\n        legendPosition: 'middle',\n        legendOffset: 76,\n    },\n    axisBottom: {\n        enable: true,\n        orient: 'bottom',\n        tickSize: 10,\n        tickPadding: 5,\n        tickRotation: 0,\n        legend: 'group if vertical, price if horizontal',\n        legendPosition: 'middle',\n        legendOffset: 46,\n    },\n    axisLeft: {\n        enable: true,\n        orient: 'left',\n        tickSize: 10,\n        tickPadding: 5,\n        tickRotation: 0,\n        legend: 'price if vertical, group if horizontal',\n        legendPosition: 'middle',\n        legendOffset: -76,\n    },\n\n    isInteractive: true,\n    useMesh: false,\n    debugMesh: false,\n\n    animate: true,\n    motionStiffness: 50,\n    motionDamping: 10,\n})\n\nconst ScatterPlot = () => {\n    return (\n        <ComponentTemplate\n            name=\"SwarmPlot\"\n            meta={meta.SwarmPlot}\n            icon=\"swarmplot\"\n            flavors={meta.flavors}\n            currentFlavor=\"svg\"\n            properties={groups}\n            initialProperties={initialProperties}\n            defaultProperties={SwarmPlotDefaultProps}\n            propertiesMapper={mapper}\n            codePropertiesMapper={(properties, data) => ({\n                groups: data.groups,\n                ...properties,\n            })}\n            generateData={generateLightDataSet}\n            getTabData={data => data.data}\n            getDataSize={data => data.data.length}\n        >\n            {(properties, data, theme, logAction) => {\n                return (\n                    <ResponsiveSwarmPlot\n                        data={data.data}\n                        groups={data.groups}\n                        {...properties}\n                        theme={theme}\n                        onClick={node => {\n                            logAction({\n                                type: 'click',\n                                label: `[node] id: ${node.id}, group: ${node.group}, value: ${node.value}`,\n                                color: node.color,\n                                data: node,\n                            })\n                        }}\n                    />\n                )\n            }}\n        </ComponentTemplate>\n    )\n}\n\nexport default ScatterPlot\n","var baseIteratee = require('./_baseIteratee'),\n    baseUniq = require('./_baseUniq');\n\n/**\n * This method is like `_.uniq` except that it accepts `iteratee` which is\n * invoked for each element in `array` to generate the criterion by which\n * uniqueness is computed. The order of result values is determined by the\n * order they occur in the array. The iteratee is invoked with one argument:\n * (value).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n * @returns {Array} Returns the new duplicate free array.\n * @example\n *\n * _.uniqBy([2.1, 1.2, 2.3], Math.floor);\n * // => [2.1, 1.2]\n *\n * // The `_.property` iteratee shorthand.\n * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n * // => [{ 'x': 1 }, { 'x': 2 }]\n */\nfunction uniqBy(array, iteratee) {\n  return (array && array.length) ? baseUniq(array, baseIteratee(iteratee, 2)) : [];\n}\n\nmodule.exports = uniqBy;\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport omit from 'lodash/omit'\nimport upperFirst from 'lodash/upperFirst'\n\nexport const settingsMapper = (mapping, { exclude = [] } = {}) => (settings, options = {}) => {\n    const overrides = {}\n\n    Object.keys(settings).forEach(key => {\n        if (mapping[key]) {\n            overrides[key] = mapping[key](settings[key], settings, options)\n        }\n    })\n\n    return {\n        ...omit(settings, exclude),\n        ...overrides,\n    }\n}\n\nexport const mapAxis = type => (value, settings) =>\n    settings[`axis${upperFirst(type)}`].enable ? omit(value, ['enable']) : null\n\nexport const mapFormat = ({ format, enabled }) => (enabled === true ? format : undefined)\n","var baseIsDate = require('./_baseIsDate'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsDate = nodeUtil && nodeUtil.isDate;\n\n/**\n * Checks if `value` is classified as a `Date` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n * @example\n *\n * _.isDate(new Date);\n * // => true\n *\n * _.isDate('Mon April 23 2012');\n * // => false\n */\nvar isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;\n\nmodule.exports = isDate;\n","import interval from \"./interval.js\";\nvar utcMonth = interval(function (date) {\n  date.setUTCDate(1);\n  date.setUTCHours(0, 0, 0, 0);\n}, function (date, step) {\n  date.setUTCMonth(date.getUTCMonth() + step);\n}, function (start, end) {\n  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;\n}, function (date) {\n  return date.getUTCMonth();\n});\nexport default utcMonth;\nexport var utcMonths = utcMonth.range;","import interval from \"./interval.js\";\nimport { durationHour } from \"./duration.js\";\nvar utcHour = interval(function (date) {\n  date.setUTCMinutes(0, 0, 0);\n}, function (date, step) {\n  date.setTime(+date + step * durationHour);\n}, function (start, end) {\n  return (end - start) / durationHour;\n}, function (date) {\n  return date.getUTCHours();\n});\nexport default utcHour;\nexport var utcHours = utcHour.range;","import interval from \"./interval.js\";\nimport { durationMinute } from \"./duration.js\";\nvar utcMinute = interval(function (date) {\n  date.setUTCSeconds(0, 0);\n}, function (date, step) {\n  date.setTime(+date + step * durationMinute);\n}, function (start, end) {\n  return (end - start) / durationMinute;\n}, function (date) {\n  return date.getUTCMinutes();\n});\nexport default utcMinute;\nexport var utcMinutes = utcMinute.range;","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { scaleLinear } from 'd3-scale'\nimport PropTypes from 'prop-types'\n\nexport const linearScale = (\n    { axis, min = 0, max = 'auto', stacked = false, reverse = false, clamp = false, nice = false },\n    xy,\n    width,\n    height\n) => {\n    const values = xy[axis]\n    const size = axis === 'x' ? width : height\n\n    let minValue = min\n    if (min === 'auto') {\n        minValue = stacked === true ? values.minStacked : values.min\n    }\n    let maxValue = max\n    if (max === 'auto') {\n        maxValue = stacked === true ? values.maxStacked : values.max\n    }\n\n    const scale = scaleLinear().rangeRound(axis === 'x' ? [0, size] : [size, 0])\n\n    if (reverse === true) scale.domain([maxValue, minValue])\n    else scale.domain([minValue, maxValue])\n\n    if (nice === true) scale.nice()\n    else if (typeof nice === 'number') scale.nice(nice)\n\n    scale.type = 'linear'\n    scale.stacked = stacked\n    scale.clamp(clamp)\n\n    return scale\n}\n\nexport const linearScalePropTypes = {\n    type: PropTypes.oneOf(['linear']).isRequired,\n    min: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number]),\n    max: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number]),\n    stacked: PropTypes.bool,\n    reverse: PropTypes.bool,\n    clamp: PropTypes.bool,\n    nice: PropTypes.oneOfType([PropTypes.number, PropTypes.bool]),\n}\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { scaleLog } from 'd3-scale'\nimport PropTypes from 'prop-types'\n\nexport const logScale = ({ axis, base = 10, min = 'auto', max = 'auto' }, xy, width, height) => {\n    const values = xy[axis]\n    const size = axis === 'x' ? width : height\n\n    const hasZero = values.all.some(v => v === 0)\n    let sign\n    let hasMixedSign = false\n    values.all\n        .filter(v => v != null)\n        .forEach(v => {\n            if (hasMixedSign === true) return\n            if (sign === undefined) {\n                sign = Math.sign(v)\n            } else if (Math.sign(v) !== sign) {\n                hasMixedSign = true\n            }\n        })\n\n    if (hasZero || hasMixedSign) {\n        throw new Error(\n            [\n                `a log scale domain must be strictly-positive or strictly-negative,`,\n                `and must not include or cross zero.`,\n            ].join('\\n')\n        )\n    }\n\n    let minValue = min\n    if (min === 'auto') {\n        minValue = values.min\n    }\n    let maxValue = max\n    if (max === 'auto') {\n        maxValue = values.max\n    }\n\n    const scale = scaleLog()\n        .domain([minValue, maxValue])\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .base(base)\n        .nice()\n\n    scale.type = 'log'\n\n    return scale\n}\n\nexport const logScalePropTypes = {\n    type: PropTypes.oneOf(['log']).isRequired,\n    base: PropTypes.number,\n    min: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number]),\n    max: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number]),\n}\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { scaleSymlog } from 'd3-scale'\nimport PropTypes from 'prop-types'\n\nexport const symlogScale = (\n    { axis, constant = 1, min = 'auto', max = 'auto' },\n    xy,\n    width,\n    height\n) => {\n    const values = xy[axis]\n    const size = axis === 'x' ? width : height\n\n    let minValue = min\n    if (min === 'auto') {\n        minValue = values.min\n    }\n\n    let maxValue = max\n    if (max === 'auto') {\n        maxValue = values.max\n    }\n\n    const scale = scaleSymlog()\n        .domain([minValue, maxValue])\n        .constant(constant)\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .nice()\n\n    scale.type = 'symlog'\n\n    return scale\n}\n\nexport const symLogScalePropTypes = {\n    type: PropTypes.oneOf(['symlog']).isRequired,\n    constant: PropTypes.number,\n    min: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number]),\n    max: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number]),\n}\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { scalePoint } from 'd3-scale'\nimport PropTypes from 'prop-types'\n\nexport const pointScale = ({ axis }, xy, width, height) => {\n    const values = xy[axis]\n    const size = axis === 'x' ? width : height\n\n    const scale = scalePoint().range([0, size]).domain(values.all)\n\n    scale.type = 'point'\n\n    return scale\n}\n\nexport const pointScalePropTypes = {\n    type: PropTypes.oneOf(['point']).isRequired,\n}\n","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { timeParse, utcParse } from 'd3-time-format'\n\nexport const TIME_PRECISION_MILLISECOND = 'millisecond'\nexport const TIME_PRECISION_SECOND = 'second'\nexport const TIME_PRECISION_MINUTE = 'minute'\nexport const TIME_PRECISION_HOUR = 'hour'\nexport const TIME_PRECISION_DAY = 'day'\nexport const TIME_PRECISION_MONTH = 'month'\nexport const TIME_PRECISION_YEAR = 'year'\n\nexport const timePrecisions = [\n    TIME_PRECISION_MILLISECOND,\n    TIME_PRECISION_SECOND,\n    TIME_PRECISION_MINUTE,\n    TIME_PRECISION_HOUR,\n    TIME_PRECISION_DAY,\n    TIME_PRECISION_MONTH,\n    TIME_PRECISION_YEAR,\n]\n\nexport const precisionCutOffs = [\n    date => date.setMilliseconds(0),\n    date => date.setSeconds(0),\n    date => date.setMinutes(0),\n    date => date.setHours(0),\n    date => date.setDate(1),\n    date => date.setMonth(0),\n]\n\nexport const precisionCutOffsByType = {\n    [TIME_PRECISION_MILLISECOND]: [],\n    [TIME_PRECISION_SECOND]: precisionCutOffs.slice(0, 1),\n    [TIME_PRECISION_MINUTE]: precisionCutOffs.slice(0, 2),\n    [TIME_PRECISION_HOUR]: precisionCutOffs.slice(0, 3),\n    [TIME_PRECISION_DAY]: precisionCutOffs.slice(0, 4),\n    [TIME_PRECISION_MONTH]: precisionCutOffs.slice(0, 5),\n    [TIME_PRECISION_YEAR]: precisionCutOffs.slice(0, 6),\n}\n\nexport const createPrecisionMethod = precision => date => {\n    precisionCutOffsByType[precision].forEach(cutOff => {\n        cutOff(date)\n    })\n    return date\n}\n\nexport const createDateNormalizer = ({\n    format = 'native',\n    precision = 'millisecond',\n    useUTC = true,\n}) => {\n    const precisionFn = createPrecisionMethod(precision)\n    if (format === 'native') return v => precisionFn(v)\n\n    const parseTime = useUTC ? utcParse(format) : timeParse(format)\n    return v => precisionFn(parseTime(v))\n}\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { scaleTime, scaleUtc } from 'd3-scale'\nimport PropTypes from 'prop-types'\nimport { createDateNormalizer, timePrecisions, TIME_PRECISION_MILLISECOND } from './timeHelpers'\n\nexport const timeScale = (\n    {\n        axis,\n        format = 'native',\n        precision = TIME_PRECISION_MILLISECOND,\n        min = 'auto',\n        max = 'auto',\n        useUTC = true,\n        nice = false,\n    },\n    xy,\n    width,\n    height\n) => {\n    const values = xy[axis]\n    const size = axis === 'x' ? width : height\n\n    const normalize = createDateNormalizer({ format, precision, useUTC })\n\n    let minValue = min\n    if (min === 'auto') {\n        minValue = values.min\n    } else if (format !== 'native') {\n        minValue = normalize(min)\n    }\n\n    let maxValue = max\n    if (max === 'auto') {\n        maxValue = values.max\n    } else if (format !== 'native') {\n        maxValue = normalize(max)\n    }\n\n    const scale = useUTC ? scaleUtc() : scaleTime()\n    scale.domain([minValue, maxValue]).range([0, size])\n    if (nice === true) scale.nice()\n    else if (typeof nice === 'object' || typeof nice === 'number') scale.nice(nice)\n\n    scale.type = 'time'\n    scale.useUTC = useUTC\n\n    return scale\n}\n\nexport const timeScalePropTypes = {\n    type: PropTypes.oneOf(['time']).isRequired,\n    format: PropTypes.string,\n    precision: PropTypes.oneOf(timePrecisions),\n    nice: PropTypes.oneOfType([PropTypes.bool, PropTypes.number, PropTypes.object]),\n}\n","import { calendar } from \"./time.js\";\nimport { utcFormat } from \"d3-time-format\";\nimport { utcYear, utcMonth, utcWeek, utcDay, utcHour, utcMinute, utcSecond, utcMillisecond } from \"d3-time\";\nimport { initRange } from \"./init.js\";\nexport default function utcTime() {\n  return initRange.apply(calendar(utcYear, utcMonth, utcWeek, utcDay, utcHour, utcMinute, utcSecond, utcMillisecond, utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]), arguments);\n}","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport PropTypes from 'prop-types'\n\nexport const bandScalePropTypes = {\n    type: PropTypes.oneOf(['band']).isRequired,\n    round: PropTypes.bool,\n}\n","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayWithoutHoles from \"./arrayWithoutHoles\";\nimport iterableToArray from \"./iterableToArray\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray\";\nimport nonIterableSpread from \"./nonIterableSpread\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}","import arrayLikeToArray from \"./arrayLikeToArray\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import defineProperty from \"./defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport uniq from 'lodash/uniq'\nimport uniqBy from 'lodash/uniqBy'\nimport sortBy from 'lodash/sortBy'\nimport last from 'lodash/last'\nimport isDate from 'lodash/isDate'\nimport { linearScale } from './linearScale'\nimport { logScale } from './logScale'\nimport { symlogScale } from './symlogScale'\nimport { pointScale } from './pointScale'\nimport { timeScale } from './timeScale'\nimport { createDateNormalizer } from './timeHelpers'\n\nexport const getOtherAxis = axis => (axis === 'x' ? 'y' : 'x')\n\nexport const compareValues = (a, b) => a === b\nexport const compareDateValues = (a, b) => a.getTime() === b.getTime()\n\nexport const computeXYScalesForSeries = (_series, xScaleSpec, yScaleSpec, width, height) => {\n    const series = _series.map(serie => ({\n        ...serie,\n        data: serie.data.map(d => ({ data: { ...d } })),\n    }))\n\n    let xy = generateSeriesXY(series, xScaleSpec, yScaleSpec)\n    if (xScaleSpec.stacked === true) {\n        stackX(yScaleSpec.type, xy, series)\n    }\n    if (yScaleSpec.stacked === true) {\n        stackY(xScaleSpec.type, xy, series)\n    }\n\n    const xScale = computeScale({ ...xScaleSpec, axis: 'x' }, xy, width, height)\n    const yScale = computeScale({ ...yScaleSpec, axis: 'y' }, xy, width, height)\n\n    series.forEach(serie => {\n        serie.data.forEach(d => {\n            d.position = {\n                x:\n                    xScale.stacked === true\n                        ? d.data.xStacked === null\n                            ? null\n                            : xScale(d.data.xStacked)\n                        : d.data.x === null\n                        ? null\n                        : xScale(d.data.x),\n                y:\n                    yScale.stacked === true\n                        ? d.data.yStacked === null\n                            ? null\n                            : yScale(d.data.yStacked)\n                        : d.data.y === null\n                        ? null\n                        : yScale(d.data.y),\n            }\n        })\n    })\n\n    return {\n        ...xy,\n        series,\n        xScale,\n        yScale,\n    }\n}\n\nexport const computeScale = (spec, xy, width, height) => {\n    if (spec.type === 'linear') return linearScale(spec, xy, width, height)\n    else if (spec.type === 'point') return pointScale(spec, xy, width, height)\n    else if (spec.type === 'time') return timeScale(spec, xy, width, height)\n    else if (spec.type === 'log') return logScale(spec, xy, width, height)\n    else if (spec.type === 'symlog') return symlogScale(spec, xy, width, height)\n}\n\nexport const generateSeriesXY = (series, xScaleSpec, yScaleSpec) => ({\n    x: generateSeriesAxis(series, 'x', xScaleSpec),\n    y: generateSeriesAxis(series, 'y', yScaleSpec),\n})\n\n/**\n * Normalize data according to scale type, (time => Date, linear => Number)\n * compute sorted unique values and min/max.\n */\nexport const generateSeriesAxis = (\n    series,\n    axis,\n    scaleSpec,\n    {\n        getValue = d => d.data[axis],\n        setValue = (d, v) => {\n            d.data[axis] = v\n        },\n    } = {}\n) => {\n    if (scaleSpec.type === 'linear') {\n        series.forEach(serie => {\n            serie.data.forEach(d => {\n                setValue(d, getValue(d) === null ? null : parseFloat(getValue(d)))\n            })\n        })\n    } else if (scaleSpec.type === 'time' && scaleSpec.format !== 'native') {\n        const parseTime = createDateNormalizer(scaleSpec)\n        series.forEach(serie => {\n            serie.data.forEach(d => {\n                setValue(d, getValue(d) === null ? null : parseTime(getValue(d)))\n            })\n        })\n    }\n\n    let all = []\n    series.forEach(serie => {\n        serie.data.forEach(d => {\n            all.push(getValue(d))\n        })\n    })\n\n    let min, max\n    if (scaleSpec.type === 'linear') {\n        all = uniq(all)\n        all = sortBy(all, v => v)\n        min = Math.min(...all)\n        max = Math.max(...all)\n    } else if (scaleSpec.type === 'time') {\n        all = uniqBy(all, v => v.getTime())\n        all = all\n            .slice(0)\n            .sort((a, b) => b - a)\n            .reverse()\n        min = all[0]\n        max = last(all)\n    } else {\n        all = uniq(all)\n        min = all[0]\n        max = last(all)\n    }\n\n    return { all, min, max }\n}\n\nexport const stackAxis = (axis, otherType, xy, series) => {\n    const otherAxis = getOtherAxis(axis)\n\n    let all = []\n    xy[otherAxis].all.forEach(v => {\n        const compare = isDate(v) ? compareDateValues : compareValues\n        const stack = []\n        series.forEach(serie => {\n            const datum = serie.data.find(d => compare(d.data[otherAxis], v))\n            let value = null\n            let stackValue = null\n            if (datum !== undefined) {\n                value = datum.data[axis]\n                if (value !== null) {\n                    const head = last(stack)\n                    if (head === undefined) {\n                        stackValue = value\n                    } else if (head !== null) {\n                        stackValue = head + value\n                    }\n                }\n                datum.data[`${axis}Stacked`] = stackValue\n            }\n            stack.push(stackValue)\n            all.push(stackValue)\n        })\n    })\n    all = all.filter(v => v !== null)\n\n    xy[axis].minStacked = Math.min(...all)\n    xy[axis].maxStacked = Math.max(...all)\n}\n\nexport const stackX = (xy, otherType, series) => stackAxis('x', xy, otherType, series)\nexport const stackY = (xy, otherType, series) => stackAxis('y', xy, otherType, series)\n\nexport const computeAxisSlices = (axis, data) => {\n    const otherAxis = getOtherAxis(axis)\n\n    return data[otherAxis].all.map(v => {\n        const slice = {\n            id: v,\n            [otherAxis]: data[`${otherAxis}Scale`](v),\n            data: [],\n        }\n        const compare = isDate(v) ? compareDateValues : compareValues\n        data.series.forEach(serie => {\n            const datum = serie.data.find(d => compare(d.data[otherAxis], v))\n            if (datum !== undefined) {\n                slice.data.push({\n                    ...datum,\n                    serie,\n                })\n            }\n        })\n        slice.data.reverse()\n\n        return slice\n    })\n}\n\nexport const computeXSlices = data => computeAxisSlices('x', data)\nexport const computeYSlices = data => computeAxisSlices('y', data)\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport PropTypes from 'prop-types'\nimport { linearScalePropTypes } from './linearScale'\nimport { logScalePropTypes } from './logScale'\nimport { symLogScalePropTypes } from './symlogScale'\nimport { pointScalePropTypes } from './pointScale'\nimport { timeScalePropTypes } from './timeScale'\nimport { bandScalePropTypes } from './bandScale'\n\nexport * from './compute'\nexport * from './linearScale'\nexport * from './logScale'\nexport * from './symlogScale'\nexport * from './pointScale'\nexport * from './timeScale'\nexport * from './timeHelpers'\nexport * from './bandScale'\n\nexport const scalePropType = PropTypes.oneOfType([\n    PropTypes.shape(linearScalePropTypes),\n    PropTypes.shape(pointScalePropTypes),\n    PropTypes.shape(timeScalePropTypes),\n    PropTypes.shape(logScalePropTypes),\n    PropTypes.shape(symLogScalePropTypes),\n    PropTypes.shape(bandScalePropTypes),\n])\n"],"sourceRoot":""}