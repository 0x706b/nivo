{"version":3,"sources":["webpack:///../node_modules/lodash/_baseIsDate.js","webpack:///../node_modules/d3-scale/node_modules/d3-array/src/range.js","webpack:///../node_modules/d3-scale/src/band.js","webpack:///../node_modules/d3-scale/node_modules/d3-time/src/second.js","webpack:///../node_modules/lodash/uniqBy.js","webpack:///../node_modules/d3-scale/node_modules/d3-time/src/year.js","webpack:///../node_modules/d3-scale/node_modules/d3-time/src/month.js","webpack:///../node_modules/d3-scale/node_modules/d3-time/src/week.js","webpack:///../node_modules/d3-scale/node_modules/d3-time/src/day.js","webpack:///../node_modules/d3-scale/node_modules/d3-time/src/hour.js","webpack:///../node_modules/d3-scale/node_modules/d3-time/src/minute.js","webpack:///../node_modules/d3-scale/src/time.js","webpack:///../node_modules/d3-scale/node_modules/d3-time/src/interval.js","webpack:///../node_modules/lodash/isDate.js","webpack:///../node_modules/d3-scale/node_modules/d3-time/src/utcYear.js","webpack:///../node_modules/d3-scale/node_modules/d3-time/src/utcMonth.js","webpack:///../node_modules/d3-scale/node_modules/d3-time/src/utcWeek.js","webpack:///../node_modules/d3-scale/node_modules/d3-time/src/utcDay.js","webpack:///../node_modules/d3-scale/node_modules/d3-time/src/utcHour.js","webpack:///../node_modules/d3-scale/node_modules/d3-time/src/utcMinute.js","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArray.js","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js","webpack:///../src/timeHelpers.ts","webpack:///../src/linearScale.ts","webpack:///../src/timeScale.ts","webpack:///../node_modules/d3-scale/src/utcTime.js","webpack:///../src/compute.ts","webpack:///../src/pointScale.ts","webpack:///../src/bandScale.ts","webpack:///../src/logScale.ts","webpack:///../src/symlogScale.ts","webpack:///../node_modules/d3-scale/node_modules/d3-time/src/duration.js","webpack:///../node_modules/d3-scale/node_modules/d3-time/src/millisecond.js"],"names":["baseGetTag","isObjectLike","module","exports","value","start","stop","step","n","arguments","length","i","Math","max","ceil","range","Array","band","bandwidth","scale","ordinal","unknown","undefined","domain","ordinalRange","r0","r1","round","paddingInner","paddingOuter","align","rescale","reverse","floor","values","map","_","_ref","_ref2","rangeRound","_ref3","_ref4","padding","min","copy","init","apply","pointish","point","second","date","setTime","getMilliseconds","end","getUTCSeconds","baseIteratee","baseUniq","array","iteratee","setMonth","setHours","setFullYear","getFullYear","every","k","isFinite","setDate","getMonth","weekday","getDate","getDay","getTimezoneOffset","duration","sunday","monday","tuesday","wednesday","thursday","friday","saturday","getSeconds","getMinutes","getHours","t","Date","number","calendar","year","month","week","day","hour","minute","millisecond","format","continuous","invert","formatMillisecond","formatSecond","formatMinute","formatHour","formatDay","formatWeek","formatMonth","formatYear","tickIntervals","durationSecond","durationMinute","durationHour","durationDay","tickFormat","tickInterval","interval","target","abs","bisector","right","y","from","ticks","d","t0","t1","r","count","specifier","nice","time","newInterval","floori","offseti","field","d0","d1","offset","previous","push","filter","test","baseIsDate","baseUnary","nodeUtil","nodeIsDate","isDate","utcYear","setUTCMonth","setUTCHours","setUTCFullYear","getUTCFullYear","utcMonth","setUTCDate","getUTCMonth","utcWeekday","getUTCDate","getUTCDay","utcSunday","utcMonday","utcTuesday","utcWednesday","utcThursday","utcFriday","utcSaturday","utcDay","utcHour","setUTCMinutes","getUTCHours","utcMinute","setUTCSeconds","getUTCMinutes","_arrayLikeToArray","arr","len","arr2","_toConsumableArray","isArray","arrayLikeToArray","arrayWithoutHoles","iter","Symbol","iterator","Object","iterableToArray","o","minLen","prototype","toString","call","slice","constructor","name","unsupportedIterableToArray","TypeError","nonIterableSpread","_defineProperty","obj","key","defineProperty","enumerable","configurable","writable","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","sym","getOwnPropertyDescriptor","_objectSpread2","source","forEach","getOwnPropertyDescriptors","defineProperties","precisionCutOffs","precisionCutOffsByType","createDateNormalizer","precision","useUTC","precisionFn","cutOff","createPrecisionMethod","parseTime","utcParse","timeParse","createLinearScale","stacked","clamp","minValue","data","maxValue","scaleLinear","axis","size","typedScale","createTimeScale","normalize","UTC","scaleUtc","scaleTime","compareValues","a","compareDateValues","b","computeScale","spec","scalePoint","createPointScale","scaleBand","createBandScale","base","v","hasMixedSign","sign","scaleLog","createLogScale","constant","scaleSymlog","createSymlogScale","computeXYScalesForSeries","series","_series","serie","xy","generateSeriesXY","xScaleSpec","stackX","yScaleSpec","stackY","xScale","yScale","x","generateSeriesAxis","getValue","setValue","scaleSpec","parseFloat","String","all","sortBy","uniq","last","stackAxis","otherAxis","getOtherAxis","compare","stack","datum","stackValue","head","durationWeek"],"mappings":"iFAAA,IAAIA,EAAa,EAAQ,QACrBC,EAAe,EAAQ,QAgB3BC,EAAOC,QAJP,SAAoBC,GAClB,OAAOH,EAAaG,IAVR,iBAUkBJ,EAAWI,K,wHCd5B,kBACbC,GAASA,EAAOC,GAAQA,EAAMC,GAAQC,EAAIC,UAAUC,QAAU,GAAKJ,EAAOD,EAAOA,EAAQ,EAAG,GAAKG,EAAI,EAAI,GAAKD,EAK9G,IAJA,IAAII,GAAK,EACLH,EAAoD,EAAhDI,KAAKC,IAAI,EAAGD,KAAKE,MAAMR,EAAOD,GAASE,IAC3CQ,EAAQ,IAAIC,MAAMR,KAEbG,EAAIH,GACXO,EAAMJ,GAAKN,EAAQM,EAAIJ,EAGzB,OAAOQ,G,wBCNM,SAASE,IACtB,IAKIV,EACAW,EANAC,EAAQ,OAAAC,EAAA,KAAUC,aAAQC,GAC1BC,EAASJ,EAAMI,OACfC,EAAeL,EAAMJ,MACrBU,EAAK,EACLC,EAAK,EAGLC,GAAQ,EACRC,EAAe,EACfC,EAAe,EACfC,EAAQ,GAGZ,SAASC,IACP,IAAIvB,EAAIe,IAASb,OACbsB,EAAUN,EAAKD,EACfpB,EAAQ2B,EAAUN,EAAKD,EACvBnB,EAAO0B,EAAUP,EAAKC,EAC1BnB,GAAQD,EAAOD,GAASO,KAAKC,IAAI,EAAGL,EAAIoB,EAA8B,EAAfC,GACnDF,IAAOpB,EAAOK,KAAKqB,MAAM1B,IAC7BF,IAAUC,EAAOD,EAAQE,GAAQC,EAAIoB,IAAiBE,EACtDZ,EAAYX,GAAQ,EAAIqB,GACpBD,IAAOtB,EAAQO,KAAKe,MAAMtB,GAAQa,EAAYN,KAAKe,MAAMT,IAC7D,IAAIgB,EAAS,EAAS1B,GAAG2B,KAAI,SAAUxB,GACrC,OAAON,EAAQE,EAAOI,KAExB,OAAOa,EAAaQ,EAAUE,EAAOF,UAAYE,GAmDnD,cAlEOf,EAAME,QAkBbF,EAAMI,OAAS,SAAUa,GACvB,OAAO3B,UAAUC,QAAUa,EAAOa,GAAIL,KAAaR,KAGrDJ,EAAMJ,MAAQ,SAAUqB,GACtB,IAAIC,EAAMC,EAEV,OAAO7B,UAAUC,QAAW2B,EAAOD,EAAGE,EAAQ,YAAeD,EAAM,GAAIZ,EAAKa,EAAM,GAAIZ,EAAKY,EAAM,GAAWb,GAAMA,EAAIC,GAAMA,EAAIK,KAAa,CAACN,EAAIC,IAGpJP,EAAMoB,WAAa,SAAUH,GAC3B,IAAII,EAAOC,EAEX,OAAQD,EAAQJ,EAAGK,EAAQ,YAAeD,EAAO,GAAIf,EAAKgB,EAAM,GAAIf,EAAKe,EAAM,GAAYhB,GAAMA,EAAIC,GAAMA,EAAIC,GAAQ,EAAMI,KAG/HZ,EAAMD,UAAY,WAChB,OAAOA,GAGTC,EAAMZ,KAAO,WACX,OAAOA,GAGTY,EAAMQ,MAAQ,SAAUS,GACtB,OAAO3B,UAAUC,QAAUiB,IAAUS,EAAGL,KAAaJ,GAGvDR,EAAMuB,QAAU,SAAUN,GACxB,OAAO3B,UAAUC,QAAUkB,EAAehB,KAAK+B,IAAI,EAAGd,GAAgBO,GAAIL,KAAaH,GAGzFT,EAAMS,aAAe,SAAUQ,GAC7B,OAAO3B,UAAUC,QAAUkB,EAAehB,KAAK+B,IAAI,EAAGP,GAAIL,KAAaH,GAGzET,EAAMU,aAAe,SAAUO,GAC7B,OAAO3B,UAAUC,QAAUmB,GAAgBO,EAAGL,KAAaF,GAG7DV,EAAMW,MAAQ,SAAUM,GACtB,OAAO3B,UAAUC,QAAUoB,EAAQlB,KAAKC,IAAI,EAAGD,KAAK+B,IAAI,EAAGP,IAAKL,KAAaD,GAG/EX,EAAMyB,KAAO,WACX,OAAO3B,EAAKM,IAAU,CAACE,EAAIC,IAAKC,MAAMA,GAAOC,aAAaA,GAAcC,aAAaA,GAAcC,MAAMA,IAGpGe,EAAA,EAAUC,MAAMf,IAAWtB,WAGpC,SAASsC,EAAS5B,GAChB,IAAIyB,EAAOzB,EAAMyB,KASjB,OARAzB,EAAMuB,QAAUvB,EAAMU,oBACfV,EAAMS,oBACNT,EAAMU,aAEbV,EAAMyB,KAAO,WACX,OAAOG,EAASH,MAGXzB,EAGF,SAAS6B,IACd,OAAOD,EAAS9B,EAAK6B,MAAM,KAAMrC,WAAWmB,aAAa,M,oCCnG3D,4BAEIqB,EAAS,aAAS,SAAUC,GAC9BA,EAAKC,QAAQD,EAAOA,EAAKE,sBACxB,SAAUF,EAAM3C,GACjB2C,EAAKC,SAASD,EAAO3C,EAAO,QAC3B,SAAUF,EAAOgD,GAClB,OAAQA,EAAMhD,GAAS,OACtB,SAAU6C,GACX,OAAOA,EAAKI,mBAEC,MACML,EAAOlC,O,qBCZ5B,IAAIwC,EAAe,EAAQ,QACvBC,EAAW,EAAQ,QA6BvBtD,EAAOC,QAJP,SAAgBsD,EAAOC,GACrB,OAAQD,GAASA,EAAM/C,OAAU8C,EAASC,EAAOF,EAAaG,EAAU,IAAM,K,8IC1B5E,EAAO,aAAS,SAAUR,GAC5BA,EAAKS,SAAS,EAAG,GACjBT,EAAKU,SAAS,EAAG,EAAG,EAAG,MACtB,SAAUV,EAAM3C,GACjB2C,EAAKW,YAAYX,EAAKY,cAAgBvD,MACrC,SAAUF,EAAOgD,GAClB,OAAOA,EAAIS,cAAgBzD,EAAMyD,iBAChC,SAAUZ,GACX,OAAOA,EAAKY,iBAGd,EAAKC,MAAQ,SAAUC,GACrB,OAAQC,SAASD,EAAIpD,KAAKqB,MAAM+B,KAASA,EAAI,EAAY,aAAS,SAAUd,GAC1EA,EAAKW,YAAYjD,KAAKqB,MAAMiB,EAAKY,cAAgBE,GAAKA,GACtDd,EAAKS,SAAS,EAAG,GACjBT,EAAKU,SAAS,EAAG,EAAG,EAAG,MACtB,SAAUV,EAAM3C,GACjB2C,EAAKW,YAAYX,EAAKY,cAAgBvD,EAAOyD,MALG,MASrC,QCrBX,GDsBe,EAAKjD,MCtBZ,aAAS,SAAUmC,GAC7BA,EAAKgB,QAAQ,GACbhB,EAAKU,SAAS,EAAG,EAAG,EAAG,MACtB,SAAUV,EAAM3C,GACjB2C,EAAKS,SAAST,EAAKiB,WAAa5D,MAC/B,SAAUF,EAAOgD,GAClB,OAAOA,EAAIc,WAAa9D,EAAM8D,WAAyD,IAA3Cd,EAAIS,cAAgBzD,EAAMyD,kBACrE,SAAUZ,GACX,OAAOA,EAAKiB,eAEC,I,GACK,EAAMpD,M,WCT1B,SAASqD,EAAQzD,GACf,OAAO,aAAS,SAAUuC,GACxBA,EAAKgB,QAAQhB,EAAKmB,WAAanB,EAAKoB,SAAW,EAAI3D,GAAK,GACxDuC,EAAKU,SAAS,EAAG,EAAG,EAAG,MACtB,SAAUV,EAAM3C,GACjB2C,EAAKgB,QAAQhB,EAAKmB,UAAmB,EAAP9D,MAC7B,SAAUF,EAAOgD,GAClB,OAAQA,EAAMhD,GAASgD,EAAIkB,oBAAsBlE,EAAMkE,qBAAuBC,EAAA,GAAkBA,EAAA,KAI7F,IAAIC,EAASL,EAAQ,GACjBM,EAASN,EAAQ,GACjBO,EAAUP,EAAQ,GAClBQ,EAAYR,EAAQ,GACpBS,EAAWT,EAAQ,GACnBU,EAASV,EAAQ,GACjBW,EAAWX,EAAQ,GClB1B,GDmBiBK,EAAO1D,MACP2D,EAAO3D,MACN4D,EAAQ5D,MACN6D,EAAU7D,MACX8D,EAAS9D,MACX+D,EAAO/D,MACLgE,EAAShE,MCzBtB,aAAS,SAAUmC,GAC3B,OAAOA,EAAKU,SAAS,EAAG,EAAG,EAAG,MAC7B,SAAUV,EAAM3C,GACjB,OAAO2C,EAAKgB,QAAQhB,EAAKmB,UAAY9D,MACpC,SAAUF,EAAOgD,GAClB,OAAQA,EAAMhD,GAASgD,EAAIkB,oBAAsBlE,EAAMkE,qBAAuBC,EAAA,GAAkBA,EAAA,KAC/F,SAAUtB,GACX,OAAOA,EAAKmB,UAAY,MAEX,ICTX,GDUc,EAAItD,MCVX,aAAS,SAAUmC,GAC5BA,EAAKC,QAAQD,EAAOA,EAAKE,kBAAoBF,EAAK8B,aAAeR,EAAA,EAAiBtB,EAAK+B,aAAeT,EAAA,MACrG,SAAUtB,EAAM3C,GACjB2C,EAAKC,SAASD,EAAO3C,EAAOiE,EAAA,MAC3B,SAAUnE,EAAOgD,GAClB,OAAQA,EAAMhD,GAASmE,EAAA,KACtB,SAAUtB,GACX,OAAOA,EAAKgC,eAEC,ICTX,GDUe,EAAKnE,MCVX,aAAS,SAAUmC,GAC9BA,EAAKC,QAAQD,EAAOA,EAAKE,kBAAoBF,EAAK8B,aAAeR,EAAA,MAChE,SAAUtB,EAAM3C,GACjB2C,EAAKC,SAASD,EAAO3C,EAAOiE,EAAA,MAC3B,SAAUnE,EAAOgD,GAClB,OAAQA,EAAMhD,GAASmE,EAAA,KACtB,SAAUtB,GACX,OAAOA,EAAK+B,iBAEC,I,GACM,EAAOlE,M,uECE5B,SAAS,EAAKoE,GACZ,OAAO,IAAIC,KAAKD,GAGlB,SAASE,EAAOF,GACd,OAAOA,aAAaC,MAAQD,GAAK,IAAIC,MAAMD,GAGtC,SAASG,EAASC,EAAMC,EAAOC,EAAMC,EAAKC,EAAMC,EAAQ3C,EAAQ4C,EAAaC,GAClF,IAAI3E,EAAQ,OAAA4E,EAAA,KACRC,EAAS7E,EAAM6E,OACfzE,EAASJ,EAAMI,OACf0E,EAAoBH,EAAO,OAC3BI,EAAeJ,EAAO,OACtBK,EAAeL,EAAO,SACtBM,EAAaN,EAAO,SACpBO,EAAYP,EAAO,SACnBQ,EAAaR,EAAO,SACpBS,EAAcT,EAAO,MACrBU,EAAaV,EAAO,MACpBW,EAAgB,CAAC,CAACxD,EAAQ,EA5BX,KA4B+B,CAACA,EAAQ,EAAG,KAAqB,CAACA,EAAQ,GAAI,MAAsB,CAACA,EAAQ,GAAI,KAAsB,CAAC2C,EAAQ,EA3B/Ic,KA2BmK,CAACd,EAAQ,EAAG,KAAqB,CAACA,EAAQ,GAAI,KAAsB,CAACA,EAAQ,GAAI,MAAsB,CAACD,EAAM,EA1BnRgB,MA0BqS,CAAChB,EAAM,EAAG,OAAmB,CAACA,EAAM,EAAG,OAAmB,CAACA,EAAM,GAAI,OAAoB,CAACD,EAAK,EAzBrYkB,OAyBsZ,CAAClB,EAAK,EAAG,QAAkB,CAACD,EAAM,EAxBvboB,QAwByc,CAACrB,EAAO,EAvBhdqB,QAuBme,CAACrB,EAAO,EAAG,QAAoB,CAACD,EAAM,EAtB1gBsB,UAwBjB,SAASC,EAAW5D,GAClB,OAAQD,EAAOC,GAAQA,EAAO+C,EAAoBL,EAAO1C,GAAQA,EAAOgD,EAAeP,EAAKzC,GAAQA,EAAOiD,EAAeT,EAAIxC,GAAQA,EAAOkD,EAAaZ,EAAMtC,GAAQA,EAAOuC,EAAKvC,GAAQA,EAAOmD,EAAYC,EAAaf,EAAKrC,GAAQA,EAAOqD,EAAcC,GAAYtD,GAG5Q,SAAS6D,EAAaC,EAAU3G,EAAOC,GAKrC,GAJgB,MAAZ0G,IAAkBA,EAAW,IAIT,iBAAbA,EAAuB,CAChC,IAIIzG,EAJA0G,EAASrG,KAAKsG,IAAI5G,EAAOD,GAAS2G,EAClCrG,EAAI,OAAAwG,EAAA,IAAS,SAAUxG,GACzB,OAAOA,EAAE,MACRyG,MAAMX,EAAeQ,GAexB,OAZItG,IAAM8F,EAAc/F,QACtBH,EAAO,YAASF,EAzCLwG,QAyC2BvG,EAzC3BuG,QAyCgDG,GAC3DA,EAAWzB,GACF5E,GAETJ,GADAI,EAAI8F,EAAcQ,EAASR,EAAc9F,EAAI,GAAG,GAAK8F,EAAc9F,GAAG,GAAKsG,EAAStG,EAAI,EAAIA,IACnF,GACTqG,EAAWrG,EAAE,KAEbJ,EAAOK,KAAKC,IAAI,YAASR,EAAOC,EAAM0G,GAAW,GACjDA,EAAWnB,GAGNmB,EAASjD,MAAMxD,GAGxB,OAAOyG,EAqCT,OAlCA7F,EAAM6E,OAAS,SAAUqB,GACvB,OAAO,IAAIjC,KAAKY,EAAOqB,KAGzBlG,EAAMI,OAAS,SAAUa,GACvB,OAAO3B,UAAUC,OAASa,EAAOP,MAAMsG,KAAKlF,EAAGiD,IAAW9D,IAASY,IAAI,IAGzEhB,EAAMoG,MAAQ,SAAUP,GACtB,IAII7B,EAJAqC,EAAIjG,IACJkG,EAAKD,EAAE,GACPE,EAAKF,EAAEA,EAAE9G,OAAS,GAClBiH,EAAID,EAAKD,EAMb,OAJIE,IAAGxC,EAAIsC,EAAIA,EAAKC,EAAIA,EAAKvC,GAE7BA,GADAA,EAAI4B,EAAaC,EAAUS,EAAIC,IACvBvC,EAAEpE,MAAM0G,EAAIC,EAAK,GAAK,GAEvBC,EAAIxC,EAAEnD,UAAYmD,GAG3BhE,EAAM2F,WAAa,SAAUc,EAAOC,GAClC,OAAoB,MAAbA,EAAoBf,EAAahB,EAAO+B,IAGjD1G,EAAM2G,KAAO,SAAUd,GACrB,IAAIQ,EAAIjG,IACR,OAAQyF,EAAWD,EAAaC,EAAUQ,EAAE,GAAIA,EAAEA,EAAE9G,OAAS,KAAOa,EAAO,OAAAuG,EAAA,GAAKN,EAAGR,IAAa7F,GAGlGA,EAAMyB,KAAO,WACX,OAAO,YAAKzB,EAAOmE,EAASC,EAAMC,EAAOC,EAAMC,EAAKC,EAAMC,EAAQ3C,EAAQ4C,EAAaC,KAGlF3E,EAEM,SAAS4G,IACtB,OAAOlF,EAAA,EAAUC,MAAMwC,EAAS,EAAU,EAAW,EAAU,EAAS,EAAU,EAAY,IAAY,IAAiB,KAAY/D,OAAO,CAAC,IAAI6D,KAAK,IAAM,EAAG,GAAI,IAAIA,KAAK,IAAM,EAAG,KAAM3E,a,kCC3G/L,sCAAIgH,EAAK,IAAIrC,KACTsC,EAAK,IAAItC,KACE,SAAS4C,EAAYC,EAAQC,EAASN,EAAOO,GAC1D,SAASnB,EAAS9D,GAChB,OAAO+E,EAAO/E,EAA4B,IAArBzC,UAAUC,OAAe,IAAI0E,KAAS,IAAIA,MAAMlC,IAAQA,EAsE/E,OAnEA8D,EAAS/E,MAAQ,SAAUiB,GACzB,OAAO+E,EAAO/E,EAAO,IAAIkC,MAAMlC,IAAQA,GAGzC8D,EAASlG,KAAO,SAAUoC,GACxB,OAAO+E,EAAO/E,EAAO,IAAIkC,KAAKlC,EAAO,IAAKgF,EAAQhF,EAAM,GAAI+E,EAAO/E,GAAOA,GAG5E8D,EAASrF,MAAQ,SAAUuB,GACzB,IAAIkF,EAAKpB,EAAS9D,GACdmF,EAAKrB,EAASlG,KAAKoC,GACvB,OAAOA,EAAOkF,EAAKC,EAAKnF,EAAOkF,EAAKC,GAGtCrB,EAASsB,OAAS,SAAUpF,EAAM3C,GAChC,OAAO2H,EAAQhF,EAAO,IAAIkC,MAAMlC,GAAe,MAAR3C,EAAe,EAAIK,KAAKqB,MAAM1B,IAAQ2C,GAG/E8D,EAASjG,MAAQ,SAAUV,EAAOC,EAAMC,GACtC,IACIgI,EADAxH,EAAQ,GAIZ,GAFAV,EAAQ2G,EAASlG,KAAKT,GACtBE,EAAe,MAARA,EAAe,EAAIK,KAAKqB,MAAM1B,KAC/BF,EAAQC,GAAWC,EAAO,GAAI,OAAOQ,EAE3C,GACEA,EAAMyH,KAAKD,EAAW,IAAInD,MAAM/E,IAAS6H,EAAQ7H,EAAOE,GAAO0H,EAAO5H,SAC/DkI,EAAWlI,GAASA,EAAQC,GAErC,OAAOS,GAGTiG,EAASyB,OAAS,SAAUC,GAC1B,OAAOV,GAAY,SAAU9E,GAC3B,GAAIA,GAAQA,EAAM,KAAO+E,EAAO/E,IAAQwF,EAAKxF,IAC3CA,EAAKC,QAAQD,EAAO,MAErB,SAAUA,EAAM3C,GACjB,GAAI2C,GAAQA,EACV,GAAI3C,EAAO,EAAG,OAASA,GAAQ,GAC7B,KAAO2H,EAAQhF,GAAO,IAAKwF,EAAKxF,UAE3B,OAAS3C,GAAQ,GACtB,KAAO2H,EAAQhF,EAAM,IAAMwF,EAAKxF,UAOpC0E,IACFZ,EAASY,MAAQ,SAAUvH,EAAOgD,GAGhC,OAFAoE,EAAGtE,SAAS9C,GAAQqH,EAAGvE,SAASE,GAChC4E,EAAOR,GAAKQ,EAAOP,GACZ9G,KAAKqB,MAAM2F,EAAMH,EAAIC,KAG9BV,EAASjD,MAAQ,SAAUxD,GAEzB,OADAA,EAAOK,KAAKqB,MAAM1B,GACV0D,SAAS1D,IAAWA,EAAO,EAAcA,EAAO,EAAgByG,EAASyB,OAAON,EAAQ,SAAUX,GACxG,OAAOW,EAAMX,GAAKjH,GAAS,GACzB,SAAUiH,GACZ,OAAOR,EAASY,MAAM,EAAGJ,GAAKjH,GAAS,IAHoByG,EAArB,OAQrCA,I,qBC1ET,IAAI2B,EAAa,EAAQ,QACrBC,EAAY,EAAQ,QACpBC,EAAW,EAAQ,QAGnBC,EAAaD,GAAYA,EAASE,OAmBlCA,EAASD,EAAaF,EAAUE,GAAcH,EAElDzI,EAAOC,QAAU4I,G,wXCzBbC,EAAU,OAAAhC,EAAA,IAAS,SAAU9D,GAC/BA,EAAK+F,YAAY,EAAG,GACpB/F,EAAKgG,YAAY,EAAG,EAAG,EAAG,MACzB,SAAUhG,EAAM3C,GACjB2C,EAAKiG,eAAejG,EAAKkG,iBAAmB7I,MAC3C,SAAUF,EAAOgD,GAClB,OAAOA,EAAI+F,iBAAmB/I,EAAM+I,oBACnC,SAAUlG,GACX,OAAOA,EAAKkG,oBAGdJ,EAAQjF,MAAQ,SAAUC,GACxB,OAAQC,SAASD,EAAIpD,KAAKqB,MAAM+B,KAASA,EAAI,EAAY,OAAAgD,EAAA,IAAS,SAAU9D,GAC1EA,EAAKiG,eAAevI,KAAKqB,MAAMiB,EAAKkG,iBAAmBpF,GAAKA,GAC5Dd,EAAK+F,YAAY,EAAG,GACpB/F,EAAKgG,YAAY,EAAG,EAAG,EAAG,MACzB,SAAUhG,EAAM3C,GACjB2C,EAAKiG,eAAejG,EAAKkG,iBAAmB7I,EAAOyD,MALH,MASrC,QCrBXqF,GDsBkBL,EAAQjI,MCtBf,OAAAiG,EAAA,IAAS,SAAU9D,GAChCA,EAAKoG,WAAW,GAChBpG,EAAKgG,YAAY,EAAG,EAAG,EAAG,MACzB,SAAUhG,EAAM3C,GACjB2C,EAAK+F,YAAY/F,EAAKqG,cAAgBhJ,MACrC,SAAUF,EAAOgD,GAClB,OAAOA,EAAIkG,cAAgBlJ,EAAMkJ,cAAkE,IAAjDlG,EAAI+F,iBAAmB/I,EAAM+I,qBAC9E,SAAUlG,GACX,OAAOA,EAAKqG,kBAEC,I,GACQF,EAAStI,M,WCThC,SAASyI,EAAW7I,GAClB,OAAO,OAAAqG,EAAA,IAAS,SAAU9D,GACxBA,EAAKoG,WAAWpG,EAAKuG,cAAgBvG,EAAKwG,YAAc,EAAI/I,GAAK,GACjEuC,EAAKgG,YAAY,EAAG,EAAG,EAAG,MACzB,SAAUhG,EAAM3C,GACjB2C,EAAKoG,WAAWpG,EAAKuG,aAAsB,EAAPlJ,MACnC,SAAUF,EAAOgD,GAClB,OAAQA,EAAMhD,GAASmE,EAAA,KAIpB,IAAImF,EAAYH,EAAW,GACvBI,EAAYJ,EAAW,GACvBK,EAAaL,EAAW,GACxBM,EAAeN,EAAW,GAC1BO,EAAcP,EAAW,GACzBQ,EAAYR,EAAW,GACvBS,EAAcT,EAAW,GClBhCU,GDmBoBP,EAAU5I,MACV6I,EAAU7I,MACT8I,EAAW9I,MACT+I,EAAa/I,MACdgJ,EAAYhJ,MACdiJ,EAAUjJ,MACRkJ,EAAYlJ,MCzBzB,OAAAiG,EAAA,IAAS,SAAU9D,GAC9BA,EAAKgG,YAAY,EAAG,EAAG,EAAG,MACzB,SAAUhG,EAAM3C,GACjB2C,EAAKoG,WAAWpG,EAAKuG,aAAelJ,MACnC,SAAUF,EAAOgD,GAClB,OAAQA,EAAMhD,GAASmE,EAAA,KACtB,SAAUtB,GACX,OAAOA,EAAKuG,aAAe,MAEd,ICTXU,GDUiBD,EAAOnJ,MCVd,OAAAiG,EAAA,IAAS,SAAU9D,GAC/BA,EAAKkH,cAAc,EAAG,EAAG,MACxB,SAAUlH,EAAM3C,GACjB2C,EAAKC,SAASD,EAAO3C,EAAOiE,EAAA,MAC3B,SAAUnE,EAAOgD,GAClB,OAAQA,EAAMhD,GAASmE,EAAA,KACtB,SAAUtB,GACX,OAAOA,EAAKmH,kBAEC,ICTXC,GDUkBH,EAAQpJ,MCVd,OAAAiG,EAAA,IAAS,SAAU9D,GACjCA,EAAKqH,cAAc,EAAG,MACrB,SAAUrH,EAAM3C,GACjB2C,EAAKC,SAASD,EAAO3C,EAAOiE,EAAA,MAC3B,SAAUnE,EAAOgD,GAClB,OAAQA,EAAMhD,GAASmE,EAAA,KACtB,SAAUtB,GACX,OAAOA,EAAKsH,oBAEC,I,GACSF,EAAUvJ,M,+DCZnB,SAAS0J,EAAkBC,EAAKC,IAClC,MAAPA,GAAeA,EAAMD,EAAIhK,UAAQiK,EAAMD,EAAIhK,QAE/C,IAAK,IAAIC,EAAI,EAAGiK,EAAO,IAAI5J,MAAM2J,GAAMhK,EAAIgK,EAAKhK,IAC9CiK,EAAKjK,GAAK+J,EAAI/J,GAGhB,OAAOiK,ECHM,SAASC,EAAmBH,GACzC,OCJa,SAA4BA,GACzC,GAAI1J,MAAM8J,QAAQJ,GAAM,OAAOK,EAAiBL,GDGzCM,CAAkBN,IELZ,SAA0BO,GACvC,GAAsB,oBAAXC,QAA0BA,OAAOC,YAAYC,OAAOH,GAAO,OAAOjK,MAAMsG,KAAK2D,GFIvDI,CAAgBX,IGJpC,SAAqCY,EAAGC,GACrD,GAAKD,EAAL,CACA,GAAiB,iBAANA,EAAgB,OAAOP,EAAiBO,EAAGC,GACtD,IAAI/K,EAAI4K,OAAOI,UAAUC,SAASC,KAAKJ,GAAGK,MAAM,GAAI,GAEpD,MADU,WAANnL,GAAkB8K,EAAEM,cAAapL,EAAI8K,EAAEM,YAAYC,MAC7C,QAANrL,GAAqB,QAANA,EAAoBQ,MAAMsG,KAAKgE,GACxC,cAAN9K,GAAqB,2CAA2CkI,KAAKlI,GAAWuK,EAAiBO,EAAGC,QAAxG,GHFyDO,CAA2BpB,IILvE,WACb,MAAM,IAAIqB,UAAU,wIJIwEC,GKL/E,SAASC,EAAgBC,EAAKC,EAAK/L,GAYhD,OAXI+L,KAAOD,EACTd,OAAOgB,eAAeF,EAAKC,EAAK,CAC9B/L,MAAOA,EACPiM,YAAY,EACZC,cAAc,EACdC,UAAU,IAGZL,EAAIC,GAAO/L,EAGN8L,ECVT,SAASM,EAAQC,EAAQC,GACvB,IAAIC,EAAOvB,OAAOuB,KAAKF,GAEvB,GAAIrB,OAAOwB,sBAAuB,CAChC,IAAIC,EAAUzB,OAAOwB,sBAAsBH,GACvCC,IAAgBG,EAAUA,EAAQpE,QAAO,SAAUqE,GACrD,OAAO1B,OAAO2B,yBAAyBN,EAAQK,GAAKT,eAEtDM,EAAKnE,KAAK1F,MAAM6J,EAAME,GAGxB,OAAOF,EAGM,SAASK,EAAe/F,GACrC,IAAK,IAAItG,EAAI,EAAGA,EAAIF,UAAUC,OAAQC,IAAK,CACzC,IAAIsM,EAAyB,MAAhBxM,UAAUE,GAAaF,UAAUE,GAAK,GAE/CA,EAAI,EACN6L,EAAQpB,OAAO6B,IAAS,GAAMC,SAAQ,SAAUf,GAC9CC,EAAenF,EAAQkF,EAAKc,EAAOd,OAE5Bf,OAAO+B,0BAChB/B,OAAOgC,iBAAiBnG,EAAQmE,OAAO+B,0BAA0BF,IAEjET,EAAQpB,OAAO6B,IAASC,SAAQ,SAAUf,GACxCf,OAAOgB,eAAenF,EAAQkF,EAAKf,OAAO2B,yBAAyBE,EAAQd,OAKjF,OAAOlF,E,ICnBIoG,EAA6C,CACtD,SAAAnK,GAAI,OAAIA,kBAAJ,IACJ,SAAAA,GAAI,OAAIA,aAAJ,IACJ,SAAAA,GAAI,OAAIA,aAAJ,IACJ,SAAAA,GAAI,OAAIA,WAAJ,IACJ,SAAAA,GAAI,OAAIA,UAAJ,IACJ,SAAAA,GAAI,OAAIA,WAAJ,KAGKoK,EAA2E,CACpFzH,YADoF,GAEpF5C,OAAQoK,UAF4E,GAGpFzH,OAAQyH,UAH4E,GAIpF1H,KAAM0H,UAJ8E,GAKpF3H,IAAK2H,UAL+E,GAMpF7H,MAAO6H,UAN6E,GAOpF9H,KAAM8H,cAWGE,EAAuB,SAAC,GAQ9B,IAAD,IAPFzH,cAOE,MAPO,SAOP,MANF0H,iBAME,MANU,cAMV,MALFC,cAKE,SACIC,EAjB2B,SAACF,GAAD,OAA+B,YAKhE,OAJAF,cAA0C,SAAAK,GACtCA,QAGGzK,GAYa0K,CAApB,GAEA,OAAO,YACH,YAAIxN,EACA,OAAOA,EAGX,GAAI0F,cAAuB1F,aAA3B,KACI,OAAOsN,EAAP,GAGJ,IAAMG,EAAYJ,EAASK,YAAH,GAAsBC,YAA9C,GACA,OAAOL,EAAYG,EAAnB,MC3DKG,EAAoB,kBAY3B,IACF,EACoB,EAMpB,EACoB,EATnB,IAVGrL,WAUH,MAVS,EAUT,MATG9B,WASH,MATS,OAST,MARGoN,eAQH,aAPGjM,eAOH,aANGkM,aAMH,aALGpG,YAKH,SAED,SAAInF,EACAwL,GAAWF,gBAAmBG,EAAnBH,4BAA0CG,EAArDD,IAEAA,IAIJ,SAAItN,EACAwN,GAAWJ,gBAAmBG,EAAnBH,4BAA0CG,EAArDC,IAEAA,IAGJ,IAAMlN,EAAQmN,yBACEC,QAAe,CAAC,EAAhBA,GAA2B,CAACC,EAD9BF,WAEFtM,EAAU,CAACqM,EAAJ,GAA0B,CAACF,EAFhCG,UAAd,IAKA,IAAIxG,EAAe3G,EAAnB,OACK,iBAAW2G,GAAmB3G,UAEnC,IAAMsN,EAAN,EAIA,OAHAA,gBACAA,YAEOA,GCtCEC,EAAkB,gBAWzB,IAGF,EASA,EAZC,IATG5I,cASH,MATY,SASZ,MARG0H,iBAQH,MARe,cAQf,MAPG7K,WAOH,MAPS,OAOT,MANG9B,WAMH,MANS,OAMT,MALG4M,cAKH,aAJG3F,YAIH,SACK6G,EAAYpB,EAAqB,CAAEzH,OAAF,EAAU0H,UAAV,EAAqBC,WAIxDU,EADJ,SAAIxL,EACWgM,EAAUP,EAArBD,KACG,WAAIrI,EACI6I,EAAXR,GAEAA,EAKAE,EADJ,SAAIxN,EACW8N,EAAUP,EAArBC,KACG,WAAIvI,EACI6I,EAAXN,GAEAA,EAGJ,IAAMlN,EAAQsM,EChCH,WACb,OAAO5K,EAAA,EAAUC,MAAM,YAAS,EAAS,EAAU,EAAS,EAAQ,EAAS,EAAW,IAAW,IAAgB,KAAWvB,OAAO,CAAC6D,KAAKwJ,IAAI,IAAM,EAAG,GAAIxJ,KAAKwJ,IAAI,IAAM,EAAG,KAAMnO,WD+B3JoO,GAAaC,cAEpC3N,QAAY,CAAC,EAAbA,IAEIgN,GAAJ,GAA0BhN,SAAa,CAACgN,EAAdhN,KAE1B,IAAI2G,EAAe3G,EAAnB,OACS,iBAAO2G,GAAX,iBAAuCA,GAAmB3G,UAE/D,IAAMsN,EAAN,EAKA,OAHAA,cACAA,WAEOA,GEGEM,EAAgB,SAACC,EAAD,UAA4CA,IAA5C,GAChBC,EAAoB,SAACD,EAAD,UAAsBA,cAAgBE,EAAtC,WAE1B,SAASC,GAAT,SAMH,OAAQC,EAAR,MACI,IAAI,SACA,OAAOpB,EAAkBoB,EAAK,EAAN,EAAxB,GACJ,IAAI,QACA,OC/DoB,gBAK5B,IAEMX,EAFQY,oBAA0B,CAAC,EAA3BA,WAA4CjB,EAA1D,KAKA,OAFAK,eAEOA,EDqDQa,CAAgB,IAAvB,GACJ,IAAI,OACA,OEjEmB,kBAKzB,IAAD,IAJC3N,aAID,SAMK8M,EALQc,oBACHhB,QAAe,CAAC,EAAhBA,GAA2B,CAACC,EADzBe,WAEFnB,EAFEmB,WAAd,GAQA,OAFAd,cAEOA,EFmDQe,CAAe,MAAtB,GACJ,IAAI,OACA,OAAOd,EAAgBU,EAAK,EAA5B,GACJ,IAAI,MACA,OGrEkB,SAAC,EAAD,OAKxB,IAMF,EANC,IAJCK,YAID,MAJQ,GAIR,MAJY9M,WAIZ,MAJkB,OAIlB,MAJ0B9B,WAI1B,MAJgC,OAIhC,EAED,GADgBuN,EAAA,UAAc,SAAAsB,GAAC,WAAIA,KAE/B,MAAM,UAAN,qDAIJ,IAgBA,EAOA,EAvBIC,GAAJ,EAYA,GAXAvB,cACY,SAAAsB,GAAC,aAAIA,KADjBtB,SAEa,SAAAsB,GACL,SACA,IAAIE,EACAA,EAAOhP,UAAPgP,GACOhP,eAAJ,IACH+O,UAIZ,EACI,MAAM,UAAN,qEAKAxB,EADJ,SAAIxL,EACWyL,EAAXD,IAEAA,EAKAE,EADJ,SAAIxN,EACWuN,EAAXC,IAEAA,EAGJ,IAAMlN,EAAQ0O,qBACF,CAAC1B,EADC0B,eAEEtB,QAAe,CAAC,EAAhBA,GAA2B,CAACC,EAF9BqB,YAAd,OASA,OAHA,EACApB,WAEOtN,EHkBQ2O,CAAeV,EAAK,EAAN,EAArB,GACJ,IAAI,SACA,OIvEqB,SAAC,EAAD,OAK3B,IACF,EAOA,EARC,IAJCW,gBAID,MAJY,EAIZ,MAJepN,WAIf,MAJqB,OAIrB,MAJ6B9B,WAI7B,MAJmC,OAInC,MAJ2CmB,eAI3C,SAGGmM,EADJ,SAAIxL,EACWyL,EAAXD,IAEAA,EAKAE,EADJ,SAAIxN,EACWuN,EAAXC,IAEAA,EAGJ,IAAMlN,EAAQ6O,qCAEEzB,QAAe,CAAC,EAAhBA,GAA2B,CAACC,EAF9BwB,IAAd,QAKA,IAAIhO,EAAkBb,SAAa,CAACkN,EAApC,IACKlN,SAAa,CAACgN,EAAdhN,IAEL,IAAMsN,EAAN,EAGA,OAFAA,gBAEOA,EJwCQwB,CAAkBb,EAAK,EAAN,EAAxB,GACJ,QACI,MAAM,UAAN,uB,IAICc,GAA2B,SAAC,EAAD,SAOpC,IAAMC,EAASC,EAAA,KAAY,SAAAC,GAAK,qBAE5BjC,KAAMiC,EAAA,UAAe,SAAA7I,GAAC,MAAK,CAAE4G,KAAK,EAAD,eAG/BkC,EAAKC,GAAiBJ,EAAO,EAAnC,GACI,gBAAJ,IAA+BK,WAC3BC,GAAOH,EAAPG,GAEA,gBAAJ,IAA+BC,WAC3BC,GAAOL,EAAPK,GAGJ,IAAMC,EAASzB,GAAaqB,EAAYF,EAAb,IAA3B,KACMO,EAAS1B,GAAauB,EAAYJ,EAAb,IAA3B,KAyBA,OAvBAH,WAAe,SAAAE,GACXA,gBAAmB,SAAA7I,GAAM,IAAD,IACpBA,WAAa,CACTsJ,EACI,oBAAuBF,UACjBpJ,4BAEIoJ,EAAOpJ,OAHjB,UAIMA,+BAEAoJ,EAAOpJ,OAFPA,kBAND,KASTH,EACI,oBAAuBwJ,UACjBrJ,4BAEIqJ,EAAOrJ,OAHjB,UAIMA,+BAEAqJ,EAAOrJ,OAFPA,kBAEoB,YAKnC,EAAP,YAEI2I,OAFJ,EAGIS,OAHJ,EAIIC,YAIKN,GAAmB,sBAI1B,CACFO,EAAGC,GAAkB,MADnB,GAEF1J,EAAG0J,GAAkB,WAOZA,GAAqB,gBAa5B,IAAD,yDADG,GACH,IARGC,gBAQH,MARc,SAAAxJ,GAAC,OAAIA,OAAJ,IAQf,MAPGyJ,gBAOH,MAPc,cACPzJ,aAMP,EACD,cAAI0J,OACAf,WAAe,SAAAE,GACXA,gBAAmB,SAAA7I,GACf,IAAMpH,EAAQ4Q,EAAd,GAEA,GACIC,EAASzJ,EAAI2J,WAAWC,OAAxBH,gBAIT,GAAIC,iBAAJ,WAAiCA,SAA+B,CAGnE,IAAMrD,EAAYN,EAAlB,GAEA4C,WAAe,SAAAE,GACXA,gBAAmB,SAAA7I,GACf,IAAMpH,EAAQ4Q,EAAd,GAEA,GACIC,EAASzJ,EAAIqG,EAAboD,UAMhB,IAAM/O,EAAN,GAQA,OANAiO,WAAe,SAAAE,GACXA,gBAAmB,SAAA7I,GACftF,OAAY8O,EAAZ9O,UAIAgP,EAAR,MACI,IAAI,SACA,IAAMG,EAAMC,IAAOC,IAAD,IAA2B,SAAA7B,GAAC,YAE9C,MAAO,CAAE2B,IAAF,EAAO1O,IAAK/B,oBAAI,EAAhB,IAA8BC,IAAKD,oBAAI,OAElD,IAAI,OACA,IAAMyQ,EAAM,IAAOnP,GAAkB,SAAAwN,GAAC,OAAIA,EAAJ,aAA1B,eAEF,qBAAUR,YAAcF,EAAxB,aAFV,UAKA,MAAO,CAAEqC,IAAF,EAAO1O,IAAK0O,EAAZ,GAAoBxQ,IAAK2Q,IAAK,IAEzC,QACI,IAAMH,EAAME,IAAZ,GAEA,MAAO,CAAEF,IAAF,EAAO1O,IAAK0O,EAAZ,GAAoBxQ,IAAK2Q,IAAK,MAKpCC,GAAY,SAAClD,EAAD,KACrB,IAAMmD,EAvKkB,SAACnD,GAAD,MAAiCA,YAAjC,IAuKNoD,CAAlB,GACMN,EAAN,GAEAf,kBAA0B,SAAAZ,GACtB,IAAMkC,EAAW7I,SAAjB,EACM8I,EAAN,GAEA1B,WAAe,SAAAE,GACX,IAAMyB,EAAQzB,EAAA,WAAgB,SAAA7I,GAAC,OAAIoK,EAAQpK,OAAD,GAAX,MAC3BpH,EAAJ,KACI2R,EAAJ,KAEA,YAAID,EAAqB,CAErB,WADA1R,EAAQ0R,OAAR1R,IACoB,CAChB,IAAM4R,EAAOR,IAAb,QACA,IAAIQ,EACAD,IACG,OAAIC,IACPD,EAAaC,EAAbD,GAIRD,iCAGJD,UAEA,OAAIE,GACAV,gBAKZf,gBAAsB1P,oBAAtB0P,GACAA,gBAAsB1P,oBAAtB0P,IAGEG,GAAS,SAACH,EAAD,UAA+CmB,GAAU,IAAI,EAA7D,IACTd,GAAS,SAACL,EAAD,UAA+CmB,GAAU,IAAI,EAA7D,K,kCKjQf,0KAAO,IAAI/K,EAAiB,IACjBC,EAAiB,IACjBC,EAAe,KACfC,EAAc,MACdoL,EAAe,Q,kCCJ1B,gBACIpM,EAAc,aAAS,eACxB,SAAU3C,EAAM3C,GACjB2C,EAAKC,SAASD,EAAO3C,MACpB,SAAUF,EAAOgD,GAClB,OAAOA,EAAMhD,KAGfwF,EAAY9B,MAAQ,SAAUC,GAE5B,OADAA,EAAIpD,KAAKqB,MAAM+B,GACVC,SAASD,IAAQA,EAAI,EACpBA,EAAI,EACH,aAAS,SAAUd,GACxBA,EAAKC,QAAQvC,KAAKqB,MAAMiB,EAAOc,GAAKA,MACnC,SAAUd,EAAM3C,GACjB2C,EAAKC,SAASD,EAAO3C,EAAOyD,MAC3B,SAAU3D,EAAOgD,GAClB,OAAQA,EAAMhD,GAAS2D,KANJ6B,EADgB,MAWxB,MACWA,EAAY9E","file":"7643800e8d67c015564d5d55486b2e966569930b-2606ba17363025c5c954.js","sourcesContent":["var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar dateTag = '[object Date]';\n\n/**\n * The base implementation of `_.isDate` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n */\nfunction baseIsDate(value) {\n  return isObjectLike(value) && baseGetTag(value) == dateTag;\n}\n\nmodule.exports = baseIsDate;\n","export default function (start, stop, step) {\n  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;\n  var i = -1,\n      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,\n      range = new Array(n);\n\n  while (++i < n) {\n    range[i] = start + i * step;\n  }\n\n  return range;\n}","import _slicedToArray from \"/Users/neil/Projects/external/nivo/node_modules/gatsby/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { range as sequence } from \"d3-array\";\nimport { initRange } from \"./init.js\";\nimport ordinal from \"./ordinal.js\";\nexport default function band() {\n  var scale = ordinal().unknown(undefined),\n      domain = scale.domain,\n      ordinalRange = scale.range,\n      r0 = 0,\n      r1 = 1,\n      step,\n      bandwidth,\n      round = false,\n      paddingInner = 0,\n      paddingOuter = 0,\n      align = 0.5;\n  delete scale.unknown;\n\n  function rescale() {\n    var n = domain().length,\n        reverse = r1 < r0,\n        start = reverse ? r1 : r0,\n        stop = reverse ? r0 : r1;\n    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);\n    if (round) step = Math.floor(step);\n    start += (stop - start - step * (n - paddingInner)) * align;\n    bandwidth = step * (1 - paddingInner);\n    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);\n    var values = sequence(n).map(function (i) {\n      return start + step * i;\n    });\n    return ordinalRange(reverse ? values.reverse() : values);\n  }\n\n  scale.domain = function (_) {\n    return arguments.length ? (domain(_), rescale()) : domain();\n  };\n\n  scale.range = function (_) {\n    var _ref, _ref2;\n\n    return arguments.length ? ((_ref = _, _ref2 = _slicedToArray(_ref, 2), r0 = _ref2[0], r1 = _ref2[1], _ref), r0 = +r0, r1 = +r1, rescale()) : [r0, r1];\n  };\n\n  scale.rangeRound = function (_) {\n    var _ref3, _ref4;\n\n    return (_ref3 = _, _ref4 = _slicedToArray(_ref3, 2), r0 = _ref4[0], r1 = _ref4[1], _ref3), r0 = +r0, r1 = +r1, round = true, rescale();\n  };\n\n  scale.bandwidth = function () {\n    return bandwidth;\n  };\n\n  scale.step = function () {\n    return step;\n  };\n\n  scale.round = function (_) {\n    return arguments.length ? (round = !!_, rescale()) : round;\n  };\n\n  scale.padding = function (_) {\n    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;\n  };\n\n  scale.paddingInner = function (_) {\n    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;\n  };\n\n  scale.paddingOuter = function (_) {\n    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;\n  };\n\n  scale.align = function (_) {\n    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;\n  };\n\n  scale.copy = function () {\n    return band(domain(), [r0, r1]).round(round).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);\n  };\n\n  return initRange.apply(rescale(), arguments);\n}\n\nfunction pointish(scale) {\n  var copy = scale.copy;\n  scale.padding = scale.paddingOuter;\n  delete scale.paddingInner;\n  delete scale.paddingOuter;\n\n  scale.copy = function () {\n    return pointish(copy());\n  };\n\n  return scale;\n}\n\nexport function point() {\n  return pointish(band.apply(null, arguments).paddingInner(1));\n}","import interval from \"./interval.js\";\nimport { durationSecond } from \"./duration.js\";\nvar second = interval(function (date) {\n  date.setTime(date - date.getMilliseconds());\n}, function (date, step) {\n  date.setTime(+date + step * durationSecond);\n}, function (start, end) {\n  return (end - start) / durationSecond;\n}, function (date) {\n  return date.getUTCSeconds();\n});\nexport default second;\nexport var seconds = second.range;","var baseIteratee = require('./_baseIteratee'),\n    baseUniq = require('./_baseUniq');\n\n/**\n * This method is like `_.uniq` except that it accepts `iteratee` which is\n * invoked for each element in `array` to generate the criterion by which\n * uniqueness is computed. The order of result values is determined by the\n * order they occur in the array. The iteratee is invoked with one argument:\n * (value).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n * @returns {Array} Returns the new duplicate free array.\n * @example\n *\n * _.uniqBy([2.1, 1.2, 2.3], Math.floor);\n * // => [2.1, 1.2]\n *\n * // The `_.property` iteratee shorthand.\n * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n * // => [{ 'x': 1 }, { 'x': 2 }]\n */\nfunction uniqBy(array, iteratee) {\n  return (array && array.length) ? baseUniq(array, baseIteratee(iteratee, 2)) : [];\n}\n\nmodule.exports = uniqBy;\n","import interval from \"./interval.js\";\nvar year = interval(function (date) {\n  date.setMonth(0, 1);\n  date.setHours(0, 0, 0, 0);\n}, function (date, step) {\n  date.setFullYear(date.getFullYear() + step);\n}, function (start, end) {\n  return end.getFullYear() - start.getFullYear();\n}, function (date) {\n  return date.getFullYear();\n}); // An optimized implementation for this simple case.\n\nyear.every = function (k) {\n  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : interval(function (date) {\n    date.setFullYear(Math.floor(date.getFullYear() / k) * k);\n    date.setMonth(0, 1);\n    date.setHours(0, 0, 0, 0);\n  }, function (date, step) {\n    date.setFullYear(date.getFullYear() + step * k);\n  });\n};\n\nexport default year;\nexport var years = year.range;","import interval from \"./interval.js\";\nvar month = interval(function (date) {\n  date.setDate(1);\n  date.setHours(0, 0, 0, 0);\n}, function (date, step) {\n  date.setMonth(date.getMonth() + step);\n}, function (start, end) {\n  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;\n}, function (date) {\n  return date.getMonth();\n});\nexport default month;\nexport var months = month.range;","import interval from \"./interval.js\";\nimport { durationMinute, durationWeek } from \"./duration.js\";\n\nfunction weekday(i) {\n  return interval(function (date) {\n    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);\n    date.setHours(0, 0, 0, 0);\n  }, function (date, step) {\n    date.setDate(date.getDate() + step * 7);\n  }, function (start, end) {\n    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;\n  });\n}\n\nexport var sunday = weekday(0);\nexport var monday = weekday(1);\nexport var tuesday = weekday(2);\nexport var wednesday = weekday(3);\nexport var thursday = weekday(4);\nexport var friday = weekday(5);\nexport var saturday = weekday(6);\nexport var sundays = sunday.range;\nexport var mondays = monday.range;\nexport var tuesdays = tuesday.range;\nexport var wednesdays = wednesday.range;\nexport var thursdays = thursday.range;\nexport var fridays = friday.range;\nexport var saturdays = saturday.range;","import interval from \"./interval.js\";\nimport { durationDay, durationMinute } from \"./duration.js\";\nvar day = interval(function (date) {\n  return date.setHours(0, 0, 0, 0);\n}, function (date, step) {\n  return date.setDate(date.getDate() + step);\n}, function (start, end) {\n  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;\n}, function (date) {\n  return date.getDate() - 1;\n});\nexport default day;\nexport var days = day.range;","import interval from \"./interval.js\";\nimport { durationHour, durationMinute, durationSecond } from \"./duration.js\";\nvar hour = interval(function (date) {\n  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);\n}, function (date, step) {\n  date.setTime(+date + step * durationHour);\n}, function (start, end) {\n  return (end - start) / durationHour;\n}, function (date) {\n  return date.getHours();\n});\nexport default hour;\nexport var hours = hour.range;","import interval from \"./interval.js\";\nimport { durationMinute, durationSecond } from \"./duration.js\";\nvar minute = interval(function (date) {\n  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);\n}, function (date, step) {\n  date.setTime(+date + step * durationMinute);\n}, function (start, end) {\n  return (end - start) / durationMinute;\n}, function (date) {\n  return date.getMinutes();\n});\nexport default minute;\nexport var minutes = minute.range;","import { bisector, tickStep } from \"d3-array\";\nimport { timeYear, timeMonth, timeWeek, timeDay, timeHour, timeMinute, timeSecond, timeMillisecond } from \"d3-time\";\nimport { timeFormat } from \"d3-time-format\";\nimport continuous, { copy } from \"./continuous.js\";\nimport { initRange } from \"./init.js\";\nimport nice from \"./nice.js\";\nvar durationSecond = 1000,\n    durationMinute = durationSecond * 60,\n    durationHour = durationMinute * 60,\n    durationDay = durationHour * 24,\n    durationWeek = durationDay * 7,\n    durationMonth = durationDay * 30,\n    durationYear = durationDay * 365;\n\nfunction date(t) {\n  return new Date(t);\n}\n\nfunction number(t) {\n  return t instanceof Date ? +t : +new Date(+t);\n}\n\nexport function calendar(year, month, week, day, hour, minute, second, millisecond, format) {\n  var scale = continuous(),\n      invert = scale.invert,\n      domain = scale.domain;\n  var formatMillisecond = format(\".%L\"),\n      formatSecond = format(\":%S\"),\n      formatMinute = format(\"%I:%M\"),\n      formatHour = format(\"%I %p\"),\n      formatDay = format(\"%a %d\"),\n      formatWeek = format(\"%b %d\"),\n      formatMonth = format(\"%B\"),\n      formatYear = format(\"%Y\");\n  var tickIntervals = [[second, 1, durationSecond], [second, 5, 5 * durationSecond], [second, 15, 15 * durationSecond], [second, 30, 30 * durationSecond], [minute, 1, durationMinute], [minute, 5, 5 * durationMinute], [minute, 15, 15 * durationMinute], [minute, 30, 30 * durationMinute], [hour, 1, durationHour], [hour, 3, 3 * durationHour], [hour, 6, 6 * durationHour], [hour, 12, 12 * durationHour], [day, 1, durationDay], [day, 2, 2 * durationDay], [week, 1, durationWeek], [month, 1, durationMonth], [month, 3, 3 * durationMonth], [year, 1, durationYear]];\n\n  function tickFormat(date) {\n    return (second(date) < date ? formatMillisecond : minute(date) < date ? formatSecond : hour(date) < date ? formatMinute : day(date) < date ? formatHour : month(date) < date ? week(date) < date ? formatDay : formatWeek : year(date) < date ? formatMonth : formatYear)(date);\n  }\n\n  function tickInterval(interval, start, stop) {\n    if (interval == null) interval = 10; // If a desired tick count is specified, pick a reasonable tick interval\n    // based on the extent of the domain and a rough estimate of tick size.\n    // Otherwise, assume interval is already a time interval and use it.\n\n    if (typeof interval === \"number\") {\n      var target = Math.abs(stop - start) / interval,\n          i = bisector(function (i) {\n        return i[2];\n      }).right(tickIntervals, target),\n          step;\n\n      if (i === tickIntervals.length) {\n        step = tickStep(start / durationYear, stop / durationYear, interval);\n        interval = year;\n      } else if (i) {\n        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];\n        step = i[1];\n        interval = i[0];\n      } else {\n        step = Math.max(tickStep(start, stop, interval), 1);\n        interval = millisecond;\n      }\n\n      return interval.every(step);\n    }\n\n    return interval;\n  }\n\n  scale.invert = function (y) {\n    return new Date(invert(y));\n  };\n\n  scale.domain = function (_) {\n    return arguments.length ? domain(Array.from(_, number)) : domain().map(date);\n  };\n\n  scale.ticks = function (interval) {\n    var d = domain(),\n        t0 = d[0],\n        t1 = d[d.length - 1],\n        r = t1 < t0,\n        t;\n    if (r) t = t0, t0 = t1, t1 = t;\n    t = tickInterval(interval, t0, t1);\n    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop\n\n    return r ? t.reverse() : t;\n  };\n\n  scale.tickFormat = function (count, specifier) {\n    return specifier == null ? tickFormat : format(specifier);\n  };\n\n  scale.nice = function (interval) {\n    var d = domain();\n    return (interval = tickInterval(interval, d[0], d[d.length - 1])) ? domain(nice(d, interval)) : scale;\n  };\n\n  scale.copy = function () {\n    return copy(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));\n  };\n\n  return scale;\n}\nexport default function time() {\n  return initRange.apply(calendar(timeYear, timeMonth, timeWeek, timeDay, timeHour, timeMinute, timeSecond, timeMillisecond, timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);\n}","var t0 = new Date(),\n    t1 = new Date();\nexport default function newInterval(floori, offseti, count, field) {\n  function interval(date) {\n    return floori(date = arguments.length === 0 ? new Date() : new Date(+date)), date;\n  }\n\n  interval.floor = function (date) {\n    return floori(date = new Date(+date)), date;\n  };\n\n  interval.ceil = function (date) {\n    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;\n  };\n\n  interval.round = function (date) {\n    var d0 = interval(date),\n        d1 = interval.ceil(date);\n    return date - d0 < d1 - date ? d0 : d1;\n  };\n\n  interval.offset = function (date, step) {\n    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;\n  };\n\n  interval.range = function (start, stop, step) {\n    var range = [],\n        previous;\n    start = interval.ceil(start);\n    step = step == null ? 1 : Math.floor(step);\n    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date\n\n    do {\n      range.push(previous = new Date(+start)), offseti(start, step), floori(start);\n    } while (previous < start && start < stop);\n\n    return range;\n  };\n\n  interval.filter = function (test) {\n    return newInterval(function (date) {\n      if (date >= date) while (floori(date), !test(date)) {\n        date.setTime(date - 1);\n      }\n    }, function (date, step) {\n      if (date >= date) {\n        if (step < 0) while (++step <= 0) {\n          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty\n\n        } else while (--step >= 0) {\n          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty\n\n        }\n      }\n    });\n  };\n\n  if (count) {\n    interval.count = function (start, end) {\n      t0.setTime(+start), t1.setTime(+end);\n      floori(t0), floori(t1);\n      return Math.floor(count(t0, t1));\n    };\n\n    interval.every = function (step) {\n      step = Math.floor(step);\n      return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval : interval.filter(field ? function (d) {\n        return field(d) % step === 0;\n      } : function (d) {\n        return interval.count(0, d) % step === 0;\n      });\n    };\n  }\n\n  return interval;\n}","var baseIsDate = require('./_baseIsDate'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsDate = nodeUtil && nodeUtil.isDate;\n\n/**\n * Checks if `value` is classified as a `Date` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n * @example\n *\n * _.isDate(new Date);\n * // => true\n *\n * _.isDate('Mon April 23 2012');\n * // => false\n */\nvar isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;\n\nmodule.exports = isDate;\n","import interval from \"./interval.js\";\nvar utcYear = interval(function (date) {\n  date.setUTCMonth(0, 1);\n  date.setUTCHours(0, 0, 0, 0);\n}, function (date, step) {\n  date.setUTCFullYear(date.getUTCFullYear() + step);\n}, function (start, end) {\n  return end.getUTCFullYear() - start.getUTCFullYear();\n}, function (date) {\n  return date.getUTCFullYear();\n}); // An optimized implementation for this simple case.\n\nutcYear.every = function (k) {\n  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : interval(function (date) {\n    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);\n    date.setUTCMonth(0, 1);\n    date.setUTCHours(0, 0, 0, 0);\n  }, function (date, step) {\n    date.setUTCFullYear(date.getUTCFullYear() + step * k);\n  });\n};\n\nexport default utcYear;\nexport var utcYears = utcYear.range;","import interval from \"./interval.js\";\nvar utcMonth = interval(function (date) {\n  date.setUTCDate(1);\n  date.setUTCHours(0, 0, 0, 0);\n}, function (date, step) {\n  date.setUTCMonth(date.getUTCMonth() + step);\n}, function (start, end) {\n  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;\n}, function (date) {\n  return date.getUTCMonth();\n});\nexport default utcMonth;\nexport var utcMonths = utcMonth.range;","import interval from \"./interval.js\";\nimport { durationWeek } from \"./duration.js\";\n\nfunction utcWeekday(i) {\n  return interval(function (date) {\n    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);\n    date.setUTCHours(0, 0, 0, 0);\n  }, function (date, step) {\n    date.setUTCDate(date.getUTCDate() + step * 7);\n  }, function (start, end) {\n    return (end - start) / durationWeek;\n  });\n}\n\nexport var utcSunday = utcWeekday(0);\nexport var utcMonday = utcWeekday(1);\nexport var utcTuesday = utcWeekday(2);\nexport var utcWednesday = utcWeekday(3);\nexport var utcThursday = utcWeekday(4);\nexport var utcFriday = utcWeekday(5);\nexport var utcSaturday = utcWeekday(6);\nexport var utcSundays = utcSunday.range;\nexport var utcMondays = utcMonday.range;\nexport var utcTuesdays = utcTuesday.range;\nexport var utcWednesdays = utcWednesday.range;\nexport var utcThursdays = utcThursday.range;\nexport var utcFridays = utcFriday.range;\nexport var utcSaturdays = utcSaturday.range;","import interval from \"./interval.js\";\nimport { durationDay } from \"./duration.js\";\nvar utcDay = interval(function (date) {\n  date.setUTCHours(0, 0, 0, 0);\n}, function (date, step) {\n  date.setUTCDate(date.getUTCDate() + step);\n}, function (start, end) {\n  return (end - start) / durationDay;\n}, function (date) {\n  return date.getUTCDate() - 1;\n});\nexport default utcDay;\nexport var utcDays = utcDay.range;","import interval from \"./interval.js\";\nimport { durationHour } from \"./duration.js\";\nvar utcHour = interval(function (date) {\n  date.setUTCMinutes(0, 0, 0);\n}, function (date, step) {\n  date.setTime(+date + step * durationHour);\n}, function (start, end) {\n  return (end - start) / durationHour;\n}, function (date) {\n  return date.getUTCHours();\n});\nexport default utcHour;\nexport var utcHours = utcHour.range;","import interval from \"./interval.js\";\nimport { durationMinute } from \"./duration.js\";\nvar utcMinute = interval(function (date) {\n  date.setUTCSeconds(0, 0);\n}, function (date, step) {\n  date.setTime(+date + step * durationMinute);\n}, function (start, end) {\n  return (end - start) / durationMinute;\n}, function (date) {\n  return date.getUTCMinutes();\n});\nexport default utcMinute;\nexport var utcMinutes = utcMinute.range;","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayWithoutHoles from \"@babel/runtime/helpers/esm/arrayWithoutHoles\";\nimport iterableToArray from \"@babel/runtime/helpers/esm/iterableToArray\";\nimport unsupportedIterableToArray from \"@babel/runtime/helpers/esm/unsupportedIterableToArray\";\nimport nonIterableSpread from \"@babel/runtime/helpers/esm/nonIterableSpread\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"@babel/runtime/helpers/esm/arrayLikeToArray\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}","import arrayLikeToArray from \"@babel/runtime/helpers/esm/arrayLikeToArray\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}","import { timeParse, utcParse } from 'd3-time-format'\n\nexport const timePrecisions = [\n    'millisecond',\n    'second',\n    'minute',\n    'hour',\n    'day',\n    'month',\n    'year',\n] as const\n\nexport type TIME_PRECISION = typeof timePrecisions[number]\n\nexport const precisionCutOffs: ((date: Date) => void)[] = [\n    date => date.setMilliseconds(0),\n    date => date.setSeconds(0),\n    date => date.setMinutes(0),\n    date => date.setHours(0),\n    date => date.setDate(1),\n    date => date.setMonth(0),\n]\n\nexport const precisionCutOffsByType: Record<TIME_PRECISION, ((date: Date) => void)[]> = {\n    millisecond: [],\n    second: precisionCutOffs.slice(0, 1),\n    minute: precisionCutOffs.slice(0, 2),\n    hour: precisionCutOffs.slice(0, 3),\n    day: precisionCutOffs.slice(0, 4),\n    month: precisionCutOffs.slice(0, 5),\n    year: precisionCutOffs.slice(0, 6),\n}\n\nexport const createPrecisionMethod = (precision: TIME_PRECISION) => (date: Date) => {\n    precisionCutOffsByType[precision].forEach(cutOff => {\n        cutOff(date)\n    })\n\n    return date\n}\n\nexport const createDateNormalizer = ({\n    format = 'native',\n    precision = 'millisecond',\n    useUTC = true,\n}: {\n    format?: 'native' | string\n    precision?: TIME_PRECISION\n    useUTC?: boolean\n}) => {\n    const precisionFn = createPrecisionMethod(precision)\n\n    return (value: Date | string | undefined) => {\n        if (value === undefined) {\n            return value\n        }\n\n        if (format === 'native' || value instanceof Date) {\n            return precisionFn(value as Date)\n        }\n\n        const parseTime = useUTC ? utcParse(format) : timeParse(format)\n        return precisionFn(parseTime(value as string) as Date)\n    }\n}\n","import { NumberValue, scaleLinear } from 'd3-scale'\nimport { ScaleLinearSpec, ScaleLinear, ComputedSerieAxis, ScaleAxis } from './types'\n\nexport const createLinearScale = <Output extends NumberValue>(\n    {\n        min = 0,\n        max = 'auto',\n        stacked = false,\n        reverse = false,\n        clamp = false,\n        nice = false,\n    }: ScaleLinearSpec,\n    data: ComputedSerieAxis<Output>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    let minValue: NumberValue\n    if (min === 'auto') {\n        minValue = stacked === true ? data.minStacked ?? 0 : data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: NumberValue\n    if (max === 'auto') {\n        maxValue = stacked === true ? data.maxStacked ?? 0 : data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleLinear<number, Output>()\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .domain(reverse ? [maxValue, minValue] : [minValue, maxValue])\n        .clamp(clamp)\n\n    if (nice === true) scale.nice()\n    else if (typeof nice === 'number') scale.nice(nice)\n\n    const typedScale = (scale as unknown) as ScaleLinear<number>\n    typedScale.type = 'linear'\n    typedScale.stacked = stacked\n\n    return typedScale\n}\n","import { NumberValue, scaleTime, scaleUtc } from 'd3-scale'\nimport { createDateNormalizer } from './timeHelpers'\nimport { ComputedSerieAxis, ScaleTime, ScaleTimeSpec } from './types'\n\nexport const createTimeScale = <Input extends Date | NumberValue>(\n    {\n        format = 'native',\n        precision = 'millisecond',\n        min = 'auto',\n        max = 'auto',\n        useUTC = true,\n        nice = false,\n    }: ScaleTimeSpec,\n    data: ComputedSerieAxis<string | Date>,\n    size: number\n) => {\n    const normalize = createDateNormalizer({ format, precision, useUTC })\n\n    let minValue: Date | undefined\n    if (min === 'auto') {\n        minValue = normalize(data.min)\n    } else if (format !== 'native') {\n        minValue = normalize(min)\n    } else {\n        minValue = min as Date\n    }\n\n    let maxValue: Date | undefined\n    if (max === 'auto') {\n        maxValue = normalize(data.max)\n    } else if (format !== 'native') {\n        maxValue = normalize(max)\n    } else {\n        maxValue = max as Date\n    }\n\n    const scale = useUTC ? scaleUtc() : scaleTime()\n\n    scale.range([0, size])\n\n    if (minValue && maxValue) scale.domain([minValue, maxValue])\n\n    if (nice === true) scale.nice()\n    else if (typeof nice === 'object' || typeof nice === 'number') scale.nice(nice)\n\n    const typedScale = (scale as unknown) as ScaleTime<Input>\n\n    typedScale.type = 'time'\n    typedScale.useUTC = useUTC\n\n    return typedScale\n}\n","import { calendar } from \"./time.js\";\nimport { utcFormat } from \"d3-time-format\";\nimport { utcYear, utcMonth, utcWeek, utcDay, utcHour, utcMinute, utcSecond, utcMillisecond } from \"d3-time\";\nimport { initRange } from \"./init.js\";\nexport default function utcTime() {\n  return initRange.apply(calendar(utcYear, utcMonth, utcWeek, utcDay, utcHour, utcMinute, utcSecond, utcMillisecond, utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]), arguments);\n}","import uniq from 'lodash/uniq'\nimport uniqBy from 'lodash/uniqBy'\nimport sortBy from 'lodash/sortBy'\nimport last from 'lodash/last'\nimport isDate from 'lodash/isDate'\nimport { createDateNormalizer } from './timeHelpers'\nimport { ScaleAxis, ScaleSpec, Series, ScaleValue, SerieAxis, ComputedSerieAxis } from './types'\nimport { createLinearScale } from './linearScale'\nimport { createPointScale } from './pointScale'\nimport { createBandScale } from './bandScale'\nimport { createTimeScale } from './timeScale'\nimport { createLogScale } from './logScale'\nimport { createSymlogScale } from './symlogScale'\n\ntype XY = ReturnType<typeof generateSeriesXY>\n\ntype StackedXY = {\n    [K in keyof XY]: XY[K] & {\n        maxStacked: number\n        minStacked: number\n    }\n}\n\ntype InputXYSeries = Record<'x' | 'y', number | string | Date | null>\n\ninterface Data {\n    x: number\n    xStacked: number | null\n    y: number\n    yStacked: number | null\n\n    // Allow template literal `xStacked/yStacked` to be set on line 213\n    [key: string]: number | null\n}\n\ntype XYSeries = InputXYSeries & {\n    data: Data[]\n}\n\ninterface ComputedXYSeries extends InputXYSeries {\n    data: Array<{\n        data: Data\n        position: {\n            x: ScaleValue | null\n            y: ScaleValue | null\n        }\n    }>\n}\n\ntype Compare = <T>(a: T, b: T) => boolean\n\nexport const getOtherAxis = (axis: ScaleAxis): ScaleAxis => (axis === 'x' ? 'y' : 'x')\n\nexport const compareValues = (a: string | number, b: string | number) => a === b\nexport const compareDateValues = (a: Date, b: Date) => a.getTime() === b.getTime()\n\nexport function computeScale<Input extends ScaleValue>(\n    spec: ScaleSpec,\n    data: ComputedSerieAxis<any>,\n    size: number,\n    axis: ScaleAxis\n) {\n    switch (spec.type) {\n        case 'linear':\n            return createLinearScale(spec, data, size, axis)\n        case 'point':\n            return createPointScale<Input>(spec, data, size)\n        case 'band':\n            return createBandScale<Input>(spec, data, size, axis)\n        case 'time':\n            return createTimeScale(spec, data, size)\n        case 'log':\n            return createLogScale(spec, data, size, axis)\n        case 'symlog':\n            return createSymlogScale(spec, data, size, axis)\n        default:\n            throw new Error('invalid scale spec')\n    }\n}\n\nexport const computeXYScalesForSeries = (\n    _series: XYSeries[],\n    xScaleSpec: ScaleSpec,\n    yScaleSpec: ScaleSpec,\n    width: number,\n    height: number\n) => {\n    const series = _series.map(serie => ({\n        ...serie,\n        data: serie.data.map(d => ({ data: { ...d } })),\n    })) as ComputedXYSeries[]\n\n    const xy = generateSeriesXY(series, xScaleSpec, yScaleSpec)\n    if ('stacked' in xScaleSpec && xScaleSpec.stacked === true) {\n        stackX(xy as StackedXY, series)\n    }\n    if ('stacked' in yScaleSpec && yScaleSpec.stacked === true) {\n        stackY(xy as StackedXY, series)\n    }\n\n    const xScale = computeScale(xScaleSpec, xy.x, width, 'x')\n    const yScale = computeScale(yScaleSpec, xy.y, height, 'y')\n\n    series.forEach(serie => {\n        serie.data.forEach(d => {\n            d.position = {\n                x:\n                    'stacked' in xScale && xScale.stacked === true\n                        ? d.data.xStacked === null\n                            ? null\n                            : xScale(d.data.xStacked)\n                        : d.data.x === null\n                        ? null\n                        : xScale(d.data.x) ?? null,\n                y:\n                    'stacked' in yScale && yScale.stacked === true\n                        ? d.data.yStacked === null\n                            ? null\n                            : yScale(d.data.yStacked)\n                        : d.data.y === null\n                        ? null\n                        : yScale(d.data.y) ?? null,\n            }\n        })\n    })\n\n    return {\n        ...xy,\n        series,\n        xScale,\n        yScale,\n    }\n}\n\nexport const generateSeriesXY = <XValue extends ScaleValue, YValue extends ScaleValue>(\n    series: Series<XValue, YValue>,\n    xScaleSpec: ScaleSpec,\n    yScaleSpec: ScaleSpec\n) => ({\n    x: generateSeriesAxis<'x', XValue>(series, 'x', xScaleSpec),\n    y: generateSeriesAxis<'y', YValue>(series, 'y', yScaleSpec),\n})\n\n/**\n * Normalize data according to scale type, (time => Date, linear => Number)\n * compute sorted unique values and min/max.\n */\nexport const generateSeriesAxis = <Axis extends ScaleAxis, Value extends ScaleValue>(\n    series: SerieAxis<Axis, Value>,\n    axis: Axis,\n    scaleSpec: ScaleSpec,\n    {\n        getValue = d => d.data[axis],\n        setValue = (d, v) => {\n            d.data[axis] = v\n        },\n    }: {\n        getValue?: (d: { data: Record<Axis, Value | null> }) => Value | null\n        setValue?: (d: { data: Record<Axis, Value | null> }, v: Value) => void\n    } = {}\n) => {\n    if (scaleSpec.type === 'linear') {\n        series.forEach(serie => {\n            serie.data.forEach(d => {\n                const value = getValue(d)\n\n                if (value) {\n                    setValue(d, (parseFloat(String(value)) as unknown) as Value)\n                }\n            })\n        })\n    } else if (scaleSpec.type === 'time' && scaleSpec.format !== 'native') {\n        // `native` means we already have Date instances,\n        // otherwise we have to convert the values to Date.\n        const parseTime = createDateNormalizer(scaleSpec)\n\n        series.forEach(serie => {\n            serie.data.forEach(d => {\n                const value = getValue(d)\n\n                if (value) {\n                    setValue(d, (parseTime(value as Date) as unknown) as Value)\n                }\n            })\n        })\n    }\n\n    const values: unknown[] = []\n\n    series.forEach(serie => {\n        serie.data.forEach(d => {\n            values.push(getValue(d))\n        })\n    })\n\n    switch (scaleSpec.type) {\n        case 'linear': {\n            const all = sortBy(uniq(values as number[]), v => v)\n\n            return { all, min: Math.min(...all), max: Math.max(...all) }\n        }\n        case 'time': {\n            const all = uniqBy(values as Date[], v => v.getTime())\n                .slice(0)\n                .sort((a, b) => b.getTime() - a.getTime())\n                .reverse()\n\n            return { all, min: all[0], max: last(all) }\n        }\n        default: {\n            const all = uniq(values)\n\n            return { all, min: all[0], max: last(all) }\n        }\n    }\n}\n\nexport const stackAxis = (axis: ScaleAxis, xy: StackedXY, series: ComputedXYSeries[]) => {\n    const otherAxis = getOtherAxis(axis)\n    const all: number[] = []\n\n    xy[otherAxis].all.forEach(v => {\n        const compare = (isDate(v) ? compareDateValues : compareValues) as Compare\n        const stack: Array<number | null> = []\n\n        series.forEach(serie => {\n            const datum = serie.data.find(d => compare(d.data[otherAxis], v))\n            let value = null\n            let stackValue = null\n\n            if (datum !== undefined) {\n                value = datum.data[axis]\n                if (value !== null) {\n                    const head = last(stack)\n                    if (head === undefined) {\n                        stackValue = value\n                    } else if (head !== null) {\n                        stackValue = head + value\n                    }\n                }\n\n                datum.data[`${axis}Stacked`] = stackValue\n            }\n\n            stack.push(stackValue)\n\n            if (stackValue !== null) {\n                all.push(stackValue)\n            }\n        })\n    })\n\n    xy[axis].minStacked = Math.min(...all)\n    xy[axis].maxStacked = Math.max(...all)\n}\n\nconst stackX = (xy: StackedXY, series: ComputedXYSeries[]) => stackAxis('x', xy, series)\nconst stackY = (xy: StackedXY, series: ComputedXYSeries[]) => stackAxis('y', xy, series)\n","import { scalePoint } from 'd3-scale'\nimport { ComputedSerieAxis, ScalePoint, ScalePointSpec, StringValue } from './types'\n\nexport const createPointScale = <Input extends StringValue>(\n    _spec: ScalePointSpec,\n    data: ComputedSerieAxis<Input>,\n    size: number\n) => {\n    const scale = scalePoint<Input>().range([0, size]).domain(data.all)\n\n    const typedScale = scale as ScalePoint<Input>\n    typedScale.type = 'point'\n\n    return typedScale\n}\n","import { scaleBand } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleBand, ScaleBandSpec, StringValue, ScaleAxis } from './types'\n\nexport const createBandScale = <Input extends StringValue>(\n    { round = true }: ScaleBandSpec,\n    data: ComputedSerieAxis<Input>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    const scale = scaleBand<Input>()\n        .range(axis === 'x' ? [0, size] : [size, 0])\n        .domain(data.all)\n        .round(round)\n\n    const typedScale = scale as ScaleBand<Input>\n    typedScale.type = 'band'\n\n    return typedScale\n}\n","import { scaleLog } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleAxis, ScaleLog, ScaleLogSpec } from './types'\n\nexport const createLogScale = (\n    { base = 10, min = 'auto', max = 'auto' }: ScaleLogSpec,\n    data: ComputedSerieAxis<number>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    const hasZero = data.all.some(v => v === 0)\n    if (hasZero) {\n        throw new Error(`a log scale domain must not include or cross zero`)\n    }\n\n    let sign: number\n    let hasMixedSign = false\n    data.all\n        .filter(v => v != null)\n        .forEach(v => {\n            if (hasMixedSign) return\n            if (sign === undefined) {\n                sign = Math.sign(v)\n            } else if (Math.sign(v) !== sign) {\n                hasMixedSign = true\n            }\n        })\n\n    if (hasMixedSign) {\n        throw new Error(`a log scale domain must be strictly-positive or strictly-negative`)\n    }\n\n    let minValue: number\n    if (min === 'auto') {\n        minValue = data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: number\n    if (max === 'auto') {\n        maxValue = data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleLog<number, number>()\n        .domain([minValue, maxValue])\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .base(base)\n        .nice()\n\n    const typedScale = scale as ScaleLog\n    typedScale.type = 'log'\n\n    return scale\n}\n","import { scaleSymlog } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleAxis, ScaleSymlog, ScaleSymlogSpec } from './types'\n\nexport const createSymlogScale = (\n    { constant = 1, min = 'auto', max = 'auto', reverse = false }: ScaleSymlogSpec,\n    data: ComputedSerieAxis<number>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    let minValue: number\n    if (min === 'auto') {\n        minValue = data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: number\n    if (max === 'auto') {\n        maxValue = data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleSymlog<number, number>()\n        .constant(constant)\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .nice()\n\n    if (reverse === true) scale.domain([maxValue, minValue])\n    else scale.domain([minValue, maxValue])\n\n    const typedScale = scale as ScaleSymlog\n    typedScale.type = 'symlog'\n\n    return typedScale\n}\n","export var durationSecond = 1e3;\nexport var durationMinute = 6e4;\nexport var durationHour = 36e5;\nexport var durationDay = 864e5;\nexport var durationWeek = 6048e5;","import interval from \"./interval.js\";\nvar millisecond = interval(function () {// noop\n}, function (date, step) {\n  date.setTime(+date + step);\n}, function (start, end) {\n  return end - start;\n}); // An optimized implementation for this simple case.\n\nmillisecond.every = function (k) {\n  k = Math.floor(k);\n  if (!isFinite(k) || !(k > 0)) return null;\n  if (!(k > 1)) return millisecond;\n  return interval(function (date) {\n    date.setTime(Math.floor(date / k) * k);\n  }, function (date, step) {\n    date.setTime(+date + step * k);\n  }, function (start, end) {\n    return (end - start) / k;\n  });\n};\n\nexport default millisecond;\nexport var milliseconds = millisecond.range;"],"sourceRoot":""}