{"version":3,"sources":["webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArray.js","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","webpack:///../src/BarAnnotations.tsx","webpack:///../src/BarLegends.tsx","webpack:///../src/compute/common.ts","webpack:///../src/compute/grouped.ts","webpack:///../src/compute/stacked.ts","webpack:///../src/compute/legends.ts","webpack:///../src/props.ts","webpack:///../src/BarTooltip.tsx","webpack:///../src/BarItem.tsx","webpack:///../src/Bar.tsx","webpack:///../src/BarCanvas.tsx","webpack:///../src/ResponsiveBar.tsx","webpack:///../src/ResponsiveBarCanvas.tsx","webpack:///../src/utils.ts","webpack:///../src/compute.ts","webpack:///../src/hooks.ts","webpack:///../src/AnnotationNote.tsx","webpack:///../src/AnnotationLink.tsx","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toArray.js","webpack:///../src/CircleAnnotationOutline.tsx","webpack:///../src/DotAnnotationOutline.tsx","webpack:///../src/RectAnnotationOutline.tsx","webpack:///../src/Annotation.tsx","webpack:///../src/canvas.ts","webpack:///../node_modules/lodash/filter.js","webpack:///../node_modules/lodash/_baseFilter.js"],"names":["_objectWithoutProperties","source","excluded","key","i","target","sourceKeys","Object","keys","length","indexOf","objectWithoutPropertiesLoose","getOwnPropertySymbols","sourceSymbolKeys","prototype","propertyIsEnumerable","call","_defineProperty","obj","value","defineProperty","enumerable","configurable","writable","ownKeys","object","enumerableOnly","symbols","filter","sym","getOwnPropertyDescriptor","push","apply","_objectSpread2","arguments","forEach","getOwnPropertyDescriptors","defineProperties","_arrayLikeToArray","arr","len","arr2","Array","_unsupportedIterableToArray","o","minLen","arrayLikeToArray","n","toString","slice","constructor","name","from","test","_toConsumableArray","isArray","arrayWithoutHoles","iter","Symbol","iterator","iterableToArray","unsupportedIterableToArray","TypeError","nonIterableSpread","_slicedToArray","arrayWithHoles","_arr","_n","_d","_e","undefined","_s","_i","next","done","err","iterableToArrayLimit","nonIterableRest","BarAnnotations","bars","annotations","boundAnnotations","useAnnotations","data","getPosition","bar","x","y","getDimensions","height","width","size","Math","_jsx","BarLegends","legends","toggleSerie","containerWidth","containerHeight","legend","getIndexScale","computeScale","all","min","max","normalizeData","item","acc","filterNullValues","coerceValue","Number","gt","lt","flatten","range","start","repeat","end","clampToZero","generateVerticalGroupedBars","formatValue","getColor","getIndex","getTooltipLabel","innerPadding","xScale","yScale","compare","reverse","cleanedData","index","d","rawValue","indexValue","barWidth","barHeight","yRef","getHeight","barData","id","formattedValue","hidden","color","label","generateHorizontalGroupedBars","xRef","getWidth","generateGroupedBars","layout","minValue","maxValue","padding","valueScale","indexScaleConfig","indexScale","hiddenIds","props","axis","otherAxis","scaleSpec","clampMin","values","k","entry","isFinite","scale","bandwidth","params","flattenDeep","generateVerticalStackedBars","stackedData","stackedDataItem","getY","generateHorizontalStackedBars","getX","generateStackedBars","array","stack","num","getLegendData","direction","groupMode","legendLabel","getLegendLabel","getPropertyAccessor","getLegendDataForIndexes","getLegendDataForKeys","defaultProps","indexBy","type","round","axisBottom","axisLeft","enableGridX","enableGridY","enableLabel","labelSkipWidth","labelSkipHeight","labelTextColor","theme","colorBy","colors","scheme","borderRadius","borderWidth","borderColor","isInteractive","tooltip","enableChip","tooltipLabel","datum","svgDefaultProps","layers","barComponent","style","transform","shouldRenderLabel","labelColor","onClick","onMouseEnter","onMouseLeave","useTheme","useTooltip","showTooltipFromEvent","hideTooltip","handleClick","useCallback","handleTooltip","createElement","handleMouseEnter","handleMouseLeave","rx","ry","fill","strokeWidth","stroke","onMouseMove","textAnchor","dominantBaseline","pointerEvents","defs","animate","motionConfig","role","canvasDefaultProps","pixelRatio","window","InnerBar","partialMargin","margin","axisTop","axisRight","gridXValues","gridYValues","markers","valueFormat","initialHiddenIds","useState","setHiddenIds","state","useMotionConfig","springConfig","useDimensions","outerWidth","outerHeight","innerWidth","innerHeight","useValueFormatter","getBorderColor","useInheritedColor","useOrdinalColorScale","usePropertyAccessor","getLabel","getLabelColor","result","legendData","useMemo","barsWithValue","transition","useTransition","enter","update","config","immediate","commonProps","boundDefs","bindDefs","dataKey","targetKey","layerById","axes","grid","top","right","bottom","left","xValues","yValues","layerContext","layer","Bar","renderWrapper","otherProps","findBarUnderCursor","nodes","node","isCursorInRect","InnerBarCanvas","renderBar","ctx","radius","canvasRef","canvasEl","useRef","options","useComputedAnnotations","useEffect","isNumber","renderGridLinesToCanvas","renderAxesToCanvas","renderLegendToCanvas","renderAnnotationsToCanvas","handleMouseHover","getRelativeCursor","event","ref","canvas","cursor","BarCanvas","forwardRef","ResponsiveBar","ResponsiveBarCanvas","_iterableToArray","isCircleAnnotation","annotationSpec","isDotAnnotation","isRectAnnotation","computeAnnotation","annotation","noteX","noteY","noteWidth","noteTextOffset","computedNoteX","computedNoteY","computedX","computedY","angle","targetY","targetX","absoluteAngleDegrees","radiansToDegrees","getLinkAngle","position","positionFromAngle","degreesToRadians","eighth","textX","noteLineX","points","text","offset","dimensions","bindAnnotations","computed","AnnotationNote","note","animatedProps","useSpring","strokeLinejoin","outlineColor","omit","_arrayWithHoles","_nonIterableRest","AnnotationLink","isOutline","path","firstPoint","animatedPath","useAnimatedPath","CircleAnnotationOutline","cx","cy","r","outline","DotAnnotationOutline","symbol","RectAnnotationOutline","Annotation","useComputedAnnotation","noteType","isValidElement","isSvgNote","drawPoints","arrayFilter","baseFilter","baseIteratee","module","exports","collection","predicate","baseEach"],"mappings":"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","file":"e6566ccda6fa281b2bfc2c90b15fb315ed8cf53b-c6dba25c8690e0e63e3c.js","sourcesContent":["import objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nexport default function _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}","export default function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayLikeToArray from \"@babel/runtime/helpers/esm/arrayLikeToArray\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","import arrayWithoutHoles from \"@babel/runtime/helpers/esm/arrayWithoutHoles\";\nimport iterableToArray from \"@babel/runtime/helpers/esm/iterableToArray\";\nimport unsupportedIterableToArray from \"@babel/runtime/helpers/esm/unsupportedIterableToArray\";\nimport nonIterableSpread from \"@babel/runtime/helpers/esm/nonIterableSpread\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"@babel/runtime/helpers/esm/arrayLikeToArray\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import arrayWithHoles from \"@babel/runtime/helpers/esm/arrayWithHoles\";\nimport iterableToArrayLimit from \"@babel/runtime/helpers/esm/iterableToArrayLimit\";\nimport unsupportedIterableToArray from \"@babel/runtime/helpers/esm/unsupportedIterableToArray\";\nimport nonIterableRest from \"@babel/runtime/helpers/esm/nonIterableRest\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import { Annotation, useAnnotations } from '@nivo/annotations'\nimport { BarAnnotationsProps } from './types'\n\nexport const BarAnnotations = <RawDatum,>({ bars, annotations }: BarAnnotationsProps<RawDatum>) => {\n    const boundAnnotations = useAnnotations({\n        data: bars,\n        annotations,\n        getPosition: bar => ({\n            x: bar.x + bar.width / 2,\n            y: bar.y + bar.height / 2,\n        }),\n        getDimensions: ({ height, width }) => ({\n            width,\n            height,\n            size: Math.max(width, height),\n        }),\n    })\n\n    return (\n        <>\n            {boundAnnotations.map((annotation, i) => (\n                <Annotation key={i} {...annotation} />\n            ))}\n        </>\n    )\n}\n","import { BoxLegendSvg } from '@nivo/legends'\nimport { BarCommonProps, LegendData } from './types'\n\ninterface BarLegendsProps<RawDatum> {\n    width: number\n    height: number\n    legends: BarCommonProps<RawDatum>['legends']\n    data: LegendData[]\n    toggleSerie: (id: string | number) => void\n}\n\nexport const BarLegends = <RawDatum,>({\n    width,\n    height,\n    legends,\n    data,\n    toggleSerie,\n}: BarLegendsProps<RawDatum>) => {\n    return (\n        <>\n            {legends.map((legend, i) => (\n                <BoxLegendSvg\n                    key={i}\n                    {...legend}\n                    containerWidth={width}\n                    containerHeight={height}\n                    data={legend.data ?? data}\n                    toggleSerie={\n                        legend.toggleSerie && legend.dataFrom === 'keys' ? toggleSerie : undefined\n                    }\n                />\n            ))}\n        </>\n    )\n}\n","import { ScaleBandSpec, ScaleBand, computeScale } from '@nivo/scales'\n\n/**\n * Generates indexed scale.\n */\nexport const getIndexScale = <RawDatum>(\n    data: RawDatum[],\n    getIndex: (datum: RawDatum) => string,\n    padding: number,\n    indexScale: ScaleBandSpec,\n    size: number,\n    axis: 'x' | 'y'\n) => {\n    return (computeScale(\n        indexScale,\n        { all: data.map(getIndex), min: 0, max: 0 },\n        size,\n        axis\n    ) as ScaleBand<string>).padding(padding)\n}\n\n/**\n * This method ensures all the provided keys exist in the entire series.\n */\nexport const normalizeData = <RawDatum>(data: RawDatum[], keys: string[]) =>\n    data.map(\n        item =>\n            ({\n                ...keys.reduce<Record<string, unknown>>((acc, key) => {\n                    acc[key] = null\n                    return acc\n                }, {}),\n                ...item,\n            } as RawDatum)\n    )\n\nexport const filterNullValues = <RawDatum extends Record<string, unknown>>(data: RawDatum) =>\n    Object.keys(data).reduce<Record<string, unknown>>((acc, key) => {\n        if (data[key]) {\n            acc[key] = data[key]\n        }\n        return acc\n    }, {}) as Exclude<RawDatum, null | undefined | false | '' | 0>\n\nexport const coerceValue = <T>(value: T) => [value, Number(value)] as const\n","import { BarDatum, BarSvgProps, ComputedBarDatum, ComputedDatum } from '../types'\nimport { OrdinalColorScale } from '@nivo/colors'\nimport { Scale, ScaleBand } from '@nivo/scales'\nimport { coerceValue, filterNullValues, getIndexScale, normalizeData } from './common'\nimport { computeScale } from '@nivo/scales'\n\ntype Params<RawDatum, XScaleInput, YScaleInput> = {\n    data: RawDatum[]\n    formatValue: (value: number) => string\n    getColor: OrdinalColorScale<ComputedDatum<RawDatum>>\n    getIndex: (datum: RawDatum) => string\n    getTooltipLabel: (datum: ComputedDatum<RawDatum>) => string\n    innerPadding: number\n    keys: string[]\n    xScale: XScaleInput extends string ? ScaleBand<XScaleInput> : Scale<XScaleInput, number>\n    yScale: YScaleInput extends string ? ScaleBand<YScaleInput> : Scale<YScaleInput, number>\n}\n\nconst gt = (value: number, other: number) => value > other\nconst lt = (value: number, other: number) => value < other\n\nconst flatten = <T>(array: T[][]) => ([] as T[]).concat(...array)\nconst range = (start: number, end: number) =>\n    Array.from(' '.repeat(end - start), (_, index) => start + index)\n\nconst clampToZero = (value: number) => (gt(value, 0) ? 0 : value)\nconst zeroIfNotFinite = (value: number) => (isFinite(value) ? value : 0)\n\n/**\n * Generates x/y scales & bars for vertical grouped bar chart.\n */\nconst generateVerticalGroupedBars = <RawDatum extends Record<string, unknown>>(\n    {\n        data,\n        formatValue,\n        getColor,\n        getIndex,\n        getTooltipLabel,\n        innerPadding = 0,\n        keys,\n        xScale,\n        yScale,\n    }: Params<RawDatum, string, number>,\n    barWidth: number,\n    reverse: boolean,\n    yRef: number\n) => {\n    const compare = reverse ? lt : gt\n    const getY = (d: number) => (compare(d, 0) ? yScale(d) ?? 0 : yRef)\n    const getHeight = (d: number, y: number) => (compare(d, 0) ? yRef - y : (yScale(d) ?? 0) - yRef)\n    const cleanedData = data.map(filterNullValues)\n\n    const bars = flatten(\n        keys.map((key, i) =>\n            range(0, xScale.domain().length).map(index => {\n                const [rawValue, value] = coerceValue(data[index][key])\n                const indexValue = getIndex(data[index])\n                const x = (xScale(indexValue) ?? 0) + barWidth * i + innerPadding * i\n                const y = getY(value)\n                const barHeight = getHeight(value, y)\n                const barData = {\n                    id: key,\n                    value: rawValue === null ? rawValue : value,\n                    formattedValue: formatValue(value),\n                    hidden: false,\n                    index,\n                    indexValue,\n                    data: cleanedData[index],\n                }\n\n                return {\n                    key: `${key}.${barData.indexValue}`,\n                    data: barData,\n                    x,\n                    y,\n                    width: barWidth,\n                    height: barHeight,\n                    color: getColor(barData),\n                    label: getTooltipLabel(barData),\n                }\n            })\n        )\n    )\n\n    return bars\n}\n\n/**\n * Generates x/y scales & bars for horizontal grouped bar chart.\n */\nconst generateHorizontalGroupedBars = <RawDatum extends Record<string, unknown>>(\n    {\n        data,\n        formatValue,\n        getIndex,\n        getColor,\n        getTooltipLabel,\n        keys,\n        innerPadding = 0,\n        xScale,\n        yScale,\n    }: Params<RawDatum, number, string>,\n    barHeight: number,\n    reverse: boolean,\n    xRef: number\n) => {\n    const compare = reverse ? lt : gt\n    const getX = (d: number) => (compare(d, 0) ? xRef : xScale(d) ?? 0)\n    const getWidth = (d: number, x: number) => (compare(d, 0) ? (xScale(d) ?? 0) - xRef : xRef - x)\n    const cleanedData = data.map(filterNullValues)\n\n    const bars = flatten(\n        keys.map((key, i) =>\n            range(0, yScale.domain().length).map(index => {\n                const [rawValue, value] = coerceValue(data[index][key])\n                const indexValue = getIndex(data[index])\n                const x = getX(value)\n                const y = (yScale(indexValue) ?? 0) + barHeight * i + innerPadding * i\n                const barWidth = getWidth(value, x)\n                const barData = {\n                    id: key,\n                    value: rawValue === null ? rawValue : value,\n                    formattedValue: formatValue(value),\n                    hidden: false,\n                    index,\n                    indexValue,\n                    data: cleanedData[index],\n                }\n\n                return {\n                    key: `${key}.${barData.indexValue}`,\n                    data: barData,\n                    x,\n                    y,\n                    width: barWidth,\n                    height: barHeight,\n                    color: getColor(barData),\n                    label: getTooltipLabel(barData),\n                }\n            })\n        )\n    )\n\n    return bars\n}\n\n/**\n * Generates x/y scales & bars for grouped bar chart.\n */\nexport const generateGroupedBars = <RawDatum extends BarDatum>({\n    layout,\n    minValue,\n    maxValue,\n    reverse,\n    width,\n    height,\n    padding = 0,\n    innerPadding = 0,\n    valueScale,\n    indexScale: indexScaleConfig,\n    hiddenIds = [],\n    ...props\n}: Pick<\n    Required<BarSvgProps<RawDatum>>,\n    | 'data'\n    | 'height'\n    | 'indexScale'\n    | 'innerPadding'\n    | 'keys'\n    | 'layout'\n    | 'maxValue'\n    | 'minValue'\n    | 'padding'\n    | 'reverse'\n    | 'valueScale'\n    | 'width'\n> & {\n    formatValue: (value: number) => string\n    getColor: OrdinalColorScale<ComputedDatum<RawDatum>>\n    getIndex: (datum: RawDatum) => string\n    getTooltipLabel: (datum: ComputedDatum<RawDatum>) => string\n    hiddenIds?: string[]\n}) => {\n    const keys = props.keys.filter(key => !hiddenIds.includes(key))\n    const data = normalizeData(props.data, keys)\n    const [axis, otherAxis, size] =\n        layout === 'vertical' ? (['y', 'x', width] as const) : (['x', 'y', height] as const)\n    const indexScale = getIndexScale(\n        data,\n        props.getIndex,\n        padding,\n        indexScaleConfig,\n        size,\n        otherAxis\n    )\n\n    const scaleSpec = {\n        max: maxValue,\n        min: minValue,\n        reverse,\n        ...valueScale,\n    }\n\n    const clampMin = scaleSpec.min === 'auto' ? clampToZero : (value: number) => value\n\n    const values = data\n        .reduce<number[]>((acc, entry) => [...acc, ...keys.map(k => entry[k] as number)], [])\n        .filter(Boolean)\n    const min = clampMin(Math.min(...values))\n    const max = zeroIfNotFinite(Math.max(...values))\n\n    const scale = computeScale(\n        scaleSpec as any,\n        { all: values, min, max },\n        axis === 'x' ? width : height,\n        axis\n    )\n\n    const [xScale, yScale] = layout === 'vertical' ? [indexScale, scale] : [scale, indexScale]\n\n    const bandwidth = (indexScale.bandwidth() - innerPadding * (keys.length - 1)) / keys.length\n    const params = [\n        { ...props, data, keys, innerPadding, xScale, yScale } as Params<RawDatum, any, any>,\n        bandwidth,\n        scaleSpec.reverse,\n        scale(0) ?? 0,\n    ] as const\n\n    const bars: ComputedBarDatum<RawDatum>[] =\n        bandwidth > 0\n            ? layout === 'vertical'\n                ? generateVerticalGroupedBars(...params)\n                : generateHorizontalGroupedBars(...params)\n            : []\n\n    return { xScale, yScale, bars }\n}\n","import { BarDatum, BarSvgProps, ComputedBarDatum, ComputedDatum } from '../types'\nimport { OrdinalColorScale } from '@nivo/colors'\nimport { Scale, ScaleBand, computeScale } from '@nivo/scales'\nimport { Series, SeriesPoint, stack, stackOffsetDiverging } from 'd3-shape'\nimport { coerceValue, filterNullValues, getIndexScale, normalizeData } from './common'\n\ntype StackDatum<RawDatum> = SeriesPoint<RawDatum>\n\ntype Params<RawDatum, XScaleInput, YScaleInput> = {\n    formatValue: (value: number) => string\n    getColor: OrdinalColorScale<ComputedDatum<RawDatum>>\n    getIndex: (datum: RawDatum) => string\n    getTooltipLabel: (datum: ComputedDatum<RawDatum>) => string\n    innerPadding: number\n    stackedData: Series<RawDatum, string>[]\n    xScale: XScaleInput extends string ? ScaleBand<XScaleInput> : Scale<XScaleInput, number>\n    yScale: YScaleInput extends string ? ScaleBand<YScaleInput> : Scale<YScaleInput, number>\n}\n\nconst flattenDeep = <T>(arr: T[]): T =>\n    arr.some(Array.isArray) ? flattenDeep(([] as T[]).concat(...arr)) : ((arr as unknown) as T)\n\nconst filterZerosIfLog = (array: number[], type: string) =>\n    type === 'log' ? array.filter(num => num !== 0) : array\n\n/**\n * Generates x/y scales & bars for vertical stacked bar chart.\n */\nconst generateVerticalStackedBars = <RawDatum extends Record<string, unknown>>(\n    {\n        formatValue,\n        getColor,\n        getIndex,\n        getTooltipLabel,\n        innerPadding,\n        stackedData,\n        xScale,\n        yScale,\n    }: Params<RawDatum, string, number>,\n    barWidth: number,\n    reverse: boolean\n) => {\n    const getY = (d: StackDatum<RawDatum>) => yScale(d[reverse ? 0 : 1])\n    const getHeight = (d: StackDatum<RawDatum>, y: number) => (yScale(d[reverse ? 1 : 0]) ?? 0) - y\n\n    const bars = flattenDeep(\n        stackedData.map(stackedDataItem =>\n            xScale.domain().map((index, i) => {\n                const d = stackedDataItem[i]\n                const x = xScale(getIndex(d.data)) ?? 0\n                const y = (getY(d) ?? 0) + innerPadding * 0.5\n                const barHeight = getHeight(d, y) - innerPadding\n                const [rawValue, value] = coerceValue(d.data[stackedDataItem.key])\n\n                const barData = {\n                    id: stackedDataItem.key,\n                    value: rawValue === null ? rawValue : value,\n                    formattedValue: formatValue(value),\n                    hidden: false,\n                    index: i,\n                    indexValue: index,\n                    data: filterNullValues(d.data),\n                }\n\n                return {\n                    key: `${stackedDataItem.key}.${index}`,\n                    data: barData,\n                    x,\n                    y,\n                    width: barWidth,\n                    height: barHeight,\n                    color: getColor(barData),\n                    label: getTooltipLabel(barData),\n                }\n            })\n        )\n    )\n\n    return bars\n}\n\n/**\n * Generates x/y scales & bars for horizontal stacked bar chart.\n */\nconst generateHorizontalStackedBars = <RawDatum extends Record<string, unknown>>(\n    {\n        formatValue,\n        getColor,\n        getIndex,\n        getTooltipLabel,\n        innerPadding,\n        stackedData,\n        xScale,\n        yScale,\n    }: Params<RawDatum, number, string>,\n    barHeight: number,\n    reverse: boolean\n) => {\n    const getX = (d: StackDatum<RawDatum>) => xScale(d[reverse ? 1 : 0])\n    const getWidth = (d: StackDatum<RawDatum>, x: number) => (xScale(d[reverse ? 0 : 1]) ?? 0) - x\n\n    const bars = flattenDeep(\n        stackedData.map(stackedDataItem =>\n            yScale.domain().map((index, i) => {\n                const d = stackedDataItem[i]\n                const y = yScale(getIndex(d.data)) ?? 0\n                const x = (getX(d) ?? 0) + innerPadding * 0.5\n                const barWidth = getWidth(d, x) - innerPadding\n                const [rawValue, value] = coerceValue(d.data[stackedDataItem.key])\n\n                const barData = {\n                    id: stackedDataItem.key,\n                    value: rawValue === null ? rawValue : value,\n                    formattedValue: formatValue(value),\n                    hidden: false,\n                    index: i,\n                    indexValue: index,\n                    data: filterNullValues(d.data),\n                }\n\n                return {\n                    key: `${stackedDataItem.key}.${index}`,\n                    data: barData,\n                    x,\n                    y,\n                    width: barWidth,\n                    height: barHeight,\n                    color: getColor(barData),\n                    label: getTooltipLabel(barData),\n                }\n            })\n        )\n    )\n\n    return bars\n}\n\n/**\n * Generates x/y scales & bars for stacked bar chart.\n */\nexport const generateStackedBars = <RawDatum extends BarDatum>({\n    data,\n    layout,\n    minValue,\n    maxValue,\n    reverse,\n    width,\n    height,\n    padding = 0,\n    valueScale,\n    indexScale: indexScaleConfig,\n    hiddenIds = [],\n    ...props\n}: Pick<\n    Required<BarSvgProps<RawDatum>>,\n    | 'data'\n    | 'height'\n    | 'indexScale'\n    | 'innerPadding'\n    | 'keys'\n    | 'layout'\n    | 'maxValue'\n    | 'minValue'\n    | 'padding'\n    | 'reverse'\n    | 'valueScale'\n    | 'width'\n> & {\n    formatValue: (value: number) => string\n    getColor: OrdinalColorScale<ComputedDatum<RawDatum>>\n    getIndex: (datum: RawDatum) => string\n    getTooltipLabel: (datum: ComputedDatum<RawDatum>) => string\n    hiddenIds?: string[]\n}) => {\n    const keys = props.keys.filter(key => !hiddenIds.includes(key))\n    const stackedData = stack<RawDatum, string>().keys(keys).offset(stackOffsetDiverging)(\n        normalizeData(data, keys)\n    )\n\n    const [axis, otherAxis, size] =\n        layout === 'vertical' ? (['y', 'x', width] as const) : (['x', 'y', height] as const)\n    const indexScale = getIndexScale(\n        data,\n        props.getIndex,\n        padding,\n        indexScaleConfig,\n        size,\n        otherAxis\n    )\n\n    const scaleSpec = {\n        max: maxValue,\n        min: minValue,\n        reverse,\n        ...valueScale,\n    }\n\n    const values = filterZerosIfLog(\n        flattenDeep((stackedData as unknown) as number[][]),\n        valueScale.type\n    )\n    const min = Math.min(...values)\n    const max = Math.max(...values)\n\n    const scale = computeScale(\n        scaleSpec as any,\n        { all: values, min, max },\n        axis === 'x' ? width : height,\n        axis\n    )\n\n    const [xScale, yScale] = layout === 'vertical' ? [indexScale, scale] : [scale, indexScale]\n\n    const innerPadding = props.innerPadding > 0 ? props.innerPadding : 0\n    const bandwidth = indexScale.bandwidth()\n    const params = [\n        { ...props, innerPadding, stackedData, xScale, yScale } as Params<RawDatum, any, any>,\n        bandwidth,\n        scaleSpec.reverse,\n    ] as const\n\n    const bars: ComputedBarDatum<RawDatum>[] =\n        bandwidth > 0\n            ? layout === 'vertical'\n                ? generateVerticalStackedBars(...params)\n                : generateHorizontalStackedBars(...params)\n            : []\n\n    return { xScale, yScale, bars }\n}\n","import { BarDatum, BarLegendProps, BarSvgProps, BarsWithHidden, LegendLabelDatum } from '../types'\nimport { getPropertyAccessor } from '@nivo/core'\nimport { uniqBy } from 'lodash'\n\nexport const getLegendDataForKeys = <RawDatum extends BarDatum>(\n    bars: BarsWithHidden<RawDatum>,\n    layout: NonNullable<BarSvgProps<RawDatum>['layout']>,\n    direction: BarLegendProps['direction'],\n    groupMode: NonNullable<BarSvgProps<RawDatum>['groupMode']>,\n    reverse: boolean,\n    getLegendLabel: (datum: LegendLabelDatum<RawDatum>) => string\n) => {\n    const data = uniqBy(\n        bars.map(bar => ({\n            id: bar.data.id,\n            label: getLegendLabel(bar.data),\n            hidden: bar.data.hidden,\n            color: bar.color ?? '#000',\n        })),\n        ({ id }) => id\n    )\n\n    if (\n        (layout === 'vertical' &&\n            groupMode === 'stacked' &&\n            direction === 'column' &&\n            reverse !== true) ||\n        (layout === 'horizontal' && groupMode === 'stacked' && reverse === true)\n    ) {\n        data.reverse()\n    }\n\n    return data\n}\n\nexport const getLegendDataForIndexes = <RawDatum extends BarDatum>(\n    bars: BarsWithHidden<RawDatum>,\n    layout: NonNullable<BarSvgProps<RawDatum>['layout']>,\n    getLegendLabel: (datum: LegendLabelDatum<RawDatum>) => string\n) => {\n    const data = uniqBy(\n        bars.map(bar => ({\n            id: bar.data.indexValue ?? '',\n            label: getLegendLabel(bar.data),\n            hidden: bar.data.hidden,\n            color: bar.color ?? '#000',\n        })),\n        ({ id }) => id\n    )\n\n    if (layout === 'horizontal') {\n        data.reverse()\n    }\n\n    return data\n}\n\nexport const getLegendData = <RawDatum extends BarDatum>({\n    bars,\n    direction,\n    from,\n    groupMode,\n    layout,\n    legendLabel,\n    reverse,\n}: Pick<Required<BarSvgProps<RawDatum>>, 'layout' | 'groupMode' | 'reverse'> & {\n    bars: BarsWithHidden<RawDatum>\n    direction: BarLegendProps['direction']\n    from: BarLegendProps['dataFrom']\n    legendLabel: BarSvgProps<RawDatum>['legendLabel']\n}) => {\n    const getLegendLabel = getPropertyAccessor(\n        legendLabel ?? (from === 'indexes' ? 'indexValue' : 'id')\n    )\n\n    if (from === 'indexes') {\n        return getLegendDataForIndexes(bars, layout, getLegendLabel)\n    }\n\n    return getLegendDataForKeys(bars, layout, direction, groupMode, reverse, getLegendLabel)\n}\n","export const defaultProps = {\n    dotSize: 4,\n    noteWidth: 120,\n    noteTextOffset: 8,\n    animate: true,\n    motionStiffness: 90,\n    motionDamping: 13,\n}\n","import { BarTooltipProps } from './types'\nimport { BasicTooltip } from '@nivo/tooltip'\n\nexport const BarTooltip = <RawDatum,>({ color, label, ...data }: BarTooltipProps<RawDatum>) => {\n    return <BasicTooltip id={label} value={data.formattedValue} enableChip={true} color={color} />\n}\n","import { BarDatum, BarItemProps } from './types'\nimport { animated } from '@react-spring/web'\nimport { createElement, useCallback } from 'react'\nimport { useTheme } from '@nivo/core'\nimport { useTooltip } from '@nivo/tooltip'\n\nexport const BarItem = <RawDatum extends BarDatum>({\n    bar: { data, ...bar },\n\n    style: { height, transform, width, x, y, ...style },\n\n    borderRadius,\n    borderWidth,\n    borderColor,\n\n    label,\n    shouldRenderLabel,\n    labelColor,\n\n    isInteractive,\n    onClick,\n    onMouseEnter,\n    onMouseLeave,\n\n    tooltip,\n}: BarItemProps<RawDatum>) => {\n    const theme = useTheme()\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n\n    const handleClick = useCallback(\n        (event: React.MouseEvent<SVGRectElement>) => {\n            onClick?.({ color: bar.color, ...data }, event)\n        },\n        [bar, data, onClick]\n    )\n    const handleTooltip = useCallback(\n        (event: React.MouseEvent<SVGRectElement>) =>\n            showTooltipFromEvent(createElement(tooltip, { ...bar, ...data }), event),\n        [bar, data, showTooltipFromEvent, tooltip]\n    )\n    const handleMouseEnter = useCallback(\n        (event: React.MouseEvent<SVGRectElement>) => {\n            onMouseEnter?.(data, event)\n            showTooltipFromEvent(createElement(tooltip, { ...bar, ...data }), event)\n        },\n        [bar, data, onMouseEnter, showTooltipFromEvent, tooltip]\n    )\n    const handleMouseLeave = useCallback(\n        (event: React.MouseEvent<SVGRectElement>) => {\n            onMouseLeave?.(data, event)\n            hideTooltip()\n        },\n        [data, hideTooltip, onMouseLeave]\n    )\n\n    return (\n        <animated.g transform={transform}>\n            <animated.rect\n                width={width}\n                height={height}\n                rx={borderRadius}\n                ry={borderRadius}\n                fill={data.fill ?? style.color}\n                strokeWidth={borderWidth}\n                stroke={borderColor}\n                onMouseEnter={isInteractive ? handleMouseEnter : undefined}\n                onMouseMove={isInteractive ? handleTooltip : undefined}\n                onMouseLeave={isInteractive ? handleMouseLeave : undefined}\n                onClick={isInteractive ? handleClick : undefined}\n            />\n            {shouldRenderLabel && (\n                <animated.text\n                    x={x}\n                    y={y}\n                    textAnchor=\"middle\"\n                    dominantBaseline=\"central\"\n                    style={{\n                        ...theme.labels.text,\n                        pointerEvents: 'none',\n                        fill: labelColor,\n                    }}\n                >\n                    {label}\n                </animated.text>\n            )}\n        </animated.g>\n    )\n}\n","import { Axes, Grid } from '@nivo/axes'\nimport { BarAnnotations } from './BarAnnotations'\nimport {\n    BarDatum,\n    BarLayer,\n    BarLayerId,\n    BarSvgProps,\n    ComputedBarDatum,\n    ComputedBarDatumWithValue,\n    LegendData,\n} from './types'\nimport { BarLegends } from './BarLegends'\nimport {\n    // @ts-ignore\n    CartesianMarkers,\n    Container,\n    SvgWrapper,\n    // @ts-ignore\n    bindDefs,\n    useDimensions,\n    useMotionConfig,\n    usePropertyAccessor,\n    useTheme,\n    useValueFormatter,\n} from '@nivo/core'\nimport { Fragment, ReactNode, createElement, useCallback, useMemo, useState } from 'react'\nimport { generateGroupedBars, generateStackedBars, getLegendData } from './compute'\nimport { svgDefaultProps } from './props'\nimport { useInheritedColor, useOrdinalColorScale } from '@nivo/colors'\nimport { useTransition } from '@react-spring/web'\n\ntype InnerBarProps<RawDatum extends BarDatum> = Omit<\n    BarSvgProps<RawDatum>,\n    'animate' | 'motionConfig' | 'renderWrapper' | 'theme'\n>\n\nconst InnerBar = <RawDatum extends BarDatum>({\n    data,\n    indexBy = svgDefaultProps.indexBy,\n    keys = svgDefaultProps.keys,\n\n    margin: partialMargin,\n    width,\n    height,\n\n    groupMode = svgDefaultProps.groupMode,\n    layout = svgDefaultProps.layout,\n    reverse = svgDefaultProps.reverse,\n    minValue = svgDefaultProps.minValue,\n    maxValue = svgDefaultProps.maxValue,\n\n    valueScale = svgDefaultProps.valueScale,\n    indexScale = svgDefaultProps.indexScale,\n\n    padding = svgDefaultProps.padding,\n    innerPadding = svgDefaultProps.innerPadding,\n\n    axisTop,\n    axisRight,\n    axisBottom = svgDefaultProps.axisBottom,\n    axisLeft = svgDefaultProps.axisLeft,\n    enableGridX = svgDefaultProps.enableGridX,\n    enableGridY = svgDefaultProps.enableGridY,\n    gridXValues,\n    gridYValues,\n\n    layers = svgDefaultProps.layers as BarLayer<RawDatum>[],\n    barComponent = svgDefaultProps.barComponent,\n\n    enableLabel = svgDefaultProps.enableLabel,\n    label = svgDefaultProps.label,\n    labelSkipWidth = svgDefaultProps.labelSkipWidth,\n    labelSkipHeight = svgDefaultProps.labelSkipHeight,\n    labelTextColor = svgDefaultProps.labelTextColor,\n\n    markers,\n\n    colorBy = svgDefaultProps.colorBy,\n    colors = svgDefaultProps.colors,\n    defs = svgDefaultProps.defs,\n    fill = svgDefaultProps.fill,\n    borderRadius = svgDefaultProps.borderRadius,\n    borderWidth = svgDefaultProps.borderWidth,\n    borderColor = svgDefaultProps.borderColor,\n\n    annotations = svgDefaultProps.annotations,\n\n    legendLabel,\n    tooltipLabel = svgDefaultProps.tooltipLabel,\n\n    valueFormat,\n\n    isInteractive = svgDefaultProps.isInteractive,\n    tooltip = svgDefaultProps.tooltip,\n    onClick,\n    onMouseEnter,\n    onMouseLeave,\n\n    legends = svgDefaultProps.legends,\n\n    role = svgDefaultProps.role,\n\n    initialHiddenIds,\n}: InnerBarProps<RawDatum>) => {\n    const [hiddenIds, setHiddenIds] = useState(initialHiddenIds ?? [])\n    const toggleSerie = useCallback(id => {\n        setHiddenIds(state =>\n            state.indexOf(id) > -1 ? state.filter(item => item !== id) : [...state, id]\n        )\n    }, [])\n\n    const theme = useTheme()\n    const { animate, config: springConfig } = useMotionConfig()\n    const { outerWidth, outerHeight, margin, innerWidth, innerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n\n    const formatValue = useValueFormatter(valueFormat)\n    const getBorderColor = useInheritedColor<ComputedBarDatum<RawDatum>>(borderColor, theme)\n    const getColor = useOrdinalColorScale(colors, colorBy)\n    const getIndex = usePropertyAccessor(indexBy)\n    const getLabel = usePropertyAccessor(label)\n    const getLabelColor = useInheritedColor<ComputedBarDatum<RawDatum>>(labelTextColor, theme)\n    const getTooltipLabel = usePropertyAccessor(tooltipLabel)\n\n    const generateBars = groupMode === 'grouped' ? generateGroupedBars : generateStackedBars\n    const result = generateBars({\n        layout,\n        reverse,\n        data,\n        getIndex,\n        keys,\n        minValue,\n        maxValue,\n        width: innerWidth,\n        height: innerHeight,\n        getColor,\n        padding,\n        innerPadding,\n        valueScale,\n        indexScale,\n        hiddenIds,\n        formatValue,\n        getTooltipLabel,\n    })\n\n    const legendData = useMemo(\n        () =>\n            keys.map(key => {\n                const bar = result.bars.find(bar => bar.data.id === key)\n\n                return { ...bar, data: { id: key, ...bar?.data, hidden: hiddenIds.includes(key) } }\n            }),\n        [hiddenIds, keys, result.bars]\n    )\n\n    const barsWithValue = useMemo(\n        () =>\n            result.bars.filter(\n                (bar): bar is ComputedBarDatumWithValue<RawDatum> => bar.data.value !== null\n            ),\n        [result.bars]\n    )\n\n    const transition = useTransition(barsWithValue, {\n        keys: bar => bar.key,\n        enter: bar => ({\n            x: bar.width / 2,\n            y: bar.height / 2,\n            width: bar.width,\n            height: bar.height,\n            color: bar.color,\n            transform: `translate(${bar.x}, ${bar.y})`,\n        }),\n        update: bar => ({\n            x: bar.width / 2,\n            y: bar.height / 2,\n            width: bar.width,\n            height: bar.height,\n            color: bar.color,\n            transform: `translate(${bar.x}, ${bar.y})`,\n        }),\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    const shouldRenderLabel = useCallback(\n        ({ width, height }: { height: number; width: number }) => {\n            if (!enableLabel) return false\n            if (labelSkipWidth > 0 && width < labelSkipWidth) return false\n            if (labelSkipHeight > 0 && height < labelSkipHeight) return false\n            return true\n        },\n        [enableLabel, labelSkipHeight, labelSkipWidth]\n    )\n\n    const commonProps = useMemo(\n        () => ({\n            borderRadius,\n            borderWidth,\n            enableLabel,\n            isInteractive,\n            labelSkipWidth,\n            labelSkipHeight,\n            onClick,\n            onMouseEnter,\n            onMouseLeave,\n            getTooltipLabel,\n            tooltip,\n        }),\n        [\n            borderRadius,\n            borderWidth,\n            enableLabel,\n            getTooltipLabel,\n            isInteractive,\n            labelSkipHeight,\n            labelSkipWidth,\n            onClick,\n            onMouseEnter,\n            onMouseLeave,\n            tooltip,\n        ]\n    )\n\n    const boundDefs = bindDefs(defs, result.bars, fill, {\n        dataKey: 'data',\n        targetKey: 'data.fill',\n    })\n\n    const layerById: Record<BarLayerId, ReactNode> = {\n        annotations: null,\n        axes: null,\n        bars: null,\n        grid: null,\n        legends: null,\n        markers: null,\n    }\n\n    if (layers.includes('annotations')) {\n        layerById.annotations = (\n            <BarAnnotations key=\"annotations\" bars={result.bars} annotations={annotations} />\n        )\n    }\n\n    if (layers.includes('axes')) {\n        layerById.axes = (\n            <Axes\n                key=\"axes\"\n                xScale={result.xScale as any}\n                yScale={result.yScale as any}\n                width={innerWidth}\n                height={innerHeight}\n                top={axisTop}\n                right={axisRight}\n                bottom={axisBottom}\n                left={axisLeft}\n            />\n        )\n    }\n\n    if (layers.includes('bars')) {\n        layerById.bars = (\n            <Fragment key=\"bars\">\n                {transition((style, bar) =>\n                    createElement(barComponent, {\n                        ...commonProps,\n                        bar,\n                        style,\n                        shouldRenderLabel: shouldRenderLabel(bar),\n                        label: getLabel(bar.data),\n                        labelColor: getLabelColor(bar),\n                        borderColor: getBorderColor(bar),\n                    })\n                )}\n            </Fragment>\n        )\n    }\n\n    if (layers.includes('grid')) {\n        layerById.grid = (\n            <Grid\n                key=\"grid\"\n                width={innerWidth}\n                height={innerHeight}\n                xScale={enableGridX ? (result.xScale as any) : null}\n                yScale={enableGridY ? (result.yScale as any) : null}\n                xValues={gridXValues}\n                yValues={gridYValues}\n            />\n        )\n    }\n\n    if (layers.includes('legends')) {\n        const data = ([] as LegendData[]).concat(\n            ...legends.map(legend =>\n                getLegendData({\n                    bars: legend.dataFrom === 'keys' ? legendData : result.bars,\n                    direction: legend.direction,\n                    from: legend.dataFrom,\n                    groupMode,\n                    layout,\n                    legendLabel,\n                    reverse,\n                })\n            )\n        )\n\n        layerById.legends = (\n            <BarLegends\n                key=\"legends\"\n                width={innerWidth}\n                height={innerHeight}\n                data={data}\n                legends={legends}\n                toggleSerie={toggleSerie}\n            />\n        )\n    }\n\n    if (layers.includes('markers')) {\n        layerById.markers = (\n            <CartesianMarkers\n                key=\"markers\"\n                markers={markers}\n                width={innerWidth}\n                height={innerHeight}\n                xScale={result.xScale}\n                yScale={result.yScale}\n                theme={theme}\n            />\n        )\n    }\n\n    // We use `any` here until we can figure out the best way to type xScale/yScale\n    const layerContext: any = useMemo(\n        () => ({\n            ...commonProps,\n            margin,\n            innerWidth,\n            innerHeight,\n            width,\n            height,\n            ...result,\n        }),\n        [commonProps, height, innerHeight, innerWidth, margin, result, width]\n    )\n\n    return (\n        <SvgWrapper\n            width={outerWidth}\n            height={outerHeight}\n            margin={margin}\n            defs={boundDefs}\n            role={role}\n        >\n            {layers.map((layer, i) => {\n                if (typeof layer === 'function') {\n                    return <Fragment key={i}>{createElement(layer, layerContext)}</Fragment>\n                }\n\n                return layerById?.[layer] ?? null\n            })}\n        </SvgWrapper>\n    )\n}\n\nexport const Bar = <RawDatum extends BarDatum>({\n    isInteractive = svgDefaultProps.isInteractive,\n    animate = svgDefaultProps.animate,\n    motionConfig = svgDefaultProps.motionConfig,\n    theme,\n    renderWrapper,\n    ...otherProps\n}: BarSvgProps<RawDatum>) => (\n    <Container\n        {...{\n            animate,\n            isInteractive,\n            motionConfig,\n            renderWrapper,\n            theme,\n        }}\n    >\n        <InnerBar<RawDatum> isInteractive={isInteractive} {...otherProps} />\n    </Container>\n)\n","import {\n    BarCanvasLayer,\n    BarCanvasProps,\n    BarDatum,\n    ComputedBarDatum,\n    ComputedBarDatumWithValue,\n} from './types'\nimport {\n    Container,\n    Margin,\n    getRelativeCursor,\n    isCursorInRect,\n    useDimensions,\n    usePropertyAccessor,\n    useTheme,\n    useValueFormatter,\n} from '@nivo/core'\nimport {\n    ForwardedRef,\n    createElement,\n    forwardRef,\n    useCallback,\n    useEffect,\n    useMemo,\n    useRef,\n} from 'react'\nimport { canvasDefaultProps } from './props'\nimport { generateGroupedBars, generateStackedBars, getLegendData } from './compute'\nimport {\n    renderAnnotationsToCanvas,\n    useAnnotations,\n    useComputedAnnotations,\n} from '@nivo/annotations'\nimport { renderAxesToCanvas, renderGridLinesToCanvas } from '@nivo/axes'\nimport { renderLegendToCanvas } from '@nivo/legends'\nimport { useInheritedColor, useOrdinalColorScale } from '@nivo/colors'\nimport { useTooltip } from '@nivo/tooltip'\n\ndeclare module 'react' {\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    function forwardRef<T, P = {}>(\n        render: (props: P, ref: React.Ref<T>) => React.ReactElement | null\n    ): (props: P & React.RefAttributes<T>) => React.ReactElement | null\n}\n\ntype InnerBarCanvasProps<RawDatum extends BarDatum> = Omit<\n    BarCanvasProps<RawDatum>,\n    'renderWrapper' | 'theme'\n> & {\n    canvasRef: ForwardedRef<HTMLCanvasElement>\n}\n\nconst findBarUnderCursor = <RawDatum,>(\n    nodes: ComputedBarDatum<RawDatum>[],\n    margin: Margin,\n    x: number,\n    y: number\n) =>\n    nodes.find(node =>\n        isCursorInRect(node.x + margin.left, node.y + margin.top, node.width, node.height, x, y)\n    )\n\nconst isNumber = (value: unknown): value is number => typeof value === 'number'\n\nconst InnerBarCanvas = <RawDatum extends BarDatum>({\n    data,\n    indexBy = canvasDefaultProps.indexBy,\n    keys = canvasDefaultProps.keys,\n\n    margin: partialMargin,\n    width,\n    height,\n\n    groupMode = canvasDefaultProps.groupMode,\n    layout = canvasDefaultProps.layout,\n    reverse = canvasDefaultProps.reverse,\n    minValue = canvasDefaultProps.minValue,\n    maxValue = canvasDefaultProps.maxValue,\n\n    valueScale = canvasDefaultProps.valueScale,\n    indexScale = canvasDefaultProps.indexScale,\n\n    padding = canvasDefaultProps.padding,\n    innerPadding = canvasDefaultProps.innerPadding,\n\n    axisTop,\n    axisRight,\n    axisBottom = canvasDefaultProps.axisBottom,\n    axisLeft = canvasDefaultProps.axisLeft,\n    enableGridX = canvasDefaultProps.enableGridX,\n    enableGridY = canvasDefaultProps.enableGridY,\n    gridXValues,\n    gridYValues,\n\n    layers = canvasDefaultProps.layers as BarCanvasLayer<RawDatum>[],\n    renderBar = (\n        ctx,\n        {\n            bar: { color, height, width, x, y },\n\n            borderColor,\n            borderRadius,\n            borderWidth,\n            label,\n            labelColor,\n            shouldRenderLabel,\n        }\n    ) => {\n        ctx.fillStyle = color\n\n        if (borderWidth > 0) {\n            ctx.strokeStyle = borderColor\n            ctx.lineWidth = borderWidth\n        }\n\n        ctx.beginPath()\n\n        if (borderRadius > 0) {\n            const radius = Math.min(borderRadius, height)\n\n            ctx.moveTo(x + radius, y)\n            ctx.lineTo(x + width - radius, y)\n            ctx.quadraticCurveTo(x + width, y, x + width, y + radius)\n            ctx.lineTo(x + width, y + height - radius)\n            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height)\n            ctx.lineTo(x + radius, y + height)\n            ctx.quadraticCurveTo(x, y + height, x, y + height - radius)\n            ctx.lineTo(x, y + radius)\n            ctx.quadraticCurveTo(x, y, x + radius, y)\n            ctx.closePath()\n        } else {\n            ctx.rect(x, y, width, height)\n        }\n\n        ctx.fill()\n\n        if (borderWidth > 0) {\n            ctx.stroke()\n        }\n\n        if (shouldRenderLabel) {\n            ctx.textBaseline = 'middle'\n            ctx.textAlign = 'center'\n            ctx.fillStyle = labelColor\n            ctx.fillText(label, x + width / 2, y + height / 2)\n        }\n    },\n\n    enableLabel = canvasDefaultProps.enableLabel,\n    label = canvasDefaultProps.label,\n    labelSkipWidth = canvasDefaultProps.labelSkipWidth,\n    labelSkipHeight = canvasDefaultProps.labelSkipHeight,\n    labelTextColor = canvasDefaultProps.labelTextColor,\n\n    colorBy = canvasDefaultProps.colorBy,\n    colors = canvasDefaultProps.colors,\n    borderRadius = canvasDefaultProps.borderRadius,\n    borderWidth = canvasDefaultProps.borderWidth,\n    borderColor = canvasDefaultProps.borderColor,\n\n    annotations = canvasDefaultProps.annotations,\n\n    legendLabel,\n    tooltipLabel = canvasDefaultProps.tooltipLabel,\n\n    valueFormat,\n\n    isInteractive = canvasDefaultProps.isInteractive,\n    tooltip = canvasDefaultProps.tooltip,\n    onClick,\n    onMouseEnter,\n    onMouseLeave,\n\n    legends = canvasDefaultProps.legends,\n\n    pixelRatio = canvasDefaultProps.pixelRatio,\n\n    canvasRef,\n}: InnerBarCanvasProps<RawDatum>) => {\n    const canvasEl = useRef<HTMLCanvasElement | null>(null)\n\n    const theme = useTheme()\n    const { margin, innerWidth, innerHeight, outerWidth, outerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n\n    const formatValue = useValueFormatter(valueFormat)\n    const getBorderColor = useInheritedColor<ComputedBarDatum<RawDatum>>(borderColor, theme)\n    const getColor = useOrdinalColorScale(colors, colorBy)\n    const getIndex = usePropertyAccessor(indexBy)\n    const getLabel = usePropertyAccessor(label)\n    const getLabelColor = useInheritedColor<ComputedBarDatum<RawDatum>>(labelTextColor, theme)\n    const getTooltipLabel = usePropertyAccessor(tooltipLabel)\n\n    const options = {\n        layout,\n        reverse,\n        data,\n        getIndex,\n        keys,\n        minValue,\n        maxValue,\n        width: innerWidth,\n        height: innerHeight,\n        getColor,\n        padding,\n        innerPadding,\n        valueScale,\n        indexScale,\n        formatValue,\n        getTooltipLabel,\n    }\n\n    const result =\n        groupMode === 'grouped' ? generateGroupedBars(options) : generateStackedBars(options)\n\n    const legendData = useMemo(\n        () =>\n            keys.map(key => {\n                const bar = result.bars.find(bar => bar.data.id === key)\n\n                return { ...bar, data: { id: key, ...bar?.data, hidden: false } }\n            }),\n        [keys, result.bars]\n    )\n\n    const barsWithValue = useMemo(\n        () =>\n            result.bars.filter(\n                (bar): bar is ComputedBarDatumWithValue<RawDatum> => bar.data.value !== null\n            ),\n        [result.bars]\n    )\n\n    const shouldRenderLabel = useCallback(\n        ({ width, height }: { height: number; width: number }) => {\n            if (!enableLabel) return false\n            if (labelSkipWidth > 0 && width < labelSkipWidth) return false\n            if (labelSkipHeight > 0 && height < labelSkipHeight) return false\n            return true\n        },\n        [enableLabel, labelSkipHeight, labelSkipWidth]\n    )\n\n    // Using any because return type isn't correct\n    const boundAnnotations: any = useComputedAnnotations({\n        annotations: useAnnotations({\n            data: result.bars,\n            annotations,\n            getPosition: node => ({\n                x: node.x,\n                y: node.y,\n            }),\n            getDimensions: ({ width, height }) => ({\n                width,\n                height,\n                size: Math.max(width, height),\n            }),\n        }),\n    })\n\n    // We use `any` here until we can figure out the best way to type xScale/yScale\n    const layerContext: any = useMemo(\n        () => ({\n            borderRadius,\n            borderWidth,\n            enableLabel,\n            isInteractive,\n            labelSkipWidth,\n            labelSkipHeight,\n            onClick,\n            onMouseEnter,\n            onMouseLeave,\n            getTooltipLabel,\n            tooltip,\n            margin,\n            innerWidth,\n            innerHeight,\n            width,\n            height,\n            ...result,\n        }),\n        [\n            borderRadius,\n            borderWidth,\n            enableLabel,\n            getTooltipLabel,\n            height,\n            innerHeight,\n            innerWidth,\n            isInteractive,\n            labelSkipHeight,\n            labelSkipWidth,\n            margin,\n            onClick,\n            onMouseEnter,\n            onMouseLeave,\n            result,\n            tooltip,\n            width,\n        ]\n    )\n\n    useEffect(() => {\n        const ctx = canvasEl.current?.getContext('2d')\n\n        if (!canvasEl.current) return\n        if (!ctx) return\n\n        canvasEl.current.width = outerWidth * pixelRatio\n        canvasEl.current.height = outerHeight * pixelRatio\n\n        ctx.scale(pixelRatio, pixelRatio)\n\n        ctx.fillStyle = theme.background\n        ctx.fillRect(0, 0, outerWidth, outerHeight)\n        ctx.translate(margin.left, margin.top)\n\n        layers.forEach(layer => {\n            if (layer === 'grid') {\n                if (isNumber(theme.grid.line.strokeWidth) && theme.grid.line.strokeWidth > 0) {\n                    ctx.lineWidth = theme.grid.line.strokeWidth\n                    ctx.strokeStyle = theme.grid.line.stroke as string\n\n                    if (enableGridX) {\n                        renderGridLinesToCanvas<string | number>(ctx, {\n                            width,\n                            height,\n                            scale: result.xScale as any,\n                            axis: 'x',\n                            values: gridXValues,\n                        })\n                    }\n\n                    if (enableGridY) {\n                        renderGridLinesToCanvas<string | number>(ctx, {\n                            width,\n                            height,\n                            scale: result.yScale as any,\n                            axis: 'y',\n                            values: gridYValues,\n                        })\n                    }\n                }\n            } else if (layer === 'axes') {\n                renderAxesToCanvas(ctx, {\n                    xScale: result.xScale as any,\n                    yScale: result.yScale as any,\n                    width: innerWidth,\n                    height: innerHeight,\n                    top: axisTop,\n                    right: axisRight,\n                    bottom: axisBottom,\n                    left: axisLeft,\n                    theme,\n                })\n            } else if (layer === 'bars') {\n                barsWithValue.forEach(bar => {\n                    renderBar(ctx, {\n                        bar,\n                        borderColor: getBorderColor(bar),\n                        borderRadius,\n                        borderWidth,\n                        label: getLabel(bar.data),\n                        labelColor: getLabelColor(bar),\n                        shouldRenderLabel: shouldRenderLabel(bar),\n                    })\n                })\n            } else if (layer === 'legends') {\n                legends.forEach(legend => {\n                    const data = getLegendData({\n                        bars: legendData,\n                        direction: legend.direction,\n                        from: legend.dataFrom,\n                        groupMode,\n                        layout,\n                        legendLabel,\n                        reverse,\n                    })\n\n                    renderLegendToCanvas(ctx, {\n                        ...legend,\n                        data,\n                        containerWidth: innerWidth,\n                        containerHeight: innerHeight,\n                        theme,\n                    })\n                })\n            } else if (layer === 'annotations') {\n                renderAnnotationsToCanvas(ctx, { annotations: boundAnnotations, theme })\n            } else if (typeof layer === 'function') {\n                layer(ctx, layerContext)\n            }\n        })\n\n        ctx.save()\n    }, [\n        axisBottom,\n        axisLeft,\n        axisRight,\n        axisTop,\n        barsWithValue,\n        borderRadius,\n        borderWidth,\n        boundAnnotations,\n        enableGridX,\n        enableGridY,\n        getBorderColor,\n        getLabel,\n        getLabelColor,\n        gridXValues,\n        gridYValues,\n        groupMode,\n        height,\n        innerHeight,\n        innerWidth,\n        layerContext,\n        layers,\n        layout,\n        legendData,\n        legendLabel,\n        legends,\n        margin.left,\n        margin.top,\n        outerHeight,\n        outerWidth,\n        pixelRatio,\n        renderBar,\n        result.xScale,\n        result.yScale,\n        reverse,\n        shouldRenderLabel,\n        theme,\n        width,\n    ])\n\n    const handleMouseHover = useCallback(\n        (event: React.MouseEvent<HTMLCanvasElement>) => {\n            if (!result.bars) return\n            if (!canvasEl.current) return\n\n            const [x, y] = getRelativeCursor(canvasEl.current, event)\n            const bar = findBarUnderCursor(result.bars, margin, x, y)\n\n            if (bar !== undefined) {\n                showTooltipFromEvent(\n                    createElement(tooltip, {\n                        ...bar.data,\n                        color: bar.color,\n                        label: bar.label,\n                        value: Number(bar.data.value),\n                    }),\n                    event\n                )\n\n                if (event.type === 'mouseenter') {\n                    onMouseEnter?.(bar.data, event)\n                }\n            } else {\n                hideTooltip()\n            }\n        },\n        [hideTooltip, margin, onMouseEnter, result.bars, showTooltipFromEvent, tooltip]\n    )\n\n    const handleMouseLeave = useCallback(\n        (event: React.MouseEvent<HTMLCanvasElement>) => {\n            if (!result.bars) return\n            if (!canvasEl.current) return\n\n            hideTooltip()\n\n            const [x, y] = getRelativeCursor(canvasEl.current, event)\n            const bar = findBarUnderCursor(result.bars, margin, x, y)\n\n            if (bar) {\n                onMouseLeave?.(bar.data, event)\n            }\n        },\n        [hideTooltip, margin, onMouseLeave, result.bars]\n    )\n\n    const handleClick = useCallback(\n        (event: React.MouseEvent<HTMLCanvasElement>) => {\n            if (!result.bars) return\n            if (!canvasEl.current) return\n\n            const [x, y] = getRelativeCursor(canvasEl.current, event)\n            const bar = findBarUnderCursor(result.bars, margin, x, y)\n\n            if (bar !== undefined) {\n                onClick?.({ ...bar.data, color: bar.color }, event)\n            }\n        },\n        [margin, onClick, result.bars]\n    )\n\n    return (\n        <canvas\n            ref={canvas => {\n                canvasEl.current = canvas\n                if (canvasRef && 'current' in canvasRef) canvasRef.current = canvas\n            }}\n            width={outerWidth * pixelRatio}\n            height={outerHeight * pixelRatio}\n            style={{\n                width: outerWidth,\n                height: outerHeight,\n                cursor: isInteractive ? 'auto' : 'normal',\n            }}\n            onMouseEnter={isInteractive ? handleMouseHover : undefined}\n            onMouseMove={isInteractive ? handleMouseHover : undefined}\n            onMouseLeave={isInteractive ? handleMouseLeave : undefined}\n            onClick={isInteractive ? handleClick : undefined}\n        />\n    )\n}\n\nexport const BarCanvas = forwardRef(\n    <RawDatum extends BarDatum>(\n        { isInteractive, renderWrapper, theme, ...props }: BarCanvasProps<RawDatum>,\n        ref: ForwardedRef<HTMLCanvasElement>\n    ) => (\n        <Container {...{ isInteractive, renderWrapper, theme }} animate={false}>\n            <InnerBarCanvas {...props} canvasRef={ref} />\n        </Container>\n    )\n)\n","import { Bar } from './Bar'\nimport { BarDatum, BarSvgProps } from './types'\nimport { ResponsiveWrapper } from '@nivo/core'\n\nexport const ResponsiveBar = <RawDatum extends BarDatum>(\n    props: Omit<BarSvgProps<RawDatum>, 'height' | 'width'>\n) => (\n    <ResponsiveWrapper>\n        {({ width, height }) => <Bar width={width} height={height} {...props} />}\n    </ResponsiveWrapper>\n)\n","import { BarDatum, BarCanvasProps } from './types'\nimport { BarCanvas } from './BarCanvas'\nimport { ForwardedRef, forwardRef } from 'react'\nimport { ResponsiveWrapper } from '@nivo/core'\n\nexport const ResponsiveBarCanvas = forwardRef(function ResponsiveBarCanvas<\n    RawDatum extends BarDatum\n>(props: Omit<BarCanvasProps<RawDatum>, 'height' | 'width'>, ref: ForwardedRef<HTMLCanvasElement>) {\n    return (\n        <ResponsiveWrapper>\n            {({ width, height }) => (\n                <BarCanvas width={width} height={height} {...props} ref={ref} />\n            )}\n        </ResponsiveWrapper>\n    )\n})\n","import {\n    AnnotationSpec,\n    CircleAnnotationSpec,\n    DotAnnotationSpec,\n    Note,\n    NoteCanvas,\n    NoteSvg,\n    RectAnnotationSpec,\n} from './types'\nimport { isValidElement } from 'react'\n\nexport const isSvgNote = <Datum>(note: Note<Datum>): note is NoteSvg<Datum> => {\n    const noteType = typeof note\n\n    return (\n        isValidElement(note) ||\n        noteType === 'string' ||\n        noteType === 'function' ||\n        noteType === 'object'\n    )\n}\n\nexport const isCanvasNote = <Datum>(note: Note<Datum>): note is NoteCanvas<Datum> => {\n    const noteType = typeof note\n\n    return noteType === 'string' || noteType === 'function'\n}\n\nexport const isCircleAnnotation = <Datum>(\n    annotationSpec: AnnotationSpec<Datum>\n): annotationSpec is CircleAnnotationSpec<Datum> => annotationSpec.type === 'circle'\n\nexport const isDotAnnotation = <Datum>(\n    annotationSpec: AnnotationSpec<Datum>\n): annotationSpec is DotAnnotationSpec<Datum> => annotationSpec.type === 'dot'\n\nexport const isRectAnnotation = <Datum>(\n    annotationSpec: AnnotationSpec<Datum>\n): annotationSpec is RectAnnotationSpec<Datum> => annotationSpec.type === 'rect'\n","import { filter, isNumber, omit } from 'lodash'\nimport {\n    radiansToDegrees,\n    absoluteAngleDegrees,\n    degreesToRadians,\n    positionFromAngle,\n} from '@nivo/core'\nimport { defaultProps } from './props'\nimport {\n    AnnotationSpec,\n    AnnotationPositionGetter,\n    AnnotationDimensionsGetter,\n    BoundAnnotation,\n    AnnotationMatcher,\n    AnnotationInstructions,\n} from './types'\nimport { isCircleAnnotation, isRectAnnotation } from './utils'\n\nexport const bindAnnotations = <\n    Datum = {\n        x: number\n        y: number\n    }\n>({\n    data,\n    annotations,\n    getPosition,\n    getDimensions,\n}: {\n    data: Datum[]\n    annotations: AnnotationMatcher<Datum>[]\n    getPosition: AnnotationPositionGetter<Datum>\n    getDimensions: AnnotationDimensionsGetter<Datum>\n}): BoundAnnotation<Datum>[] =>\n    annotations.reduce((acc: BoundAnnotation<Datum>[], annotation) => {\n        const offset = annotation.offset || 0\n\n        return [\n            ...acc,\n            ...filter<Datum>(data, annotation.match).map(datum => {\n                const position = getPosition(datum)\n                const dimensions = getDimensions(datum)\n\n                if (isCircleAnnotation(annotation) || isRectAnnotation(annotation)) {\n                    dimensions.size = dimensions.size + offset * 2\n                    dimensions.width = dimensions.width + offset * 2\n                    dimensions.height = dimensions.height + offset * 2\n                }\n\n                // acc.push({\n                //     ...omit(annotation, ['match', 'offset']),\n                //     ...position,\n                //     ...dimensions,\n                //     size: annotation.size || dimensions.size,\n                //     datum,\n                // } as any)\n                // return [\n                //     ...acc,\n                //     {\n                //         ...omit(annotation, ['match', 'offset']),\n                //         ...position,\n                //         ...dimensions,\n                //         size: annotation.size || dimensions.size,\n                //         datum,\n                //     },\n                // ]\n                return {\n                    ...omit(annotation, ['match', 'offset']),\n                    ...position,\n                    ...dimensions,\n                    size: annotation.size || dimensions.size,\n                    datum,\n                } as Required<BoundAnnotation<Datum>>\n            }),\n        ]\n\n        // return acc\n    }, [])\n\nexport const getLinkAngle = (\n    sourceX: number,\n    sourceY: number,\n    targetX: number,\n    targetY: number\n) => {\n    const angle = Math.atan2(targetY - sourceY, targetX - sourceX)\n\n    return absoluteAngleDegrees(radiansToDegrees(angle))\n}\n\nexport const computeAnnotation = <Datum>(\n    annotation: Required<AnnotationSpec<Datum>>\n): AnnotationInstructions => {\n    const {\n        x,\n        y,\n        noteX,\n        noteY,\n        noteWidth = defaultProps.noteWidth,\n        noteTextOffset = defaultProps.noteTextOffset,\n    } = annotation\n\n    let computedNoteX: number\n    let computedNoteY: number\n\n    if (isNumber(noteX)) {\n        computedNoteX = x + noteX\n    } else if (noteX.abs !== undefined) {\n        computedNoteX = noteX.abs\n    } else {\n        throw new Error(`noteX should be either a number or an object containing an 'abs' property`)\n    }\n\n    if (isNumber(noteY)) {\n        computedNoteY = y + noteY\n    } else if (noteY.abs !== undefined) {\n        computedNoteY = noteY.abs\n    } else {\n        throw new Error(`noteY should be either a number or an object containing an 'abs' property`)\n    }\n\n    let computedX = x\n    let computedY = y\n\n    const angle = getLinkAngle(x, y, computedNoteX, computedNoteY)\n\n    if (isCircleAnnotation<Datum>(annotation)) {\n        const position = positionFromAngle(degreesToRadians(angle), annotation.size / 2)\n        computedX += position.x\n        computedY += position.y\n    }\n\n    if (isRectAnnotation<Datum>(annotation)) {\n        const eighth = Math.round((angle + 90) / 45) % 8\n        if (eighth === 0) {\n            computedY -= annotation.height / 2\n        }\n        if (eighth === 1) {\n            computedX += annotation.width / 2\n            computedY -= annotation.height / 2\n        }\n        if (eighth === 2) {\n            computedX += annotation.width / 2\n        }\n        if (eighth === 3) {\n            computedX += annotation.width / 2\n            computedY += annotation.height / 2\n        }\n        if (eighth === 4) {\n            computedY += annotation.height / 2\n        }\n        if (eighth === 5) {\n            computedX -= annotation.width / 2\n            computedY += annotation.height / 2\n        }\n        if (eighth === 6) {\n            computedX -= annotation.width / 2\n        }\n        if (eighth === 7) {\n            computedX -= annotation.width / 2\n            computedY -= annotation.height / 2\n        }\n    }\n\n    let textX = computedNoteX\n    const textY = computedNoteY - noteTextOffset\n\n    let noteLineX = computedNoteX\n    const noteLineY = computedNoteY\n\n    if ((angle + 90) % 360 > 180) {\n        textX -= noteWidth\n        noteLineX -= noteWidth\n    } else {\n        noteLineX += noteWidth\n    }\n\n    return {\n        points: [\n            [computedX, computedY],\n            [computedNoteX, computedNoteY],\n            [noteLineX, noteLineY],\n        ] as [number, number][],\n        text: [textX, textY],\n        angle: angle + 90,\n    }\n}\n","import { useMemo } from 'react'\nimport { bindAnnotations, computeAnnotation } from './compute'\nimport {\n    AnnotationDimensionsGetter,\n    AnnotationMatcher,\n    AnnotationPositionGetter,\n    AnnotationSpec,\n} from './types'\n\n/**\n * Bind annotations to a dataset.\n */\nexport const useAnnotations = <Datum>({\n    data,\n    annotations,\n    getPosition,\n    getDimensions,\n}: {\n    data: Datum[]\n    annotations: AnnotationMatcher<Datum>[]\n    getPosition: AnnotationPositionGetter<Datum>\n    getDimensions: AnnotationDimensionsGetter<Datum>\n}) =>\n    useMemo(\n        () =>\n            bindAnnotations<Datum>({\n                data,\n                annotations,\n                getPosition,\n                getDimensions,\n            }),\n        [data, annotations, getPosition, getDimensions]\n    )\n\nexport const useComputedAnnotations = <Datum>({\n    annotations,\n}: {\n    annotations: Required<AnnotationSpec<Datum>>[]\n}) =>\n    useMemo(\n        () =>\n            annotations.map(annotation => ({\n                ...annotation,\n                computed: computeAnnotation<Datum>({\n                    ...annotation,\n                }),\n            })),\n        [annotations]\n    )\n\nexport const useComputedAnnotation = <Datum>(annotation: Required<AnnotationSpec<Datum>>) =>\n    useMemo(() => computeAnnotation<Datum>(annotation), [annotation])\n","import { createElement } from 'react'\nimport omit from 'lodash/omit'\nimport { useSpring, animated } from '@react-spring/web'\nimport { useTheme, useMotionConfig } from '@nivo/core'\nimport { NoteSvg } from './types'\n\nexport const AnnotationNote = <Datum,>({\n    datum,\n    x,\n    y,\n    note,\n}: {\n    datum: Datum\n    x: number\n    y: number\n    note: NoteSvg<Datum>\n}) => {\n    const theme = useTheme()\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const animatedProps = useSpring({\n        x,\n        y,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    if (typeof note === 'function') {\n        return createElement(note, { x, y, datum })\n    }\n\n    return (\n        <>\n            {theme.annotations.text.outlineWidth > 0 && (\n                <animated.text\n                    x={animatedProps.x}\n                    y={animatedProps.y}\n                    style={{\n                        ...theme.annotations.text,\n                        strokeLinejoin: 'round',\n                        strokeWidth: theme.annotations.text.outlineWidth * 2,\n                        stroke: theme.annotations.text.outlineColor,\n                    }}\n                >\n                    {note}\n                </animated.text>\n            )}\n            <animated.text\n                x={animatedProps.x}\n                y={animatedProps.y}\n                style={omit(theme.annotations.text, ['outlineWidth', 'outlineColor'])}\n            >\n                {note}\n            </animated.text>\n        </>\n    )\n}\n","import { useMemo } from 'react'\nimport { animated } from '@react-spring/web'\nimport { useAnimatedPath, useTheme } from '@nivo/core'\n\nexport const AnnotationLink = ({\n    points,\n    isOutline = false,\n}: {\n    points: [number, number][]\n    isOutline?: boolean\n}) => {\n    const theme = useTheme()\n\n    const path = useMemo(() => {\n        const [firstPoint, ...otherPoints] = points\n\n        return otherPoints.reduce(\n            (acc, [x, y]) => `${acc} L${x},${y}`,\n            `M${firstPoint[0]},${firstPoint[1]}`\n        )\n    }, [points])\n\n    const animatedPath = useAnimatedPath(path)\n\n    if (isOutline && theme.annotations.link.outlineWidth <= 0) {\n        return null\n    }\n\n    const style = { ...theme.annotations.link }\n    if (isOutline) {\n        style.strokeLinecap = 'square'\n        style.strokeWidth =\n            theme.annotations.link.strokeWidth + theme.annotations.link.outlineWidth * 2\n        style.stroke = theme.annotations.link.outlineColor\n    }\n\n    return <animated.path fill=\"none\" d={animatedPath} style={style} />\n}\n","import arrayWithHoles from \"@babel/runtime/helpers/esm/arrayWithHoles\";\nimport iterableToArray from \"@babel/runtime/helpers/esm/iterableToArray\";\nimport unsupportedIterableToArray from \"@babel/runtime/helpers/esm/unsupportedIterableToArray\";\nimport nonIterableRest from \"@babel/runtime/helpers/esm/nonIterableRest\";\nexport default function _toArray(arr) {\n  return arrayWithHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableRest();\n}","import { useSpring, animated } from '@react-spring/web'\nimport { useMotionConfig, useTheme } from '@nivo/core'\n\nexport const CircleAnnotationOutline = ({ x, y, size }: { x: number; y: number; size: number }) => {\n    const theme = useTheme()\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const animatedProps = useSpring({\n        x,\n        y,\n        radius: size / 2,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <>\n            {theme.annotations.outline.outlineWidth > 0 && (\n                <animated.circle\n                    cx={animatedProps.x}\n                    cy={animatedProps.y}\n                    r={animatedProps.radius}\n                    style={{\n                        ...theme.annotations.outline,\n                        fill: 'none',\n                        strokeWidth:\n                            theme.annotations.outline.strokeWidth +\n                            theme.annotations.outline.outlineWidth * 2,\n                        stroke: theme.annotations.outline.outlineColor,\n                    }}\n                />\n            )}\n            <animated.circle\n                cx={animatedProps.x}\n                cy={animatedProps.y}\n                r={animatedProps.radius}\n                style={theme.annotations.outline}\n            />\n        </>\n    )\n}\n","import { useSpring, animated } from '@react-spring/web'\nimport { useMotionConfig, useTheme } from '@nivo/core'\nimport { defaultProps } from './props'\n\nexport const DotAnnotationOutline = ({\n    x,\n    y,\n    size = defaultProps.dotSize,\n}: {\n    x: number\n    y: number\n    size?: number\n}) => {\n    const theme = useTheme()\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const animatedProps = useSpring({\n        x,\n        y,\n        radius: size / 2,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <>\n            {theme.annotations.outline.outlineWidth > 0 && (\n                <animated.circle\n                    cx={animatedProps.x}\n                    cy={animatedProps.y}\n                    r={animatedProps.radius}\n                    style={{\n                        ...theme.annotations.outline,\n                        fill: 'none',\n                        strokeWidth: theme.annotations.outline.outlineWidth * 2,\n                        stroke: theme.annotations.outline.outlineColor,\n                    }}\n                />\n            )}\n            <animated.circle\n                cx={animatedProps.x}\n                cy={animatedProps.y}\n                r={animatedProps.radius}\n                style={theme.annotations.symbol}\n            />\n        </>\n    )\n}\n","import { useSpring, animated } from '@react-spring/web'\nimport { useMotionConfig, useTheme } from '@nivo/core'\n\nexport const RectAnnotationOutline = ({\n    x,\n    y,\n    width,\n    height,\n}: {\n    x: number\n    y: number\n    width: number\n    height: number\n}) => {\n    const theme = useTheme()\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const animatedProps = useSpring({\n        x: x - width / 2,\n        y: y - height / 2,\n        width,\n        height,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <>\n            {theme.annotations.outline.outlineWidth > 0 && (\n                <animated.rect\n                    x={animatedProps.x}\n                    y={animatedProps.y}\n                    width={animatedProps.width}\n                    height={animatedProps.height}\n                    style={{\n                        ...theme.annotations.outline,\n                        fill: 'none',\n                        strokeWidth:\n                            theme.annotations.outline.strokeWidth +\n                            theme.annotations.outline.outlineWidth * 2,\n                        stroke: theme.annotations.outline.outlineColor,\n                    }}\n                />\n            )}\n            <animated.rect\n                x={animatedProps.x}\n                y={animatedProps.y}\n                width={animatedProps.width}\n                height={animatedProps.height}\n                style={theme.annotations.outline}\n            />\n        </>\n    )\n}\n","import { useComputedAnnotation } from './hooks'\nimport { AnnotationNote } from './AnnotationNote'\nimport { AnnotationLink } from './AnnotationLink'\nimport { CircleAnnotationOutline } from './CircleAnnotationOutline'\nimport { DotAnnotationOutline } from './DotAnnotationOutline'\nimport { RectAnnotationOutline } from './RectAnnotationOutline'\nimport { BoundAnnotation } from './types'\nimport { isCircleAnnotation, isDotAnnotation, isRectAnnotation, isSvgNote } from './utils'\n\nexport const Annotation = <Datum,>(annotation: BoundAnnotation<Datum>) => {\n    const { datum, x, y, note } = annotation\n    const computed = useComputedAnnotation(annotation)\n\n    if (!isSvgNote(note)) {\n        throw new Error('note should be a valid react element')\n    }\n\n    return (\n        <>\n            <AnnotationLink points={computed.points} isOutline={true} />\n            {isCircleAnnotation(annotation) && (\n                <CircleAnnotationOutline x={x} y={y} size={annotation.size} />\n            )}\n            {isDotAnnotation(annotation) && (\n                <DotAnnotationOutline x={x} y={y} size={annotation.size} />\n            )}\n            {isRectAnnotation(annotation) && (\n                <RectAnnotationOutline\n                    x={x}\n                    y={y}\n                    width={annotation.width}\n                    height={annotation.height}\n                />\n            )}\n            <AnnotationLink points={computed.points} />\n            <AnnotationNote datum={datum} x={computed.text[0]} y={computed.text[1]} note={note} />\n        </>\n    )\n}\n","import { CompleteTheme } from '@nivo/core'\nimport { ComputedAnnotation } from './types'\nimport { isCanvasNote, isCircleAnnotation, isDotAnnotation, isRectAnnotation } from './utils'\n\nconst drawPoints = (ctx: CanvasRenderingContext2D, points: [number, number][]) => {\n    points.forEach(([x, y], index) => {\n        if (index === 0) {\n            ctx.moveTo(x, y)\n        } else {\n            ctx.lineTo(x, y)\n        }\n    })\n}\n\nexport const renderAnnotationsToCanvas = <Datum>(\n    ctx: CanvasRenderingContext2D,\n    {\n        annotations,\n        theme,\n    }: {\n        annotations: ComputedAnnotation<Datum>[]\n        theme: CompleteTheme\n    }\n) => {\n    if (annotations.length === 0) return\n\n    ctx.save()\n    annotations.forEach(annotation => {\n        if (!isCanvasNote(annotation.note)) {\n            throw new Error('note is invalid for canvas implementation')\n        }\n\n        if (theme.annotations.link.outlineWidth > 0) {\n            ctx.lineCap = 'square'\n            ctx.strokeStyle = theme.annotations.link.outlineColor\n            ctx.lineWidth =\n                theme.annotations.link.strokeWidth + theme.annotations.link.outlineWidth * 2\n            ctx.beginPath()\n            drawPoints(ctx, annotation.computed.points)\n            ctx.stroke()\n            ctx.lineCap = 'butt'\n        }\n\n        if (isCircleAnnotation(annotation) && theme.annotations.outline.outlineWidth > 0) {\n            ctx.strokeStyle = theme.annotations.outline.outlineColor\n            ctx.lineWidth =\n                theme.annotations.outline.strokeWidth + theme.annotations.outline.outlineWidth * 2\n            ctx.beginPath()\n            ctx.arc(annotation.x, annotation.y, annotation.size / 2, 0, 2 * Math.PI)\n            ctx.stroke()\n        }\n\n        if (isDotAnnotation(annotation) && theme.annotations.symbol.outlineWidth > 0) {\n            ctx.strokeStyle = theme.annotations.symbol.outlineColor\n            ctx.lineWidth = theme.annotations.symbol.outlineWidth * 2\n            ctx.beginPath()\n            ctx.arc(annotation.x, annotation.y, annotation.size / 2, 0, 2 * Math.PI)\n            ctx.stroke()\n        }\n\n        if (isRectAnnotation(annotation) && theme.annotations.outline.outlineWidth > 0) {\n            ctx.strokeStyle = theme.annotations.outline.outlineColor\n            ctx.lineWidth =\n                theme.annotations.outline.strokeWidth + theme.annotations.outline.outlineWidth * 2\n            ctx.beginPath()\n            ctx.rect(\n                annotation.x - annotation.width / 2,\n                annotation.y - annotation.height / 2,\n                annotation.width,\n                annotation.height\n            )\n            ctx.stroke()\n        }\n\n        ctx.strokeStyle = theme.annotations.link.stroke\n        ctx.lineWidth = theme.annotations.link.strokeWidth\n        ctx.beginPath()\n        drawPoints(ctx, annotation.computed.points)\n        ctx.stroke()\n\n        if (isCircleAnnotation(annotation)) {\n            ctx.strokeStyle = theme.annotations.outline.stroke\n            ctx.lineWidth = theme.annotations.outline.strokeWidth\n            ctx.beginPath()\n            ctx.arc(annotation.x, annotation.y, annotation.size / 2, 0, 2 * Math.PI)\n            ctx.stroke()\n        }\n\n        if (isDotAnnotation(annotation)) {\n            ctx.fillStyle = theme.annotations.symbol.fill\n            ctx.beginPath()\n            ctx.arc(annotation.x, annotation.y, annotation.size / 2, 0, 2 * Math.PI)\n            ctx.fill()\n        }\n\n        if (isRectAnnotation(annotation)) {\n            ctx.strokeStyle = theme.annotations.outline.stroke\n            ctx.lineWidth = theme.annotations.outline.strokeWidth\n            ctx.beginPath()\n            ctx.rect(\n                annotation.x - annotation.width / 2,\n                annotation.y - annotation.height / 2,\n                annotation.width,\n                annotation.height\n            )\n            ctx.stroke()\n        }\n\n        if (typeof annotation.note === 'function') {\n            annotation.note(ctx, {\n                datum: annotation.datum,\n                x: annotation.computed.text[0],\n                y: annotation.computed.text[1],\n                theme,\n            })\n        } else {\n            ctx.font = `${theme.annotations.text.fontSize}px ${theme.annotations.text.fontFamily}`\n            ctx.fillStyle = theme.annotations.text.fill\n            ctx.strokeStyle = theme.annotations.text.outlineColor\n            ctx.lineWidth = theme.annotations.text.outlineWidth * 2\n            if (theme.annotations.text.outlineWidth > 0) {\n                ctx.lineJoin = 'round'\n                ctx.strokeText(\n                    annotation.note,\n                    annotation.computed.text[0],\n                    annotation.computed.text[1]\n                )\n                ctx.lineJoin = 'miter'\n            }\n            ctx.fillText(annotation.note, annotation.computed.text[0], annotation.computed.text[1])\n        }\n    })\n    ctx.restore()\n}\n","var arrayFilter = require('./_arrayFilter'),\n    baseFilter = require('./_baseFilter'),\n    baseIteratee = require('./_baseIteratee'),\n    isArray = require('./isArray');\n\n/**\n * Iterates over elements of `collection`, returning an array of all elements\n * `predicate` returns truthy for. The predicate is invoked with three\n * arguments: (value, index|key, collection).\n *\n * **Note:** Unlike `_.remove`, this method returns a new array.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n * @see _.reject\n * @example\n *\n * var users = [\n *   { 'user': 'barney', 'age': 36, 'active': true },\n *   { 'user': 'fred',   'age': 40, 'active': false }\n * ];\n *\n * _.filter(users, function(o) { return !o.active; });\n * // => objects for ['fred']\n *\n * // The `_.matches` iteratee shorthand.\n * _.filter(users, { 'age': 36, 'active': true });\n * // => objects for ['barney']\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.filter(users, ['active', false]);\n * // => objects for ['fred']\n *\n * // The `_.property` iteratee shorthand.\n * _.filter(users, 'active');\n * // => objects for ['barney']\n *\n * // Combining several predicates using `_.overEvery` or `_.overSome`.\n * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));\n * // => objects for ['fred', 'barney']\n */\nfunction filter(collection, predicate) {\n  var func = isArray(collection) ? arrayFilter : baseFilter;\n  return func(collection, baseIteratee(predicate, 3));\n}\n\nmodule.exports = filter;\n","var baseEach = require('./_baseEach');\n\n/**\n * The base implementation of `_.filter` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction baseFilter(collection, predicate) {\n  var result = [];\n  baseEach(collection, function(value, index, collection) {\n    if (predicate(value, index, collection)) {\n      result.push(value);\n    }\n  });\n  return result;\n}\n\nmodule.exports = baseFilter;\n"],"sourceRoot":""}