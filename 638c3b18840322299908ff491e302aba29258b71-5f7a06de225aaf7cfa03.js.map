{"version":3,"sources":["webpack:///../src/props.ts","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js","webpack:///../src/hooks.ts","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArray.js","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","webpack:///../src/CellsSvg.tsx","webpack:///../src/Waffle.tsx","webpack:///../src/ResponsiveWaffle.tsx","webpack:///../src/WaffleHtml.tsx","webpack:///../src/ResponsiveWaffleHtml.tsx","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","webpack:///../src/CellTooltip.tsx","webpack:///../src/WaffleCanvas.tsx","webpack:///../src/types.ts","webpack:///../src/ResponsiveWaffleCanvas.tsx"],"names":["defaultProps","fillDirection","padding","colors","scheme","emptyColor","emptyOpacity","borderWidth","borderColor","from","modifiers","defs","fill","isInteractive","legends","animate","motionDefaultProps","motionConfig","role","pixelRatio","window","_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","push","apply","_objectSpread2","target","i","arguments","length","source","forEach","getOwnPropertyDescriptors","defineProperties","computeGrid","cellSize","sizeX","width","columns","sizeY","height","rows","Math","computeCellSize","cells","row","column","position","x","y","color","origin","useWaffle","data","valueFormat","total","formatValue","useValueFormatter","getColor","useOrdinalColorScale","theme","useTheme","getBorderColor","useInheritedColor","unit","grid","useMemo","computedData","currentPosition","enhancedDatum","id","datum","label","formattedValue","groupIndex","startAt","endAt","legendData","useMergeCellsData","console","cellsCopy","cell","cellWithData","mergeCellsData","_arrayLikeToArray","arr","len","arr2","Array","_unsupportedIterableToArray","o","minLen","arrayLikeToArray","n","prototype","toString","call","slice","constructor","name","test","_toConsumableArray","isArray","arrayWithoutHoles","iter","Symbol","iterator","iterableToArray","unsupportedIterableToArray","TypeError","nonIterableSpread","CellsSvg","mergedCells","useMotionConfig","springConfig","reversed","r","transitions","useTransition","opacity","enter","update","leave","unique","reset","config","immediate","item","props","stroke","withContainer","partialMargin","margin","layers","useDimensions","outerWidth","outerHeight","innerWidth","innerHeight","layerById","containerWidth","containerHeight","layer","createElement","ResponsiveWaffle","style","top","left","background","boxSizing","borderStyle","ResponsiveWaffleHtml","_slicedToArray","arrayWithHoles","_arr","_n","_d","_e","undefined","_s","_i","next","done","err","iterableToArrayLimit","nonIterableRest","CellTooltip","enableChip","findCellUnderCursor","isCursorInRect","onMouseMove","onClick","tooltip","canvasEl","useRef","useEffect","ctx","legend","renderLegendToCanvas","handleClick","useCallback","getRelativeCursor","useTooltip","showTooltipFromEvent","hideTooltip","TooltipComponent","handleMouseHover","isDataCell","handleMouseLeave","ref","cursor","onMouseEnter","onMouseLeave","ResponsiveWaffleCanvas"],"mappings":"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","file":"638c3b18840322299908ff491e302aba29258b71-5f7a06de225aaf7cfa03.js","sourcesContent":["import { motionDefaultProps } from '@nivo/core'\n// @ts-ignore\nimport { OrdinalColorScaleConfigScheme, InheritedColorConfigFromContext } from '@nivo/colors'\nimport { FillDirection } from './types'\n\nexport const defaultProps = {\n    // hiddenIds: [],\n    fillDirection: 'bottom' as FillDirection,\n    padding: 1,\n    colors: { scheme: 'nivo' } as OrdinalColorScaleConfigScheme,\n    emptyColor: '#cccccc',\n    emptyOpacity: 1,\n    borderWidth: 0,\n    borderColor: { from: 'color', modifiers: [['darker', 1]] } as InheritedColorConfigFromContext,\n    defs: [],\n    fill: [],\n    isInteractive: true,\n    legends: [],\n    animate: motionDefaultProps.animate,\n    motionConfig: motionDefaultProps.config,\n    role: 'img',\n    pixelRatio: typeof window !== 'undefined' ? window.devicePixelRatio ?? 1 : 1,\n}\n","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import defineProperty from \"./defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}","import { useMemo } from 'react'\nimport { range } from 'lodash'\n// @ts-ignore\nimport { useTheme, useValueFormatter } from '@nivo/core'\nimport { useInheritedColor, useOrdinalColorScale } from '@nivo/colors'\nimport {\n    CommonProps,\n    ComputedDatum,\n    Datum,\n    DefaultRawDatum,\n    DataProps,\n    FillDirection,\n    EmptyCell,\n    Cell,\n    DataCell,\n} from './types'\nimport { defaultProps } from './props'\n\n/**\n * Computes optimal cell size according to dimensions/layout/padding.\n */\nexport const computeCellSize = (\n    width: number,\n    height: number,\n    rows: number,\n    columns: number,\n    padding: number\n) => {\n    const sizeX = (width - (columns - 1) * padding) / columns\n    const sizeY = (height - (rows - 1) * padding) / rows\n\n    return Math.min(sizeX, sizeY)\n}\n\n/**\n * Computes empty cells according to dimensions/layout/padding.\n * At this stage the cells aren't bound to any data.\n */\nexport const computeGrid = (\n    width: number,\n    height: number,\n    rows: number,\n    columns: number,\n    fillDirection: FillDirection,\n    padding: number,\n    emptyColor: string\n) => {\n    const cellSize = computeCellSize(width, height, rows, columns, padding)\n\n    const cells: EmptyCell[] = []\n    switch (fillDirection) {\n        case 'top':\n            range(rows).forEach(row => {\n                range(columns).forEach(column => {\n                    cells.push({\n                        position: row * columns + column,\n                        row,\n                        column,\n                        x: column * (cellSize + padding),\n                        y: row * (cellSize + padding),\n                        color: emptyColor,\n                    })\n                })\n            })\n            break\n\n        case 'bottom':\n            range(rows - 1, -1).forEach(row => {\n                range(columns).forEach(column => {\n                    cells.push({\n                        position: row * columns + column,\n                        row,\n                        column,\n                        x: column * (cellSize + padding),\n                        y: row * (cellSize + padding),\n                        color: emptyColor,\n                    })\n                })\n            })\n            break\n\n        case 'left':\n            range(columns).forEach(column => {\n                range(rows).forEach(row => {\n                    cells.push({\n                        position: row * columns + column,\n                        row,\n                        column,\n                        x: column * (cellSize + padding),\n                        y: row * (cellSize + padding),\n                        color: emptyColor,\n                    })\n                })\n            })\n            break\n\n        case 'right':\n            range(columns - 1, -1).forEach(column => {\n                range(rows - 1, -1).forEach(row => {\n                    cells.push({\n                        position: row * columns + column,\n                        row,\n                        column,\n                        x: column * (cellSize + padding),\n                        y: row * (cellSize + padding),\n                        color: emptyColor,\n                    })\n                })\n            })\n            break\n\n        default:\n            throw new Error(`Invalid fill direction provided: ${fillDirection}`)\n    }\n\n    const origin = {\n        x: (width - (cellSize * columns + padding * (columns - 1))) / 2,\n        y: (height - (cellSize * rows + padding * (rows - 1))) / 2,\n    }\n\n    return { cells, cellSize, origin }\n}\n\nexport const useWaffle = <RawDatum extends Datum = DefaultRawDatum>({\n    width,\n    height,\n    data,\n    valueFormat,\n    total,\n    rows,\n    columns,\n    fillDirection = defaultProps.fillDirection,\n    padding = defaultProps.padding,\n    colors = defaultProps.colors,\n    emptyColor = defaultProps.emptyColor,\n    borderColor = defaultProps.borderColor,\n}: Pick<\n    CommonProps<RawDatum>,\n    'valueFormat' | 'fillDirection' | 'padding' | 'colors' | 'emptyColor' | 'borderColor'\n> &\n    DataProps<RawDatum> & {\n        width: number\n        height: number\n    }) => {\n    const formatValue = useValueFormatter(valueFormat as any)\n\n    const getColor = useOrdinalColorScale<RawDatum>(colors, 'id')\n    const theme = useTheme()\n    const getBorderColor = useInheritedColor<Cell<RawDatum>>(borderColor, theme)\n\n    const unit = total / (rows * columns)\n\n    const grid = useMemo(\n        () => computeGrid(width, height, rows, columns, fillDirection, padding, emptyColor),\n        [width, height, rows, columns, fillDirection, padding, emptyColor]\n    )\n\n    const computedData: Array<ComputedDatum<RawDatum>> = useMemo(() => {\n        let currentPosition = 0\n\n        return data.map((datum, groupIndex) => {\n            const enhancedDatum: ComputedDatum<RawDatum> = {\n                id: datum.id,\n                label: datum.label,\n                value: datum.value,\n                formattedValue: formatValue(datum.value),\n                groupIndex,\n                startAt: currentPosition,\n                endAt: currentPosition + Math.round(datum.value / unit),\n                color: getColor(datum),\n                data: datum,\n            }\n\n            currentPosition = enhancedDatum.endAt\n\n            return enhancedDatum\n\n            /*\n            if (!hiddenIds.includes(datum.id)) {\n                const enhancedDatum = {\n                    ...datum,\n                    groupIndex,\n                    startAt: currentPosition,\n                    endAt: currentPosition + Math.round(datum.value / unit),\n                    color: getColor(datum),\n                }\n\n                currentPosition = enhancedDatum.endAt\n\n                return enhancedDatum\n            }\n\n            return {\n                ...datum,\n                groupIndex,\n                startAt: currentPosition,\n                endAt: currentPosition,\n                color: getColor(datum),\n            }\n             */\n        })\n    }, [data, formatValue, getColor, unit])\n\n    const legendData = useMemo(\n        () =>\n            computedData.map(datum => ({\n                id: datum.id,\n                label: datum.id,\n                color: datum.color,\n                // fill: datum.fill,\n            })),\n        [computedData]\n    )\n\n    return {\n        grid,\n        computedData,\n        legendData,\n        getBorderColor,\n    }\n}\n\nexport const mergeCellsData = <RawDatum extends Datum>(\n    cells: EmptyCell[],\n    data: ComputedDatum<RawDatum>[]\n) => {\n    const cellsCopy: Cell<RawDatum>[] = cells.map(cell => ({ ...cell }))\n\n    data.forEach(datum => {\n        range(datum.startAt, datum.endAt).forEach(position => {\n            const cell = cellsCopy[position]\n            if (cell !== undefined) {\n                const cellWithData = cell as DataCell<RawDatum>\n                cellWithData.data = datum\n                cellWithData.color = datum.color\n            }\n        })\n    }, [])\n\n    return cellsCopy\n}\n\nexport const useMergeCellsData = <RawDatum extends Datum = DefaultRawDatum>(\n    cells: EmptyCell[],\n    data: ComputedDatum<RawDatum>[]\n) => useMemo(() => {\n    console.log('merge cells data')\n    return mergeCellsData(cells, data)\n}, [cells, data])\n","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayLikeToArray from \"./arrayLikeToArray\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","import arrayWithoutHoles from \"./arrayWithoutHoles\";\nimport iterableToArray from \"./iterableToArray\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray\";\nimport nonIterableSpread from \"./nonIterableSpread\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import React, { useMemo } from 'react'\nimport { useSpring, useTransition, animated } from 'react-spring'\n// @ts-ignore\nimport { useMotionConfig } from '@nivo/core'\nimport { Cell, ComputedDatum, Datum, EmptyCell } from './types'\nimport { useMergeCellsData } from './hooks'\n\ninterface CellsSvgProps<RawDatum extends Datum> {\n    cells: EmptyCell[]\n    computedData: ComputedDatum<RawDatum>[]\n    cellSize: number\n    origin: {\n        x: number\n        y: number\n    }\n    borderWidth: number\n    getBorderColor: (cell: Cell<RawDatum>) => string\n}\n\nexport const CellsSvg = <RawDatum extends Datum>({\n    cells,\n    computedData,\n    cellSize,\n    origin,\n    borderWidth,\n    getBorderColor,\n}: CellsSvgProps<RawDatum>) => {\n    console.log('render')\n    const mergedCells = useMergeCellsData<RawDatum>(cells, computedData)\n\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const reversed = useMemo(() => {\n        console.log('reverse')\n        const r = [...mergedCells]\n        r.reverse()\n\n        return r\n    }, [mergedCells])\n\n    const transitions = useTransition(\n        reversed,\n        cell => cell.position,\n        {\n            from: cell => {\n                return {\n                    color: cell.color,\n                    opacity: 1,\n                    borderColor: getBorderColor(cell),\n                    x: cell.x + origin.x,\n                    y: cell.y + origin.y,\n                }\n            },\n            enter: cell => {\n                return {\n                    color: cell.color,\n                    opacity: 1,\n                    borderColor: getBorderColor(cell),\n                    x: cell.x + origin.x,\n                    y: cell.y + origin.y,\n                }\n            },\n            update: cell => {\n                return {\n                    color: cell.color,\n                    opacity: 1,\n                    borderColor: getBorderColor(cell),\n                    x: cell.x + origin.x,\n                    y: cell.y + origin.y,\n                }\n            },\n            leave: cell => {\n                return {\n                    color: cell.color,\n                    opacity: 0,\n                    borderColor: getBorderColor(cell),\n                    x: cell.x + origin.x,\n                    y: cell.y + origin.y,\n                }\n            },\n            unique: true,\n            reset: true,\n            //trail: 2,\n            config: springConfig,\n            immediate: !animate,\n        }\n    )\n\n    /*\n    const commonAnimatedProps = useSpring({\n        cellSize,\n        borderWidth,\n        config: springConfig,\n        immediate: !animate,\n    })\n     */\n\n    return (\n        <g>\n            {transitions.map(({ item: cell, key, props }) => {\n                return (\n                    <animated.rect\n                        key={key}\n                        x={props.x}\n                        y={props.y}\n                        opacity={props.opacity}\n                        width={cellSize} //commonAnimatedProps.cellSize}\n                        height={cellSize} //commonAnimatedProps.cellSize}\n                        fill={props.color}\n                        stroke={props.borderColor}\n                        //strokeWidth={commonAnimatedProps.borderWidth}\n                    />\n                )\n            })}\n        </g>\n    )\n}\n","import React, { createElement, Fragment, ReactNode } from 'react'\n// @ts-ignore\nimport { SvgWrapper, withContainer, useDimensions } from '@nivo/core'\nimport { BoxLegendSvg } from '@nivo/legends'\nimport { Datum, DefaultRawDatum, SvgProps, LayerId } from './types'\nimport { defaultProps } from './props'\nimport { useWaffle } from './hooks'\nimport { CellsSvg } from './CellsSvg'\n\nconst Waffle = <RawDatum extends Datum = DefaultRawDatum>({\n    width,\n    height,\n    margin: partialMargin,\n    data,\n    valueFormat,\n    total,\n    rows,\n    columns,\n    fillDirection = defaultProps.fillDirection,\n    padding = defaultProps.padding,\n    layers = ['cells', 'legends'],\n    colors = defaultProps.colors,\n    emptyColor = defaultProps.emptyColor,\n    // emptyOpacity = defaultProps.emptyOpacity,\n    borderWidth = defaultProps.borderWidth,\n    borderColor = defaultProps.borderColor,\n    // defs = defaultProps.defs,\n    // fill = defaultProps.fill,\n    // isInteractive = defaultProps.isInteractive,\n    legends = defaultProps.legends,\n    role = defaultProps.role,\n}: SvgProps<RawDatum>) => {\n    const { outerWidth, outerHeight, margin, innerWidth, innerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n\n    const { grid, computedData, legendData, getBorderColor } = useWaffle<RawDatum>({\n        width: innerWidth,\n        height: innerHeight,\n        data,\n        valueFormat,\n        total,\n        rows,\n        columns,\n        fillDirection,\n        padding,\n        colors,\n        emptyColor,\n        borderColor,\n    })\n\n    const layerById: Record<LayerId, ReactNode> = {\n        cells: null,\n        legends: null,\n    }\n\n    if (layers.includes('cells')) {\n        layerById.cells = (\n            <CellsSvg<RawDatum>\n                key=\"cells\"\n                cells={grid.cells}\n                computedData={computedData}\n                cellSize={grid.cellSize}\n                origin={grid.origin}\n                borderWidth={borderWidth}\n                getBorderColor={getBorderColor}\n            />\n        )\n    }\n\n    if (layers.includes('legends')) {\n        layerById.legends = (\n            <g key=\"legends\">\n                {legends.map((legend, i) => (\n                    <BoxLegendSvg\n                        key={i}\n                        {...legend}\n                        containerWidth={width}\n                        containerHeight={height}\n                        data={legendData}\n                    />\n                ))}\n            </g>\n        )\n    }\n\n    return (\n        <SvgWrapper\n            width={outerWidth}\n            height={outerHeight}\n            margin={margin}\n            //defs={boundDefs}\n            role={role}\n        >\n            {layers.map((layer, i) => {\n                if (layerById[layer as LayerId] !== undefined) {\n                    return layerById[layer as LayerId]\n                }\n\n                if (typeof layer === 'function') {\n                    return <Fragment key={i}>{createElement(layer)}</Fragment>\n                }\n\n                return null\n            })}\n        </SvgWrapper>\n    )\n}\n\nexport default withContainer(Waffle) as <RawDatum extends Datum = DefaultRawDatum>(\n    props: SvgProps<RawDatum>\n) => JSX.Element\n\n/*\nexport class Waffle extends Component {\n    static propTypes = WafflePropTypes\n\n\n    render() {\n        const {\n            hiddenIds,\n\n            // dimensions\n            margin,\n            width,\n            height,\n            outerWidth,\n            outerHeight,\n\n            // styling\n            cellComponent,\n            emptyColor,\n            emptyOpacity,\n            borderWidth,\n            getBorderColor,\n            theme,\n            defs,\n\n            // motion\n            animate,\n            motionStiffness,\n            motionDamping,\n\n            // interactivity\n            isInteractive,\n            onClick,\n\n            // computed\n            cells,\n            cellSize,\n            origin,\n            computedData,\n            legendData,\n\n            legends,\n            role,\n        } = this.props\n\n        cells.forEach(cell => {\n            cell.color = emptyColor\n        })\n\n        return (\n            <Container\n                isInteractive={isInteractive}\n                theme={theme}\n                animate={animate}\n                motionDamping={motionDamping}\n                motionStiffness={motionStiffness}\n            >\n                {({ showTooltip, hideTooltip }) => {\n                    const onHover = partial(this.handleCellHover, showTooltip)\n                    const onLeave = partial(this.handleCellLeave, hideTooltip)\n\n                    let cellsRender\n                    if (animate === true) {\n                        const springConfig = {\n                            stiffness: motionStiffness,\n                            damping: motionDamping,\n                        }\n\n                        cellsRender = (\n                            <TransitionMotion\n                                styles={computedData.map(datum => ({\n                                    key: datum.id,\n                                    data: datum,\n                                    style: {\n                                        startAt: spring(datum.startAt, springConfig),\n                                        endAt: spring(datum.endAt, springConfig),\n                                    },\n                                }))}\n                            >\n                                {interpolatedStyles => {\n                                    const computedCells = applyDataToGrid(\n                                        cells,\n                                        interpolatedStyles.map(s => ({\n                                            ...s.data,\n                                            startAt: Math.round(s.style.startAt),\n                                            endAt: Math.round(s.style.endAt),\n                                        })),\n                                        hiddenIds\n                                    )\n\n                                    return (\n                                        <Fragment>\n                                            {computedCells.map(cell =>\n                                                React.createElement(cellComponent, {\n                                                    key: cell.position,\n                                                    position: cell.position,\n                                                    size: cellSize,\n                                                    x: cell.x,\n                                                    y: cell.y,\n                                                    color: cell.color,\n                                                    fill: cell.data && cell.data.fill,\n                                                    opacity: cell.data ? 1 : emptyOpacity,\n                                                    borderWidth,\n                                                    borderColor: getBorderColor(cell),\n                                                    data: cell.data,\n                                                    onHover: partial(onHover, cell),\n                                                    onLeave,\n                                                    onClick,\n                                                })\n                                            )}\n                                        </Fragment>\n                                    )\n                                }}\n                            </TransitionMotion>\n                        )\n                    } else {\n                        const computedCells = applyDataToGrid(cells, computedData, hiddenIds)\n\n                        cellsRender = (\n                            <Fragment>\n                                {computedCells.map(cell =>\n                                    React.createElement(cellComponent, {\n                                        key: cell.position,\n                                        position: cell.position,\n                                        size: cellSize,\n                                        x: cell.x,\n                                        y: cell.y,\n                                        color: cell.color,\n                                        fill: cell.data && cell.data.fill,\n                                        opacity: cell.data ? 1 : emptyOpacity,\n                                        borderWidth,\n                                        borderColor: getBorderColor(cell),\n                                        data: cell.data,\n                                        onHover: partial(onHover, cell),\n                                        onLeave,\n                                        onClick,\n                                    })\n                                )}\n                            </Fragment>\n                        )\n                    }\n\n                    return (\n                        <SvgWrapper\n                            width={outerWidth}\n                            height={outerHeight}\n                            margin={margin}\n                            defs={defs}\n                            theme={theme}\n                            role={role}\n                        >\n                            <g transform={`translate(${origin.x}, ${origin.y})`}>{cellsRender}</g>\n                            {legends.map((legend, i) => (\n                                <BoxLegendSvg\n                                    key={i}\n                                    {...legend}\n                                    containerWidth={width}\n                                    containerHeight={height}\n                                    data={legendData}\n                                    theme={theme}\n                                />\n                            ))}\n                        </SvgWrapper>\n                    )\n                }}\n            </Container>\n        )\n    }\n}\n*/\n","import React from 'react'\n// @ts-ignore\nimport { ResponsiveWrapper } from '@nivo/core'\nimport { SvgProps, Datum, DefaultRawDatum } from './types'\nimport Waffle from './Waffle'\n\nexport const ResponsiveWaffle = <RawDatum extends Datum = DefaultRawDatum>(\n    props: Omit<SvgProps<RawDatum>, 'width' | 'height'>\n) => (\n    <ResponsiveWrapper>\n        {({ width, height }: { width: number; height: number }) => (\n            <Waffle<RawDatum> width={width} height={height} {...props} />\n        )}\n    </ResponsiveWrapper>\n)\n","import React, { createElement, Fragment, ReactNode } from 'react'\n// @ts-ignore\nimport { withContainer, useDimensions } from '@nivo/core'\nimport { Datum, DefaultRawDatum, HtmlProps, HtmlLayerId } from './types'\nimport { defaultProps } from './props'\nimport { useWaffle, useMergeCellsData } from './hooks'\n\nconst WaffleHtml = <RawDatum extends Datum = DefaultRawDatum>({\n    width,\n    height,\n    margin: partialMargin,\n    data,\n    valueFormat,\n    total,\n    rows,\n    columns,\n    fillDirection = defaultProps.fillDirection,\n    padding = defaultProps.padding,\n    layers = ['cells'],\n    colors = defaultProps.colors,\n    emptyColor = defaultProps.emptyColor,\n    // emptyOpacity = defaultProps.emptyOpacity,\n    borderWidth = defaultProps.borderWidth,\n    borderColor = defaultProps.borderColor,\n    // isInteractive = defaultProps.isInteractive,\n    role = defaultProps.role,\n}: HtmlProps<RawDatum>) => {\n    const { outerWidth, outerHeight, margin, innerWidth, innerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n\n    const { grid, computedData, getBorderColor } = useWaffle<RawDatum>({\n        width: innerWidth,\n        height: innerHeight,\n        data,\n        valueFormat,\n        total,\n        rows,\n        columns,\n        fillDirection,\n        padding,\n        colors,\n        emptyColor,\n        borderColor,\n    })\n\n    const mergedCells = useMergeCellsData<RawDatum>(grid.cells, computedData)\n\n    const layerById: Record<HtmlLayerId, ReactNode> = {\n        cells: null,\n    }\n\n    if (layers.includes('cells')) {\n        layerById.cells = (\n            <div\n                key=\"cells\"\n                style={{\n                    position: 'absolute',\n                    top: margin.top + grid.origin.y,\n                    left: margin.left + grid.origin.x,\n                }}\n            >\n                {mergedCells.map(cell => {\n                    return (\n                        <div\n                            key={cell.position}\n                            style={{\n                                position: 'absolute',\n                                top: cell.y,\n                                left: cell.x,\n                                width: grid.cellSize,\n                                height: grid.cellSize,\n                                background: cell.color,\n                                // opacity: ,\n                                boxSizing: 'content-box',\n                                borderStyle: 'solid',\n                                borderWidth: `${borderWidth}px`,\n                                borderColor: getBorderColor(cell),\n                            }}\n                        />\n                    )\n                })}\n            </div>\n        )\n    }\n\n    return (\n        <div\n            style={{\n                position: 'relative',\n                width: outerWidth,\n                height: outerHeight,\n            }}\n            role={role}\n        >\n            {layers.map((layer, i) => {\n                if (layerById[layer as HtmlLayerId] !== undefined) {\n                    return layerById[layer as HtmlLayerId]\n                }\n\n                if (typeof layer === 'function') {\n                    return <Fragment key={i}>{createElement(layer)}</Fragment>\n                }\n\n                return null\n            })}\n        </div>\n    )\n}\n\nexport default withContainer(WaffleHtml) as <RawDatum extends Datum = DefaultRawDatum>(\n    props: HtmlProps<RawDatum>\n) => JSX.Element\n\n/*\nimport React, { Component, Fragment } from 'react'\nimport partial from 'lodash.partial'\nimport setDisplayName from 'recompose/setDisplayName'\nimport { TransitionMotion, spring } from 'react-motion'\nimport { Container } from '@nivo/core'\nimport enhance from './enhance'\nimport { WaffleHtmlPropTypes } from './props'\nimport { applyDataToGrid } from './compute'\nimport WaffleCellTooltip from './WaffleCellTooltip'\n\nclass WaffleHtml extends Component {\n    static propTypes = WaffleHtmlPropTypes\n\n    handleCellHover = (showTooltip, cell, event) => {\n        const { setCurrentCell, theme, tooltipFormat, tooltip } = this.props\n\n        setCurrentCell(cell)\n\n        if (!cell.data) return\n\n        showTooltip(\n            <WaffleCellTooltip\n                position={cell.position}\n                row={cell.row}\n                column={cell.column}\n                color={cell.color}\n                data={cell.data}\n                theme={theme}\n                tooltipFormat={tooltipFormat}\n                tooltip={tooltip}\n            />,\n            event\n        )\n    }\n\n    handleCellLeave = hideTooltip => {\n        this.props.setCurrentCell(null)\n        hideTooltip()\n    }\n\n    render() {\n        const {\n            // dimensions\n            margin,\n            outerWidth,\n            outerHeight,\n\n            // styling\n            cellComponent,\n            emptyColor,\n            emptyOpacity,\n            borderWidth,\n            getBorderColor,\n            theme,\n\n            // motion\n            animate,\n            motionStiffness,\n            motionDamping,\n\n            // interactivity\n            isInteractive,\n            onClick,\n\n            // computed\n            cells,\n            cellSize,\n            origin,\n            computedData,\n        } = this.props\n\n        cells.forEach(cell => {\n            cell.color = emptyColor\n        })\n\n        return (\n            <Container\n                isInteractive={isInteractive}\n                theme={theme}\n                animate={animate}\n                motionDamping={motionDamping}\n                motionStiffness={motionStiffness}\n            >\n                {({ showTooltip, hideTooltip }) => {\n                    const onHover = partial(this.handleCellHover, showTooltip)\n                    const onLeave = partial(this.handleCellLeave, hideTooltip)\n\n                    let cellsRender\n                    if (animate === true) {\n                        const springConfig = {\n                            stiffness: motionStiffness,\n                            damping: motionDamping,\n                        }\n\n                        cellsRender = (\n                            <TransitionMotion\n                                styles={computedData.map(datum => ({\n                                    key: datum.id,\n                                    data: datum,\n                                    style: {\n                                        startAt: spring(datum.startAt, springConfig),\n                                        endAt: spring(datum.endAt, springConfig),\n                                    },\n                                }))}\n                            >\n                                {interpolatedStyles => {\n                                    const computedCells = applyDataToGrid(\n                                        cells,\n                                        interpolatedStyles.map(s => ({\n                                            ...s.data,\n                                            startAt: Math.round(s.style.startAt),\n                                            endAt: Math.round(s.style.endAt),\n                                        }))\n                                    )\n\n                                    return (\n                                        <Fragment>\n                                            {computedCells.map(cell =>\n                                                React.createElement(cellComponent, {\n                                                    key: cell.position,\n                                                    position: cell.position,\n                                                    size: cellSize,\n                                                    x: cell.x,\n                                                    y: cell.y,\n                                                    color: cell.color,\n                                                    fill: cell.data && cell.data.fill,\n                                                    opacity: cell.data ? 1 : emptyOpacity,\n                                                    borderWidth,\n                                                    borderColor: getBorderColor(cell),\n                                                    data: cell.data,\n                                                    onHover: partial(onHover, cell),\n                                                    onLeave,\n                                                    onClick,\n                                                })\n                                            )}\n                                        </Fragment>\n                                    )\n                                }}\n                            </TransitionMotion>\n                        )\n                    } else {\n                        const computedCells = applyDataToGrid(cells, computedData)\n\n                        cellsRender = (\n                            <Fragment>\n                                {computedCells.map(cell =>\n                                    React.createElement(cellComponent, {\n                                        key: cell.position,\n                                        position: cell.position,\n                                        size: cellSize,\n                                        x: cell.x,\n                                        y: cell.y,\n                                        color: cell.color,\n                                        fill: cell.data && cell.data.fill,\n                                        opacity: cell.data ? 1 : emptyOpacity,\n                                        borderWidth,\n                                        borderColor: getBorderColor(cell),\n                                        data: cell.data,\n                                        onHover: partial(onHover, cell),\n                                        onLeave,\n                                        onClick,\n                                    })\n                                )}\n                            </Fragment>\n                        )\n                    }\n\n                    return (\n                        <div\n                            style={{\n                                position: 'relative',\n                                width: outerWidth,\n                                height: outerHeight,\n                            }}\n                        >\n                            <div\n                                style={{\n                                    position: 'absolute',\n                                    top: margin.top + origin.y,\n                                    left: margin.left + origin.x,\n                                }}\n                            >\n                                {cellsRender}\n                            </div>\n                        </div>\n                    )\n                }}\n            </Container>\n        )\n    }\n}\n\nWaffleHtml.displayName = 'WaffleHtml'\n\nexport default setDisplayName(WaffleHtml.displayName)(enhance(WaffleHtml))\n */\n","import React from 'react'\n// @ts-ignore\nimport { ResponsiveWrapper } from '@nivo/core'\nimport WaffleHtml from './WaffleHtml'\nimport { Datum, DefaultRawDatum, HtmlProps } from './types'\n\nexport const ResponsiveWaffleHtml = <RawDatum extends Datum = DefaultRawDatum>(\n    props: Omit<HtmlProps<RawDatum>, 'width' | 'height'>\n) => (\n    <ResponsiveWrapper>\n        {({ width, height }: { width: number; height: number }) => (\n            <WaffleHtml<RawDatum> width={width} height={height} {...props} />\n        )}\n    </ResponsiveWrapper>\n)\n","import arrayWithHoles from \"./arrayWithHoles\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray\";\nimport nonIterableRest from \"./nonIterableRest\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import React from 'react'\nimport { BasicTooltip } from '@nivo/tooltip'\nimport { DataCell, Datum } from './types'\n\nexport interface TooltipProps<RawDatum extends Datum> {\n    cell: DataCell<RawDatum>\n}\n\nexport const CellTooltip = <RawDatum extends Datum>({ cell }: TooltipProps<RawDatum>) => (\n    <BasicTooltip\n        id={cell.data.label}\n        value={cell.data.formattedValue}\n        enableChip={true}\n        color={cell.data.color}\n    />\n)\n","import React, { useEffect, useRef, useCallback, createElement } from 'react'\nimport {\n    // @ts-ignore\n    withContainer,\n    useDimensions,\n    // @ts-ignore\n    useTheme,\n    // @ts-ignore\n    isCursorInRect,\n    // @ts-ignore\n    getRelativeCursor,\n} from '@nivo/core'\n// @ts-ignore\nimport { renderLegendToCanvas } from '@nivo/legends'\nimport { useTooltip } from '@nivo/tooltip'\nimport { Datum, DefaultRawDatum, CanvasProps, Cell, isDataCell } from './types'\nimport { defaultProps } from './props'\nimport { useWaffle, useMergeCellsData } from './hooks'\nimport { CellTooltip, TooltipProps } from './CellTooltip'\n\nconst findCellUnderCursor = <RawDatum extends Datum>(\n    cells: Cell<RawDatum>[],\n    cellSize: number,\n    padding: number,\n    origin: {\n        x: number\n        y: number\n    },\n    margin: {\n        top: number\n        right: number\n        bottom: number\n        left: number\n    },\n    x: number,\n    y: number\n) =>\n    cells.find(cell =>\n        isCursorInRect(\n            cell.x + origin.x + margin.left,\n            cell.y + origin.y + margin.top,\n            cellSize + padding,\n            cellSize + padding,\n            x,\n            y\n        )\n    )\n\nconst WaffleCanvas = <RawDatum extends Datum = DefaultRawDatum>({\n    width,\n    height,\n    margin: partialMargin,\n    data,\n    valueFormat,\n    total,\n    rows,\n    columns,\n    fillDirection = defaultProps.fillDirection,\n    padding = defaultProps.padding,\n    colors = defaultProps.colors,\n    emptyColor = defaultProps.emptyColor,\n    // emptyOpacity = defaultProps.emptyOpacity,\n    borderWidth = defaultProps.borderWidth,\n    borderColor = defaultProps.borderColor,\n    isInteractive = defaultProps.isInteractive,\n    onMouseMove,\n    onClick,\n    tooltip = CellTooltip,\n    legends = defaultProps.legends,\n    role = defaultProps.role,\n    pixelRatio = defaultProps.pixelRatio,\n}: CanvasProps<RawDatum>) => {\n    const canvasEl = useRef<HTMLCanvasElement | null>(null)\n    const theme = useTheme()\n\n    const { outerWidth, outerHeight, margin, innerWidth, innerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n\n    const { grid, computedData, legendData, getBorderColor } = useWaffle<RawDatum>({\n        width: innerWidth,\n        height: innerHeight,\n        data,\n        valueFormat,\n        total,\n        rows,\n        columns,\n        fillDirection,\n        padding,\n        colors,\n        emptyColor,\n        borderColor,\n    })\n\n    const mergedCells = useMergeCellsData<RawDatum>(grid.cells, computedData)\n\n    useEffect(() => {\n        if (!canvasEl.current) return\n\n        canvasEl.current.width = outerWidth * pixelRatio\n        canvasEl.current.height = outerHeight * pixelRatio\n\n        const ctx = canvasEl.current.getContext('2d')!\n\n        ctx.scale(pixelRatio, pixelRatio)\n\n        ctx.fillStyle = theme.background\n        ctx.fillRect(0, 0, outerWidth, outerHeight)\n\n        ctx.translate(margin.left, margin.top)\n\n        mergedCells.forEach(cell => {\n            ctx.save()\n            //ctx.globalAlpha = isCell ? 1 : emptyOpacity\n\n            ctx.fillStyle = cell.color\n            ctx.fillRect(\n                cell.x + grid.origin.x,\n                cell.y + grid.origin.y,\n                grid.cellSize,\n                grid.cellSize\n            )\n\n            if (borderWidth > 0) {\n                ctx.strokeStyle = getBorderColor(cell)\n                ctx.lineWidth = borderWidth\n                ctx.strokeRect(\n                    cell.x + grid.origin.x,\n                    cell.y + grid.origin.y,\n                    grid.cellSize,\n                    grid.cellSize\n                )\n            }\n\n            ctx.restore()\n        })\n\n        legends.forEach(legend => {\n            renderLegendToCanvas(ctx, {\n                ...legend,\n                data: legendData,\n                containerWidth: outerWidth,\n                containerHeight: outerHeight,\n                theme,\n            })\n        })\n    }, [\n        canvasEl,\n        pixelRatio,\n        theme,\n        outerWidth,\n        outerHeight,\n        margin,\n        legends,\n        legendData,\n        mergedCells,\n        grid,\n        borderWidth,\n        getBorderColor,\n    ])\n\n    const handleClick = useCallback(\n        (event: React.MouseEvent<HTMLCanvasElement>) => {\n            if (!onClick) return\n\n            const [x, y] = getRelativeCursor(canvasEl.current!, event)\n            const cell = findCellUnderCursor(\n                mergedCells,\n                grid.cellSize,\n                padding,\n                grid.origin,\n                margin,\n                x,\n                y\n            )\n            if (cell) {\n                onClick(cell, event)\n            }\n        },\n        [canvasEl, mergedCells, grid.origin, grid.cellSize, padding, margin]\n    )\n\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n\n    const TooltipComponent = tooltip as (props: TooltipProps<RawDatum>) => JSX.Element\n\n    const handleMouseHover = useCallback(\n        (event: React.MouseEvent<HTMLCanvasElement>) => {\n            const [x, y] = getRelativeCursor(canvasEl.current!, event)\n            const cell = findCellUnderCursor(\n                mergedCells,\n                grid.cellSize,\n                padding,\n                grid.origin,\n                margin,\n                x,\n                y\n            )\n\n            if (cell && isDataCell(cell)) {\n                showTooltipFromEvent(createElement(TooltipComponent, { cell }), event)\n            } else {\n                hideTooltip()\n            }\n\n            if (cell) {\n                onMouseMove?.(cell, event)\n            }\n        },\n        [\n            canvasEl,\n            mergedCells,\n            grid.origin,\n            grid.cellSize,\n            padding,\n            margin,\n            showTooltipFromEvent,\n            hideTooltip,\n            TooltipComponent,\n            onMouseMove,\n        ]\n    )\n\n    const handleMouseLeave = useCallback(() => {\n        hideTooltip()\n    }, [hideTooltip])\n\n    return (\n        <canvas\n            ref={canvasEl}\n            width={outerWidth * pixelRatio}\n            height={outerHeight * pixelRatio}\n            style={{\n                width: outerWidth,\n                height: outerHeight,\n                cursor: isInteractive ? 'auto' : 'normal',\n            }}\n            onMouseEnter={isInteractive ? handleMouseHover : undefined}\n            onMouseMove={isInteractive ? handleMouseHover : undefined}\n            onMouseLeave={isInteractive ? handleMouseLeave : undefined}\n            onClick={isInteractive ? handleClick : undefined}\n            role={role}\n        />\n    )\n}\n\nexport default withContainer(WaffleCanvas) as <RawDatum extends Datum = DefaultRawDatum>(\n    props: CanvasProps<RawDatum>\n) => JSX.Element\n","import * as React from 'react'\nimport { Box, Dimensions, Theme, SvgDefsAndFill, ModernMotionProps } from '@nivo/core'\nimport { InheritedColorConfig, OrdinalColorScaleConfig } from '@nivo/colors'\nimport { LegendProps } from '@nivo/legends'\nimport { TooltipProps } from './CellTooltip'\n\nexport type DatumId = string | number\nexport type DatumLabel = string | number\nexport type DatumValue = number\nexport type DatumFormattedValue = string | number\n\nexport interface Datum {\n    id: DatumId\n    label: DatumLabel\n    value: DatumValue\n}\n\nexport interface DefaultRawDatum extends Datum {\n    id: string\n    label: string\n    value: number\n}\n\nexport type ValueFormatter = (value: number) => DatumFormattedValue\n\nexport interface ComputedDatum<RawDatum> extends Datum {\n    formattedValue: DatumFormattedValue\n    groupIndex: number\n    // Index of the starting cell\n    startAt: number\n    // Index of the ending cell\n    endAt: number\n    color: string\n    fill?: string\n    data: RawDatum\n}\n\n// used for cells without data, considered empty\nexport interface EmptyCell {\n    position: number\n    row: number\n    column: number\n    x: number\n    y: number\n    color: string\n}\n\n// used for cells having data\nexport interface DataCell<RawDatum extends Datum> extends EmptyCell {\n    data: ComputedDatum<RawDatum>\n}\n\nexport type Cell<RawDatum extends Datum> = EmptyCell | DataCell<RawDatum>\n\nexport const isDataCell = <RawDatum extends Datum>(\n    cell: Cell<RawDatum>\n): cell is DataCell<RawDatum> => {\n    return (cell as DataCell<RawDatum>).data !== undefined\n}\n\nexport type FillDirection = 'top' | 'right' | 'bottom' | 'left'\n\n// all those props are required\nexport interface DataProps<RawDatum extends Datum> {\n    data: RawDatum[]\n    total: number\n    rows: number\n    columns: number\n}\n\n// most of those props are optional for the public API,\n// but required internally, using defaults.\nexport interface CommonProps<RawDatum extends Datum> {\n    margin: Box\n    valueFormat?: string | ValueFormatter\n    fillDirection: FillDirection\n    padding: number\n    theme: Theme\n    colors: OrdinalColorScaleConfig<RawDatum>\n    emptyColor: string\n    emptyOpacity: number\n    borderWidth: number\n    borderColor: InheritedColorConfig<Cell<RawDatum>>\n    isInteractive: boolean\n    tooltip: React.FC<TooltipProps<RawDatum>>\n    role: string\n}\n\nexport type MouseHandler<RawDatum extends Datum, ElementType = HTMLCanvasElement> = (\n    cell: Cell<RawDatum>,\n    event: React.MouseEvent<ElementType>\n) => void\n\ninterface MouseHandlers<RawDatum extends Datum, ElementType = HTMLCanvasElement> {\n    onClick?: MouseHandler<RawDatum, ElementType>\n    onMouseEnter?: MouseHandler<RawDatum, ElementType>\n    onMouseMove?: MouseHandler<RawDatum, ElementType>\n    onMouseLeave?: MouseHandler<RawDatum, ElementType>\n}\n\nexport type LayerId = 'cells' | 'legends'\n\nexport interface CustomLayerProps<RawDatum extends Datum> {\n    yay?: RawDatum\n}\n\nexport type SvgLayer<RawDatum extends Datum> = LayerId | React.FC<CustomLayerProps<RawDatum>>\n\nexport type SvgProps<RawDatum extends Datum = DefaultRawDatum> = DataProps<RawDatum> &\n    Dimensions &\n    Partial<CommonProps<RawDatum>> & {\n        layers?: SvgLayer<RawDatum>[]\n    } & ModernMotionProps &\n    SvgDefsAndFill<ComputedDatum<RawDatum>> & {\n        legends?: LegendProps[]\n    } & MouseHandlers<RawDatum>\n\nexport type HtmlLayerId = Exclude<LayerId, 'legends'>\n\nexport type HtmlLayer<RawDatum extends Datum> = HtmlLayerId | React.FC<CustomLayerProps<RawDatum>>\n\nexport type HtmlProps<RawDatum extends Datum = DefaultRawDatum> = DataProps<RawDatum> &\n    Dimensions &\n    Partial<CommonProps<RawDatum>> & {\n        layers?: HtmlLayer<RawDatum>[]\n    } & ModernMotionProps &\n    MouseHandlers<RawDatum>\n\nexport type CanvasProps<RawDatum extends Datum = DefaultRawDatum> = DataProps<RawDatum> &\n    Dimensions &\n    Partial<CommonProps<RawDatum>> & {\n        legends?: LegendProps[]\n    } & {\n        pixelRatio?: number\n    } & Omit<MouseHandlers<RawDatum>, 'onMouseEnter' | 'onMouseLeave'>\n","import React from 'react'\n// @ts-ignore\nimport { ResponsiveWrapper } from '@nivo/core'\nimport { CanvasProps, Datum, DefaultRawDatum } from './types'\nimport WaffleCanvas from './WaffleCanvas'\n\nexport const ResponsiveWaffleCanvas = <RawDatum extends Datum = DefaultRawDatum>(\n    props: Omit<CanvasProps<RawDatum>, 'width' | 'height'>\n) => (\n    <ResponsiveWrapper>\n        {({ width, height }: { width: number; height: number }) => (\n            <WaffleCanvas width={width} height={height} {...props} />\n        )}\n    </ResponsiveWrapper>\n)\n"],"sourceRoot":""}