{"version":3,"sources":["webpack:///../node_modules/lodash/_baseIsDate.js","webpack:///../node_modules/lodash/uniqBy.js","webpack:///./src/lib/settings.js","webpack:///../node_modules/lodash/isDate.js","webpack:///../node_modules/d3-scale/node_modules/d3-time/src/utcMonth.js","webpack:///../node_modules/d3-scale/node_modules/d3-time/src/utcHour.js","webpack:///../node_modules/d3-scale/node_modules/d3-time/src/utcMinute.js","webpack:///../src/linearScale.js","webpack:///../src/logScale.js","webpack:///../src/symlogScale.js","webpack:///../src/pointScale.js","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js","webpack:///../src/timeHelpers.js","webpack:///../src/timeScale.js","webpack:///../node_modules/d3-scale/src/utcTime.js","webpack:///../src/bandScale.js","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArray.js","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","webpack:///../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js","webpack:///../src/compute.js","webpack:///../src/index.js","webpack:///./src/data/components/scatterplot/mapper.js"],"names":["baseGetTag","isObjectLike","module","exports","value","baseIteratee","baseUniq","array","iteratee","length","settingsMapper","mapping","exclude","settings","options","overrides","Object","keys","forEach","key","omit","mapAxis","type","upperFirst","enable","mapFormat","format","enabled","undefined","baseIsDate","baseUnary","nodeUtil","nodeIsDate","isDate","utcMonth","interval","date","setUTCDate","setUTCHours","step","setUTCMonth","getUTCMonth","start","end","getUTCFullYear","range","utcHour","setUTCMinutes","setTime","duration","getUTCHours","utcMinute","setUTCSeconds","getUTCMinutes","linearScalePropTypes","PropTypes","min","max","stacked","reverse","clamp","nice","logScalePropTypes","base","symLogScalePropTypes","constant","pointScalePropTypes","isRequired","_defineProperty","obj","defineProperty","enumerable","configurable","writable","timePrecisions","precisionCutOffs","precisionCutOffsByType","createDateNormalizer","precision","useUTC","precisionFn","cutOff","createPrecisionMethod","v","parseTime","utcParse","timeParse","timeScale","axis","values","xy","size","normalize","minValue","maxValue","scale","init","apply","utcYear","utcWeek","utcDay","domain","Date","UTC","arguments","scaleUtc","scaleTime","timeScalePropTypes","bandScalePropTypes","round","bool","_arrayLikeToArray","arr","len","i","arr2","Array","_toConsumableArray","isArray","arrayLikeToArray","arrayWithoutHoles","iter","Symbol","iterator","from","iterableToArray","o","minLen","n","prototype","toString","call","slice","constructor","name","test","unsupportedIterableToArray","TypeError","nonIterableSpread","ownKeys","object","enumerableOnly","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","push","_objectSpread2","target","source","getOwnPropertyDescriptors","defineProperties","getOtherAxis","compareValues","a","compareDateValues","b","computeXYScalesForSeries","_series","series","serie","data","d","generateSeriesXY","xScaleSpec","stackX","yScaleSpec","stackY","xScale","computeScale","yScale","x","y","spec","scaleLinear","linearScale","scalePoint","pointScale","hasZero","hasMixedSign","sign","Math","scaleLog","logScale","scaleSymlog","symlogScale","generateSeriesAxis","getValue","setValue","scaleSpec","parseFloat","all","uniq","sortBy","uniqBy","last","stackAxis","otherAxis","compare","stack","datum","stackValue","head","scalePropType","axisTop","axisRight","axisBottom","axisLeft"],"mappings":"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","file":"67f3db2ee6971e0f728c1b048e60831158f21154-21362df90b312285f2f5.js","sourcesContent":["var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar dateTag = '[object Date]';\n\n/**\n * The base implementation of `_.isDate` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n */\nfunction baseIsDate(value) {\n  return isObjectLike(value) && baseGetTag(value) == dateTag;\n}\n\nmodule.exports = baseIsDate;\n","var baseIteratee = require('./_baseIteratee'),\n    baseUniq = require('./_baseUniq');\n\n/**\n * This method is like `_.uniq` except that it accepts `iteratee` which is\n * invoked for each element in `array` to generate the criterion by which\n * uniqueness is computed. The order of result values is determined by the\n * order they occur in the array. The iteratee is invoked with one argument:\n * (value).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n * @returns {Array} Returns the new duplicate free array.\n * @example\n *\n * _.uniqBy([2.1, 1.2, 2.3], Math.floor);\n * // => [2.1, 1.2]\n *\n * // The `_.property` iteratee shorthand.\n * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n * // => [{ 'x': 1 }, { 'x': 2 }]\n */\nfunction uniqBy(array, iteratee) {\n  return (array && array.length) ? baseUniq(array, baseIteratee(iteratee, 2)) : [];\n}\n\nmodule.exports = uniqBy;\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport omit from 'lodash/omit'\nimport upperFirst from 'lodash/upperFirst'\n\nexport const settingsMapper = (mapping, { exclude = [] } = {}) => (settings, options = {}) => {\n    const overrides = {}\n\n    Object.keys(settings).forEach(key => {\n        if (mapping[key]) {\n            overrides[key] = mapping[key](settings[key], settings, options)\n        }\n    })\n\n    return {\n        ...omit(settings, exclude),\n        ...overrides,\n    }\n}\n\nexport const mapAxis = type => (value, settings) =>\n    settings[`axis${upperFirst(type)}`].enable ? omit(value, ['enable']) : null\n\nexport const mapFormat = ({ format, enabled }) => (enabled === true ? format : undefined)\n","var baseIsDate = require('./_baseIsDate'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsDate = nodeUtil && nodeUtil.isDate;\n\n/**\n * Checks if `value` is classified as a `Date` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n * @example\n *\n * _.isDate(new Date);\n * // => true\n *\n * _.isDate('Mon April 23 2012');\n * // => false\n */\nvar isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;\n\nmodule.exports = isDate;\n","import interval from \"./interval.js\";\nvar utcMonth = interval(function (date) {\n  date.setUTCDate(1);\n  date.setUTCHours(0, 0, 0, 0);\n}, function (date, step) {\n  date.setUTCMonth(date.getUTCMonth() + step);\n}, function (start, end) {\n  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;\n}, function (date) {\n  return date.getUTCMonth();\n});\nexport default utcMonth;\nexport var utcMonths = utcMonth.range;","import interval from \"./interval.js\";\nimport { durationHour } from \"./duration.js\";\nvar utcHour = interval(function (date) {\n  date.setUTCMinutes(0, 0, 0);\n}, function (date, step) {\n  date.setTime(+date + step * durationHour);\n}, function (start, end) {\n  return (end - start) / durationHour;\n}, function (date) {\n  return date.getUTCHours();\n});\nexport default utcHour;\nexport var utcHours = utcHour.range;","import interval from \"./interval.js\";\nimport { durationMinute } from \"./duration.js\";\nvar utcMinute = interval(function (date) {\n  date.setUTCSeconds(0, 0);\n}, function (date, step) {\n  date.setTime(+date + step * durationMinute);\n}, function (start, end) {\n  return (end - start) / durationMinute;\n}, function (date) {\n  return date.getUTCMinutes();\n});\nexport default utcMinute;\nexport var utcMinutes = utcMinute.range;","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { scaleLinear } from 'd3-scale'\nimport PropTypes from 'prop-types'\n\nexport const linearScale = (\n    { axis, min = 0, max = 'auto', stacked = false, reverse = false, clamp = false, nice = false },\n    xy,\n    width,\n    height\n) => {\n    const values = xy[axis]\n    const size = axis === 'x' ? width : height\n\n    let minValue = min\n    if (min === 'auto') {\n        minValue = stacked === true ? values.minStacked : values.min\n    }\n    let maxValue = max\n    if (max === 'auto') {\n        maxValue = stacked === true ? values.maxStacked : values.max\n    }\n\n    const scale = scaleLinear().rangeRound(axis === 'x' ? [0, size] : [size, 0])\n\n    if (reverse === true) scale.domain([maxValue, minValue])\n    else scale.domain([minValue, maxValue])\n\n    if (nice === true) scale.nice()\n    else if (typeof nice === 'number') scale.nice(nice)\n\n    scale.type = 'linear'\n    scale.stacked = stacked\n    scale.clamp(clamp)\n\n    return scale\n}\n\nexport const linearScalePropTypes = {\n    type: PropTypes.oneOf(['linear']).isRequired,\n    min: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number]),\n    max: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number]),\n    stacked: PropTypes.bool,\n    reverse: PropTypes.bool,\n    clamp: PropTypes.bool,\n    nice: PropTypes.oneOfType([PropTypes.number, PropTypes.bool]),\n}\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { scaleLog } from 'd3-scale'\nimport PropTypes from 'prop-types'\n\nexport const logScale = ({ axis, base = 10, min = 'auto', max = 'auto' }, xy, width, height) => {\n    const values = xy[axis]\n    const size = axis === 'x' ? width : height\n\n    const hasZero = values.all.some(v => v === 0)\n    let sign\n    let hasMixedSign = false\n    values.all\n        .filter(v => v != null)\n        .forEach(v => {\n            if (hasMixedSign === true) return\n            if (sign === undefined) {\n                sign = Math.sign(v)\n            } else if (Math.sign(v) !== sign) {\n                hasMixedSign = true\n            }\n        })\n\n    if (hasZero || hasMixedSign) {\n        throw new Error(\n            [\n                `a log scale domain must be strictly-positive or strictly-negative,`,\n                `and must not include or cross zero.`,\n            ].join('\\n')\n        )\n    }\n\n    let minValue = min\n    if (min === 'auto') {\n        minValue = values.min\n    }\n    let maxValue = max\n    if (max === 'auto') {\n        maxValue = values.max\n    }\n\n    const scale = scaleLog()\n        .domain([minValue, maxValue])\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .base(base)\n        .nice()\n\n    scale.type = 'log'\n\n    return scale\n}\n\nexport const logScalePropTypes = {\n    type: PropTypes.oneOf(['log']).isRequired,\n    base: PropTypes.number,\n    min: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number]),\n    max: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number]),\n}\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { scaleSymlog } from 'd3-scale'\nimport PropTypes from 'prop-types'\n\nexport const symlogScale = (\n    { axis, constant = 1, min = 'auto', max = 'auto' },\n    xy,\n    width,\n    height\n) => {\n    const values = xy[axis]\n    const size = axis === 'x' ? width : height\n\n    let minValue = min\n    if (min === 'auto') {\n        minValue = values.min\n    }\n\n    let maxValue = max\n    if (max === 'auto') {\n        maxValue = values.max\n    }\n\n    const scale = scaleSymlog()\n        .domain([minValue, maxValue])\n        .constant(constant)\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .nice()\n\n    scale.type = 'symlog'\n\n    return scale\n}\n\nexport const symLogScalePropTypes = {\n    type: PropTypes.oneOf(['symlog']).isRequired,\n    constant: PropTypes.number,\n    min: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number]),\n    max: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number]),\n}\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { scalePoint } from 'd3-scale'\nimport PropTypes from 'prop-types'\n\nexport const pointScale = ({ axis }, xy, width, height) => {\n    const values = xy[axis]\n    const size = axis === 'x' ? width : height\n\n    const scale = scalePoint().range([0, size]).domain(values.all)\n\n    scale.type = 'point'\n\n    return scale\n}\n\nexport const pointScalePropTypes = {\n    type: PropTypes.oneOf(['point']).isRequired,\n}\n","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { timeParse, utcParse } from 'd3-time-format'\n\nexport const TIME_PRECISION_MILLISECOND = 'millisecond'\nexport const TIME_PRECISION_SECOND = 'second'\nexport const TIME_PRECISION_MINUTE = 'minute'\nexport const TIME_PRECISION_HOUR = 'hour'\nexport const TIME_PRECISION_DAY = 'day'\nexport const TIME_PRECISION_MONTH = 'month'\nexport const TIME_PRECISION_YEAR = 'year'\n\nexport const timePrecisions = [\n    TIME_PRECISION_MILLISECOND,\n    TIME_PRECISION_SECOND,\n    TIME_PRECISION_MINUTE,\n    TIME_PRECISION_HOUR,\n    TIME_PRECISION_DAY,\n    TIME_PRECISION_MONTH,\n    TIME_PRECISION_YEAR,\n]\n\nexport const precisionCutOffs = [\n    date => date.setMilliseconds(0),\n    date => date.setSeconds(0),\n    date => date.setMinutes(0),\n    date => date.setHours(0),\n    date => date.setDate(1),\n    date => date.setMonth(0),\n]\n\nexport const precisionCutOffsByType = {\n    [TIME_PRECISION_MILLISECOND]: [],\n    [TIME_PRECISION_SECOND]: precisionCutOffs.slice(0, 1),\n    [TIME_PRECISION_MINUTE]: precisionCutOffs.slice(0, 2),\n    [TIME_PRECISION_HOUR]: precisionCutOffs.slice(0, 3),\n    [TIME_PRECISION_DAY]: precisionCutOffs.slice(0, 4),\n    [TIME_PRECISION_MONTH]: precisionCutOffs.slice(0, 5),\n    [TIME_PRECISION_YEAR]: precisionCutOffs.slice(0, 6),\n}\n\nexport const createPrecisionMethod = precision => date => {\n    precisionCutOffsByType[precision].forEach(cutOff => {\n        cutOff(date)\n    })\n    return date\n}\n\nexport const createDateNormalizer = ({\n    format = 'native',\n    precision = 'millisecond',\n    useUTC = true,\n}) => {\n    const precisionFn = createPrecisionMethod(precision)\n    if (format === 'native') return v => precisionFn(v)\n\n    const parseTime = useUTC ? utcParse(format) : timeParse(format)\n    return v => precisionFn(parseTime(v))\n}\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { scaleTime, scaleUtc } from 'd3-scale'\nimport PropTypes from 'prop-types'\nimport { createDateNormalizer, timePrecisions, TIME_PRECISION_MILLISECOND } from './timeHelpers'\n\nexport const timeScale = (\n    {\n        axis,\n        format = 'native',\n        precision = TIME_PRECISION_MILLISECOND,\n        min = 'auto',\n        max = 'auto',\n        useUTC = true,\n        nice = false,\n    },\n    xy,\n    width,\n    height\n) => {\n    const values = xy[axis]\n    const size = axis === 'x' ? width : height\n\n    const normalize = createDateNormalizer({ format, precision, useUTC })\n\n    let minValue = min\n    if (min === 'auto') {\n        minValue = values.min\n    } else if (format !== 'native') {\n        minValue = normalize(min)\n    }\n\n    let maxValue = max\n    if (max === 'auto') {\n        maxValue = values.max\n    } else if (format !== 'native') {\n        maxValue = normalize(max)\n    }\n\n    const scale = useUTC ? scaleUtc() : scaleTime()\n    scale.domain([minValue, maxValue]).range([0, size])\n    if (nice === true) scale.nice()\n    else if (typeof nice === 'object' || typeof nice === 'number') scale.nice(nice)\n\n    scale.type = 'time'\n    scale.useUTC = useUTC\n\n    return scale\n}\n\nexport const timeScalePropTypes = {\n    type: PropTypes.oneOf(['time']).isRequired,\n    format: PropTypes.string,\n    precision: PropTypes.oneOf(timePrecisions),\n    nice: PropTypes.oneOfType([PropTypes.bool, PropTypes.number, PropTypes.object]),\n}\n","import { calendar } from \"./time.js\";\nimport { utcFormat } from \"d3-time-format\";\nimport { utcYear, utcMonth, utcWeek, utcDay, utcHour, utcMinute, utcSecond, utcMillisecond } from \"d3-time\";\nimport { initRange } from \"./init.js\";\nexport default function utcTime() {\n  return initRange.apply(calendar(utcYear, utcMonth, utcWeek, utcDay, utcHour, utcMinute, utcSecond, utcMillisecond, utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]), arguments);\n}","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport PropTypes from 'prop-types'\n\nexport const bandScalePropTypes = {\n    type: PropTypes.oneOf(['band']).isRequired,\n    round: PropTypes.bool,\n}\n","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayWithoutHoles from \"./arrayWithoutHoles\";\nimport iterableToArray from \"./iterableToArray\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray\";\nimport nonIterableSpread from \"./nonIterableSpread\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}","import arrayLikeToArray from \"./arrayLikeToArray\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import defineProperty from \"./defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport uniq from 'lodash/uniq'\nimport uniqBy from 'lodash/uniqBy'\nimport sortBy from 'lodash/sortBy'\nimport last from 'lodash/last'\nimport isDate from 'lodash/isDate'\nimport { linearScale } from './linearScale'\nimport { logScale } from './logScale'\nimport { symlogScale } from './symlogScale'\nimport { pointScale } from './pointScale'\nimport { timeScale } from './timeScale'\nimport { createDateNormalizer } from './timeHelpers'\n\nexport const getOtherAxis = axis => (axis === 'x' ? 'y' : 'x')\n\nexport const compareValues = (a, b) => a === b\nexport const compareDateValues = (a, b) => a.getTime() === b.getTime()\n\nexport const computeXYScalesForSeries = (_series, xScaleSpec, yScaleSpec, width, height) => {\n    const series = _series.map(serie => ({\n        ...serie,\n        data: serie.data.map(d => ({ data: { ...d } })),\n    }))\n\n    let xy = generateSeriesXY(series, xScaleSpec, yScaleSpec)\n    if (xScaleSpec.stacked === true) {\n        stackX(yScaleSpec.type, xy, series)\n    }\n    if (yScaleSpec.stacked === true) {\n        stackY(xScaleSpec.type, xy, series)\n    }\n\n    const xScale = computeScale({ ...xScaleSpec, axis: 'x' }, xy, width, height)\n    const yScale = computeScale({ ...yScaleSpec, axis: 'y' }, xy, width, height)\n\n    series.forEach(serie => {\n        serie.data.forEach(d => {\n            d.position = {\n                x:\n                    xScale.stacked === true\n                        ? d.data.xStacked === null\n                            ? null\n                            : xScale(d.data.xStacked)\n                        : d.data.x === null\n                        ? null\n                        : xScale(d.data.x),\n                y:\n                    yScale.stacked === true\n                        ? d.data.yStacked === null\n                            ? null\n                            : yScale(d.data.yStacked)\n                        : d.data.y === null\n                        ? null\n                        : yScale(d.data.y),\n            }\n        })\n    })\n\n    return {\n        ...xy,\n        series,\n        xScale,\n        yScale,\n    }\n}\n\nexport const computeScale = (spec, xy, width, height) => {\n    if (spec.type === 'linear') return linearScale(spec, xy, width, height)\n    else if (spec.type === 'point') return pointScale(spec, xy, width, height)\n    else if (spec.type === 'time') return timeScale(spec, xy, width, height)\n    else if (spec.type === 'log') return logScale(spec, xy, width, height)\n    else if (spec.type === 'symlog') return symlogScale(spec, xy, width, height)\n}\n\nexport const generateSeriesXY = (series, xScaleSpec, yScaleSpec) => ({\n    x: generateSeriesAxis(series, 'x', xScaleSpec),\n    y: generateSeriesAxis(series, 'y', yScaleSpec),\n})\n\n/**\n * Normalize data according to scale type, (time => Date, linear => Number)\n * compute sorted unique values and min/max.\n */\nexport const generateSeriesAxis = (\n    series,\n    axis,\n    scaleSpec,\n    {\n        getValue = d => d.data[axis],\n        setValue = (d, v) => {\n            d.data[axis] = v\n        },\n    } = {}\n) => {\n    if (scaleSpec.type === 'linear') {\n        series.forEach(serie => {\n            serie.data.forEach(d => {\n                setValue(d, getValue(d) === null ? null : parseFloat(getValue(d)))\n            })\n        })\n    } else if (scaleSpec.type === 'time' && scaleSpec.format !== 'native') {\n        const parseTime = createDateNormalizer(scaleSpec)\n        series.forEach(serie => {\n            serie.data.forEach(d => {\n                setValue(d, getValue(d) === null ? null : parseTime(getValue(d)))\n            })\n        })\n    }\n\n    let all = []\n    series.forEach(serie => {\n        serie.data.forEach(d => {\n            all.push(getValue(d))\n        })\n    })\n\n    let min, max\n    if (scaleSpec.type === 'linear') {\n        all = uniq(all)\n        all = sortBy(all, v => v)\n        min = Math.min(...all)\n        max = Math.max(...all)\n    } else if (scaleSpec.type === 'time') {\n        all = uniqBy(all, v => v.getTime())\n        all = all\n            .slice(0)\n            .sort((a, b) => b - a)\n            .reverse()\n        min = all[0]\n        max = last(all)\n    } else {\n        all = uniq(all)\n        min = all[0]\n        max = last(all)\n    }\n\n    return { all, min, max }\n}\n\nexport const stackAxis = (axis, otherType, xy, series) => {\n    const otherAxis = getOtherAxis(axis)\n\n    let all = []\n    xy[otherAxis].all.forEach(v => {\n        const compare = isDate(v) ? compareDateValues : compareValues\n        const stack = []\n        series.forEach(serie => {\n            const datum = serie.data.find(d => compare(d.data[otherAxis], v))\n            let value = null\n            let stackValue = null\n            if (datum !== undefined) {\n                value = datum.data[axis]\n                if (value !== null) {\n                    const head = last(stack)\n                    if (head === undefined) {\n                        stackValue = value\n                    } else if (head !== null) {\n                        stackValue = head + value\n                    }\n                }\n                datum.data[`${axis}Stacked`] = stackValue\n            }\n            stack.push(stackValue)\n            all.push(stackValue)\n        })\n    })\n    all = all.filter(v => v !== null)\n\n    xy[axis].minStacked = Math.min(...all)\n    xy[axis].maxStacked = Math.max(...all)\n}\n\nexport const stackX = (xy, otherType, series) => stackAxis('x', xy, otherType, series)\nexport const stackY = (xy, otherType, series) => stackAxis('y', xy, otherType, series)\n\nexport const computeAxisSlices = (axis, data) => {\n    const otherAxis = getOtherAxis(axis)\n\n    return data[otherAxis].all.map(v => {\n        const slice = {\n            id: v,\n            [otherAxis]: data[`${otherAxis}Scale`](v),\n            data: [],\n        }\n        const compare = isDate(v) ? compareDateValues : compareValues\n        data.series.forEach(serie => {\n            const datum = serie.data.find(d => compare(d.data[otherAxis], v))\n            if (datum !== undefined) {\n                slice.data.push({\n                    ...datum,\n                    serie,\n                })\n            }\n        })\n        slice.data.reverse()\n\n        return slice\n    })\n}\n\nexport const computeXSlices = data => computeAxisSlices('x', data)\nexport const computeYSlices = data => computeAxisSlices('y', data)\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport PropTypes from 'prop-types'\nimport { linearScalePropTypes } from './linearScale'\nimport { logScalePropTypes } from './logScale'\nimport { symLogScalePropTypes } from './symlogScale'\nimport { pointScalePropTypes } from './pointScale'\nimport { timeScalePropTypes } from './timeScale'\nimport { bandScalePropTypes } from './bandScale'\n\nexport * from './compute'\nexport * from './linearScale'\nexport * from './logScale'\nexport * from './symlogScale'\nexport * from './pointScale'\nexport * from './timeScale'\nexport * from './timeHelpers'\nexport * from './bandScale'\n\nexport const scalePropType = PropTypes.oneOfType([\n    PropTypes.shape(linearScalePropTypes),\n    PropTypes.shape(pointScalePropTypes),\n    PropTypes.shape(timeScalePropTypes),\n    PropTypes.shape(logScalePropTypes),\n    PropTypes.shape(symLogScalePropTypes),\n    PropTypes.shape(bandScalePropTypes),\n])\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport React from 'react'\nimport styled from 'styled-components'\nimport { settingsMapper, mapAxis } from '../../../lib/settings'\n\nexport default settingsMapper(\n    {\n        axisTop: mapAxis('top'),\n        axisRight: mapAxis('right'),\n        axisBottom: mapAxis('bottom'),\n        axisLeft: mapAxis('left'),\n    },\n    {\n        exclude: ['enable axisTop', 'enable axisRight', 'enable axisBottom', 'enable axisLeft'],\n    }\n)\n"],"sourceRoot":""}